{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rediscover the joy of coding. \u00b6 Code is more dynamic, complex and intertwined than ever before. Errors cascade out of control, things update in the wrong order, and it's all connected by difficult, unreadable spaghetti. No longer. Fusion introduces modern 'reactive' concepts for managing code, so you can spend more time getting your logic right, and less time implementing buggy boilerplate code connections. Starting from simple roots, concepts neatly combine and build up with very little learning curve. At every stage, you can robustly guarantee what your code will do, and when you come back in six months, your code is easy to pick back up. Getting started guide Download Scroll down for a quick look at 3 main features. Representing change \u00b6 Fusion introduces \u2018state objects\u2019. They aren\u2019t that complex, but allow you to write dynamic code that\u2019s highly readable, behaves predictably and splits into parts easily. State objects are used to represent changeable or dynamic values in your program. You can peek at their value at any time. -- For example, suppose this function returned a state object. local currentTimeObj = getCurrentTimeStateObject () -- State objects are objects... print ( typeof ( currentTimeObj )) --> table -- ...and you can peek at their value (or \u2018state\u2019) at any time. print ( currentTimeObj : get ()) --> 0.0 task . wait ( 5 ) print ( currentTimeObj : get ()) --> 5.0 You can write out your logic using Fusion's built-in state objects. Here's the two basic ones, Value and Computed: -- This creates a state object that you can set manually. -- You can change its value using myName:set(). local myName = Value ( \"Daniel\" ) -- This creates a state object from a calculation. -- It determines its own value automatically. local myGreeting = Computed ( function () return \"Hello! My name is \" .. myName : get () end ) To watch what a state object does, you can use an Observer. For example, you can run some code when an object changes value. -- This observer watches for when the greeting changes. local myObserver = Observer ( myGreeting ) -- Let\u2019s print out the greeting when there\u2019s a new one. local disconnect = myObserver : onChange ( function () print ( myGreeting : get ()) end ) -- This will run the code above! myName : set ( \"Danny\" ) Building instances \u00b6 Fusion offers comprehensive APIs to build or enrich instances from code, so you can easily integrate with your game scripts. Fusion provides dedicated functions to create and modify instances. They allow you to easily configure your instance in one place. -- This will create a red part in the workspace. local myPart = New \"Part\" { Parent = workspace , BrickColor = BrickColor . Red () } -- This adds on some extras after. Hydrate ( myPart ) { Material = \"Wood\" , Transparency = 0.5 } They offer powerful features to keep all your instance code close together. For example, you can listen for events or add children. -- This will create a rounded button. -- When you click it, it\u2019ll greet you. local myButton = New \"TextButton\" { Text = \"Click me\" , [ OnEvent \"Activated\" ] = function () print ( \"Hello! I\u2019m a button.\" ) end , [ Children ] = New \"UICorner\" { CornerRadius = UDim . new ( 1 , 0 ) } } You can also plug state objects in directly. The instance updates as the state object changes value. -- Creating a state object you can control... local message = Value ( \"Hello!\" ) -- Now you can plug that state object into the Text property. local myLabel = New \"TextLabel\" { Text = message } print ( myLabel . Text ) --> Hello! -- The Text property now responds to changes: message : set ( \"Goodbye!\" ) print ( myLabel . Text ) --> Goodbye! Animating anything \u00b6 Fusion gives you best-in-class tools to animate anything you can think of, completely out of the box. Fusion lets you use tweens or physically based springs to animate any value you want - not just instance properties. -- This could be anything you want, as long as it's a state object. local health = Value ( 100 ) -- Easily make it tween between values... local style = TweenInfo . new ( 0.5 , Enum . EasingStyle . Quad ) local tweenHealth = Tween ( health , style ) -- ...or use spring physics for extra responsiveness. local springHealth = Spring ( health , 30 , 0.9 ) Tween and Spring are state objects, just like anything else that changes in your program. That means it's easy to process them afterwards. -- You can round the animated health to whole numbers. local wholeHealth = Computed ( function () return math . round ( health : get ()) end ) -- You can format it as text and put it in some UI, too. local myText = New \"TextLabel\" { Text = Computed ( function () return \"Health: \" .. wholeHealth : get () end ) } You can even configure your animations using state objects, too. This makes it easy to swap out animations or disable them when needed. -- Define some tweening styles... local TWEEN_FAST = TweenInfo . new ( 0.5 , Enum . EasingStyle . Elastic ) local TWEEN_SLOW = TweenInfo . new ( 2 , Enum . EasingStyle . Sine ) -- Choose more dramatic styles at low health... local style = Computed ( function () return if health : get () < 20 then TWEEN_FAST else TWEEN_SLOW end ) -- Plug it right into your animation! local tweenHealth = Tween ( health , style ) Sparked your curiosity? \u00b6 Those are the core features of Fusion, and they're the foundation of everything - whether it\u2019s complex 3D UI systems, procedural animation, or just a hello world app. It all fits on one page, and that's the magic. You don't have to keep relearning ever-more-complex tools as you scale up from prototype to product. If you'd like to learn in depth, we have a comprehensive beginner's tutorial track , complete with diagrams, examples and code. We would love to welcome you into our warm, vibrant community. Hopefully, we'll see you there :)","title":"Home"},{"location":"#rediscover-the-joy-of-coding","text":"Code is more dynamic, complex and intertwined than ever before. Errors cascade out of control, things update in the wrong order, and it's all connected by difficult, unreadable spaghetti. No longer. Fusion introduces modern 'reactive' concepts for managing code, so you can spend more time getting your logic right, and less time implementing buggy boilerplate code connections. Starting from simple roots, concepts neatly combine and build up with very little learning curve. At every stage, you can robustly guarantee what your code will do, and when you come back in six months, your code is easy to pick back up. Getting started guide Download Scroll down for a quick look at 3 main features.","title":"Rediscover the joy of coding."},{"location":"#representing-change","text":"Fusion introduces \u2018state objects\u2019. They aren\u2019t that complex, but allow you to write dynamic code that\u2019s highly readable, behaves predictably and splits into parts easily. State objects are used to represent changeable or dynamic values in your program. You can peek at their value at any time. -- For example, suppose this function returned a state object. local currentTimeObj = getCurrentTimeStateObject () -- State objects are objects... print ( typeof ( currentTimeObj )) --> table -- ...and you can peek at their value (or \u2018state\u2019) at any time. print ( currentTimeObj : get ()) --> 0.0 task . wait ( 5 ) print ( currentTimeObj : get ()) --> 5.0 You can write out your logic using Fusion's built-in state objects. Here's the two basic ones, Value and Computed: -- This creates a state object that you can set manually. -- You can change its value using myName:set(). local myName = Value ( \"Daniel\" ) -- This creates a state object from a calculation. -- It determines its own value automatically. local myGreeting = Computed ( function () return \"Hello! My name is \" .. myName : get () end ) To watch what a state object does, you can use an Observer. For example, you can run some code when an object changes value. -- This observer watches for when the greeting changes. local myObserver = Observer ( myGreeting ) -- Let\u2019s print out the greeting when there\u2019s a new one. local disconnect = myObserver : onChange ( function () print ( myGreeting : get ()) end ) -- This will run the code above! myName : set ( \"Danny\" )","title":"Representing change"},{"location":"#building-instances","text":"Fusion offers comprehensive APIs to build or enrich instances from code, so you can easily integrate with your game scripts. Fusion provides dedicated functions to create and modify instances. They allow you to easily configure your instance in one place. -- This will create a red part in the workspace. local myPart = New \"Part\" { Parent = workspace , BrickColor = BrickColor . Red () } -- This adds on some extras after. Hydrate ( myPart ) { Material = \"Wood\" , Transparency = 0.5 } They offer powerful features to keep all your instance code close together. For example, you can listen for events or add children. -- This will create a rounded button. -- When you click it, it\u2019ll greet you. local myButton = New \"TextButton\" { Text = \"Click me\" , [ OnEvent \"Activated\" ] = function () print ( \"Hello! I\u2019m a button.\" ) end , [ Children ] = New \"UICorner\" { CornerRadius = UDim . new ( 1 , 0 ) } } You can also plug state objects in directly. The instance updates as the state object changes value. -- Creating a state object you can control... local message = Value ( \"Hello!\" ) -- Now you can plug that state object into the Text property. local myLabel = New \"TextLabel\" { Text = message } print ( myLabel . Text ) --> Hello! -- The Text property now responds to changes: message : set ( \"Goodbye!\" ) print ( myLabel . Text ) --> Goodbye!","title":"Building instances"},{"location":"#animating-anything","text":"Fusion gives you best-in-class tools to animate anything you can think of, completely out of the box. Fusion lets you use tweens or physically based springs to animate any value you want - not just instance properties. -- This could be anything you want, as long as it's a state object. local health = Value ( 100 ) -- Easily make it tween between values... local style = TweenInfo . new ( 0.5 , Enum . EasingStyle . Quad ) local tweenHealth = Tween ( health , style ) -- ...or use spring physics for extra responsiveness. local springHealth = Spring ( health , 30 , 0.9 ) Tween and Spring are state objects, just like anything else that changes in your program. That means it's easy to process them afterwards. -- You can round the animated health to whole numbers. local wholeHealth = Computed ( function () return math . round ( health : get ()) end ) -- You can format it as text and put it in some UI, too. local myText = New \"TextLabel\" { Text = Computed ( function () return \"Health: \" .. wholeHealth : get () end ) } You can even configure your animations using state objects, too. This makes it easy to swap out animations or disable them when needed. -- Define some tweening styles... local TWEEN_FAST = TweenInfo . new ( 0.5 , Enum . EasingStyle . Elastic ) local TWEEN_SLOW = TweenInfo . new ( 2 , Enum . EasingStyle . Sine ) -- Choose more dramatic styles at low health... local style = Computed ( function () return if health : get () < 20 then TWEEN_FAST else TWEEN_SLOW end ) -- Plug it right into your animation! local tweenHealth = Tween ( health , style )","title":"Animating anything"},{"location":"#sparked-your-curiosity","text":"Those are the core features of Fusion, and they're the foundation of everything - whether it\u2019s complex 3D UI systems, procedural animation, or just a hello world app. It all fits on one page, and that's the magic. You don't have to keep relearning ever-more-complex tools as you scale up from prototype to product. If you'd like to learn in depth, we have a comprehensive beginner's tutorial track , complete with diagrams, examples and code. We would love to welcome you into our warm, vibrant community. Hopefully, we'll see you there :)","title":"Sparked your curiosity?"},{"location":"api-reference/","text":"API Reference \u00b6 Welcome to the API Reference! This is where you can find more technical documentation about what the Fusion library provides. This isn't a beginner's guide. For a guided experience, try the tutorials! Navigation \u00b6 Using the sidebar on the left, you can find API members grouped by category. Alternatively, you can search for APIs using the search box at the top of the page. Commonly Used \u00b6 General \u00b6 Errors State Instances Animation State \u00b6 Computed ForKeys ForPairs ForValues Observer Value Instances \u00b6 Hydrate New Animation \u00b6 Spring Tween","title":"Home"},{"location":"api-reference/#api-reference","text":"Welcome to the API Reference! This is where you can find more technical documentation about what the Fusion library provides. This isn't a beginner's guide. For a guided experience, try the tutorials!","title":"API Reference"},{"location":"api-reference/#navigation","text":"Using the sidebar on the left, you can find API members grouped by category. Alternatively, you can search for APIs using the search box at the top of the page.","title":"Navigation"},{"location":"api-reference/#commonly-used","text":"","title":"Commonly Used"},{"location":"api-reference/#general","text":"Errors State Instances Animation","title":"General"},{"location":"api-reference/#state","text":"Computed ForKeys ForPairs ForValues Observer Value","title":"State"},{"location":"api-reference/#instances","text":"Hydrate New","title":"Instances"},{"location":"api-reference/#animation","text":"Spring Tween","title":"Animation"},{"location":"api-reference/animation/","text":"Fusion Animation \u00b6 Utilities for adding transitions and animations to state objects. Types \u00b6 Animatable State Objects \u00b6 Spring Tween","title":"Index"},{"location":"api-reference/animation/#animation","text":"Utilities for adding transitions and animations to state objects.","title":"Animation"},{"location":"api-reference/animation/#types","text":"Animatable","title":"Types"},{"location":"api-reference/animation/#state-objects","text":"Spring Tween","title":"State Objects"},{"location":"api-reference/animation/animatable/","text":"Fusion Animation Animatable type since v0.1 \u00b6 Represents types that can be animated component-wise. If a data type can reasonably be represented as a fixed-length array of numbers, then it is animatable. Any data type present in this type can be animated by Fusion. number | CFrame | Color3 | ColorSequenceKeypoint | DateTime | NumberRange | NumberSequenceKeypoint | PhysicalProperties | Ray | Rect | Region3 | Region3int16 | UDim | UDim2 | Vector2 | Vector2int16 | Vector3 | Vector3int16 Example Usage \u00b6 local DEFAULT_TWEEN = TweenInfo . new ( 0.25 , Enum . EasingStyle . Quint ) local function withDefaultTween ( target : StateObject < Animatable > ) return Tween ( target , DEFAULT_TWEEN ) end Animatability \u00b6 Tween and Spring work by animating the individual components of whatever data they're working with. For example, if you tween a Vector3, the X, Y and Z components will have the tween individually applied to each. This is a very flexible definition of animatability, but it does not cover all data types. For example, it still doesn't make sense to animate a string, a boolean, or nil. By default, Tween and Spring will just snap to the goal value if you try to smoothly animate something that is not animatable. However, if you want to try and prevent the use of non-animatable types statically, you can use this type definition in your own code.","title":"Animatable"},{"location":"api-reference/animation/animatable/#animatable-type-since-v01","text":"Represents types that can be animated component-wise. If a data type can reasonably be represented as a fixed-length array of numbers, then it is animatable. Any data type present in this type can be animated by Fusion. number | CFrame | Color3 | ColorSequenceKeypoint | DateTime | NumberRange | NumberSequenceKeypoint | PhysicalProperties | Ray | Rect | Region3 | Region3int16 | UDim | UDim2 | Vector2 | Vector2int16 | Vector3 | Vector3int16","title":"Animatable type since v0.1"},{"location":"api-reference/animation/animatable/#example-usage","text":"local DEFAULT_TWEEN = TweenInfo . new ( 0.25 , Enum . EasingStyle . Quint ) local function withDefaultTween ( target : StateObject < Animatable > ) return Tween ( target , DEFAULT_TWEEN ) end","title":"Example Usage"},{"location":"api-reference/animation/animatable/#animatability","text":"Tween and Spring work by animating the individual components of whatever data they're working with. For example, if you tween a Vector3, the X, Y and Z components will have the tween individually applied to each. This is a very flexible definition of animatability, but it does not cover all data types. For example, it still doesn't make sense to animate a string, a boolean, or nil. By default, Tween and Spring will just snap to the goal value if you try to smoothly animate something that is not animatable. However, if you want to try and prevent the use of non-animatable types statically, you can use this type definition in your own code.","title":"Animatability"},{"location":"api-reference/animation/spring/","text":"Fusion Animation Spring state object since v0.1 \u00b6 Follows the value of another state object, as if linked by a damped spring. If the state object is not animatable , the spring will just snap to the goal value. ( goal : StateObject < T > , speed : CanBeState < number > ? , damping : CanBeState < number > ? ) -> Spring < T > Parameters \u00b6 goal - The state object whose value should be followed. speed - Scales the time it takes for the spring to move (but does not directly correlate to a duration). Defaults to 10 . damping - Affects the friction/damping which the spring experiences. 0 represents no friction, and 1 is just enough friction to reach the goal without overshooting or oscillating. Defaults to 1 . Methods \u00b6 since v0.2 Spring:setPosition() \u00b6 Instantaneously moves the spring to a new position. This does not affect the velocity of the spring. If the given value doesn't have the same type as the spring's current value, the position will snap instantly to the new value. ( newPosition : T ) -> () Parameters \u00b6 newPosition - The value the spring's position should jump to. since v0.2 Spring:setVelocity() \u00b6 Overwrites the velocity of this spring. This does not have an immediate effect on the position of the spring. If the given value doesn't have the same type as the spring's current value, the velocity will snap instantly to the new value. ( newVelocity : T ) -> () Parameters \u00b6 newVelocity - The value the spring's velocity should jump to. since v0.2 Spring:addVelocity() \u00b6 Adds to the velocity of this spring. This does not have an immediate effect on the position of the spring. If the given value doesn't have the same type as the spring's current value, the velocity will snap instantly to the new value. ( deltaVelocity : T ) -> () Parameters \u00b6 deltaVelocity - The velocity to add to the spring. Example Usage \u00b6 local position = Value ( UDim2 . fromOffset ( 25 , 50 )) local smoothPosition = Spring ( position , 25 , 0.6 ) local ui = New \"Frame\" { Parent = PlayerGui . ScreenGui , Position = smoothPosition } while true do task . wait ( 5 ) -- apply an impulse smoothPosition : addVelocity ( UDim2 . fromOffset ( - 10 , 10 )) end","title":"Spring"},{"location":"api-reference/animation/spring/#spring-state-object-since-v01","text":"Follows the value of another state object, as if linked by a damped spring. If the state object is not animatable , the spring will just snap to the goal value. ( goal : StateObject < T > , speed : CanBeState < number > ? , damping : CanBeState < number > ? ) -> Spring < T >","title":"Spring state object since v0.1"},{"location":"api-reference/animation/spring/#parameters","text":"goal - The state object whose value should be followed. speed - Scales the time it takes for the spring to move (but does not directly correlate to a duration). Defaults to 10 . damping - Affects the friction/damping which the spring experiences. 0 represents no friction, and 1 is just enough friction to reach the goal without overshooting or oscillating. Defaults to 1 .","title":"Parameters"},{"location":"api-reference/animation/spring/#methods","text":"since v0.2","title":"Methods"},{"location":"api-reference/animation/spring/#springsetposition","text":"Instantaneously moves the spring to a new position. This does not affect the velocity of the spring. If the given value doesn't have the same type as the spring's current value, the position will snap instantly to the new value. ( newPosition : T ) -> ()","title":"Spring:setPosition()"},{"location":"api-reference/animation/spring/#parameters_1","text":"newPosition - The value the spring's position should jump to. since v0.2","title":"Parameters"},{"location":"api-reference/animation/spring/#springsetvelocity","text":"Overwrites the velocity of this spring. This does not have an immediate effect on the position of the spring. If the given value doesn't have the same type as the spring's current value, the velocity will snap instantly to the new value. ( newVelocity : T ) -> ()","title":"Spring:setVelocity()"},{"location":"api-reference/animation/spring/#parameters_2","text":"newVelocity - The value the spring's velocity should jump to. since v0.2","title":"Parameters"},{"location":"api-reference/animation/spring/#springaddvelocity","text":"Adds to the velocity of this spring. This does not have an immediate effect on the position of the spring. If the given value doesn't have the same type as the spring's current value, the velocity will snap instantly to the new value. ( deltaVelocity : T ) -> ()","title":"Spring:addVelocity()"},{"location":"api-reference/animation/spring/#parameters_3","text":"deltaVelocity - The velocity to add to the spring.","title":"Parameters"},{"location":"api-reference/animation/spring/#example-usage","text":"local position = Value ( UDim2 . fromOffset ( 25 , 50 )) local smoothPosition = Spring ( position , 25 , 0.6 ) local ui = New \"Frame\" { Parent = PlayerGui . ScreenGui , Position = smoothPosition } while true do task . wait ( 5 ) -- apply an impulse smoothPosition : addVelocity ( UDim2 . fromOffset ( - 10 , 10 )) end","title":"Example Usage"},{"location":"api-reference/animation/tween/","text":"Fusion Animation Tween state object since v0.1 \u00b6 Follows the value of another state object, by tweening towards it. If the state object is not animatable , the tween will just snap to the goal value. ( goal : StateObject < T > , tweenInfo : CanBeState < TweenInfo > ? ) -> Tween < T > Parameters \u00b6 goal - The state object whose value should be followed. tweenInfo - The style of tween to use when moving to the goal. Defaults to TweenInfo.new() . Example Usage \u00b6 local position = Value ( UDim2 . fromOffset ( 25 , 50 )) local smoothPosition = Tween ( position , TweenInfo . new ( 2 )) local ui = New \"Frame\" { Parent = PlayerGui . ScreenGui , Position = smoothPosition } while true do task . wait ( 5 ) position : set ( peek ( position ) + UDim2 . fromOffset ( 100 , 100 )) end","title":"Tween"},{"location":"api-reference/animation/tween/#tween-state-object-since-v01","text":"Follows the value of another state object, by tweening towards it. If the state object is not animatable , the tween will just snap to the goal value. ( goal : StateObject < T > , tweenInfo : CanBeState < TweenInfo > ? ) -> Tween < T >","title":"Tween state object since v0.1"},{"location":"api-reference/animation/tween/#parameters","text":"goal - The state object whose value should be followed. tweenInfo - The style of tween to use when moving to the goal. Defaults to TweenInfo.new() .","title":"Parameters"},{"location":"api-reference/animation/tween/#example-usage","text":"local position = Value ( UDim2 . fromOffset ( 25 , 50 )) local smoothPosition = Tween ( position , TweenInfo . new ( 2 )) local ui = New \"Frame\" { Parent = PlayerGui . ScreenGui , Position = smoothPosition } while true do task . wait ( 5 ) position : set ( peek ( position ) + UDim2 . fromOffset ( 100 , 100 )) end","title":"Example Usage"},{"location":"api-reference/errors/","text":"Fusion Errors \u00b6 Whenever Fusion outputs any errors or messages to the console, it will have a short error ID at the end. This is used to uniquely identify what kind of error or message you're seeing. Use the search box below to paste in or type an error ID, and it will scroll to the details for you.","title":"Index"},{"location":"api-reference/errors/#errors","text":"Whenever Fusion outputs any errors or messages to the console, it will have a short error ID at the end. This is used to uniquely identify what kind of error or message you're seeing. Use the search box below to paste in or type an error ID, and it will scroll to the details for you.","title":"Errors"},{"location":"api-reference/instances/","text":"Fusion Instances \u00b6 Utilities for connecting state objects to instances via code. Types \u00b6 Child Component SpecialKey Functions \u00b6 Attribute AttributeChange AttributeOut Hydrate New OnChange OnEvent Out Special Keys \u00b6 Children Cleanup Ref","title":"Index"},{"location":"api-reference/instances/#instances","text":"Utilities for connecting state objects to instances via code.","title":"Instances"},{"location":"api-reference/instances/#types","text":"Child Component SpecialKey","title":"Types"},{"location":"api-reference/instances/#functions","text":"Attribute AttributeChange AttributeOut Hydrate New OnChange OnEvent Out","title":"Functions"},{"location":"api-reference/instances/#special-keys","text":"Children Cleanup Ref","title":"Special Keys"},{"location":"api-reference/instances/attribute/","text":"Fusion Instances Attribute special key since v0.3 \u00b6 A special key for adding attributes to instances. Parameters \u00b6 ( attributeName : string ) -> SpecialKey Example Usage \u00b6 local ammoValue = Value ( 10 ) local label = New \"TextLabel\" { [ Attribute \"Ammo\" ] = ammoValue } print ( label : GetAttribute ( \"Ammo\" )) -- 10 Technical Details \u00b6 This special key runs at the self stage.","title":"Attribute"},{"location":"api-reference/instances/attribute/#attribute-special-key-since-v03","text":"A special key for adding attributes to instances.","title":"Attribute special key since v0.3"},{"location":"api-reference/instances/attribute/#parameters","text":"( attributeName : string ) -> SpecialKey","title":"Parameters"},{"location":"api-reference/instances/attribute/#example-usage","text":"local ammoValue = Value ( 10 ) local label = New \"TextLabel\" { [ Attribute \"Ammo\" ] = ammoValue } print ( label : GetAttribute ( \"Ammo\" )) -- 10","title":"Example Usage"},{"location":"api-reference/instances/attribute/#technical-details","text":"This special key runs at the self stage.","title":"Technical Details"},{"location":"api-reference/instances/attributechange/","text":"Fusion Instances AttributeChange function since v0.3 \u00b6 Given an attribute name, returns a special key which connects to that attribute's change events. ( attributeName : string ) -> SpecialKey Parameters \u00b6 attributeName - The name of the attribute to listen for changes to. Returns \u00b6 A special key which runs at the observer stage. When applied to an instance, it connects to the attribute change signal on the instance for the given property. The handler is run with the attribute's value after every change. Example Usage \u00b6 New \"TextBox\" { [ AttributeChange \"State\" ] = function ( newValue ) print ( \"The state attribute changed to:\" , newValue ) end }","title":"AttributeChange"},{"location":"api-reference/instances/attributechange/#attributechange-function-since-v03","text":"Given an attribute name, returns a special key which connects to that attribute's change events. ( attributeName : string ) -> SpecialKey","title":"AttributeChange function since v0.3"},{"location":"api-reference/instances/attributechange/#parameters","text":"attributeName - The name of the attribute to listen for changes to.","title":"Parameters"},{"location":"api-reference/instances/attributechange/#returns","text":"A special key which runs at the observer stage. When applied to an instance, it connects to the attribute change signal on the instance for the given property. The handler is run with the attribute's value after every change.","title":"Returns"},{"location":"api-reference/instances/attributechange/#example-usage","text":"New \"TextBox\" { [ AttributeChange \"State\" ] = function ( newValue ) print ( \"The state attribute changed to:\" , newValue ) end }","title":"Example Usage"},{"location":"api-reference/instances/attributeout/","text":"Fusion Instances AttributeOut function since v0.3 \u00b6 Given an attribute name, returns a special key which outputs the value of attribute's with that name. It should be used with a value object. ( attributeName : string ) -> SpecialKey Parameters \u00b6 attributeName - The name of the attribute to output the value of. Returns \u00b6 A special key which runs at the observer stage. When applied to an instance, it sets the value object equal to the attribute with the given name. It then listens for further changes and updates the value object accordingly. Example Usage \u00b6 local ammo = Value () New \"Configuration\" { [ Attribute \"Ammo\" ] = ammo , [ AttributeOut \"Ammo\" ] = ammo } Observer ( ammo ): onChange ( function () print ( \"Current ammo:\" , peek ( ammo )) end )","title":"AttributeOut"},{"location":"api-reference/instances/attributeout/#attributeout-function-since-v03","text":"Given an attribute name, returns a special key which outputs the value of attribute's with that name. It should be used with a value object. ( attributeName : string ) -> SpecialKey","title":"AttributeOut function since v0.3"},{"location":"api-reference/instances/attributeout/#parameters","text":"attributeName - The name of the attribute to output the value of.","title":"Parameters"},{"location":"api-reference/instances/attributeout/#returns","text":"A special key which runs at the observer stage. When applied to an instance, it sets the value object equal to the attribute with the given name. It then listens for further changes and updates the value object accordingly.","title":"Returns"},{"location":"api-reference/instances/attributeout/#example-usage","text":"local ammo = Value () New \"Configuration\" { [ Attribute \"Ammo\" ] = ammo , [ AttributeOut \"Ammo\" ] = ammo } Observer ( ammo ): onChange ( function () print ( \"Current ammo:\" , peek ( ammo )) end )","title":"Example Usage"},{"location":"api-reference/instances/child/","text":"Fusion Instances Child type since v0.2 \u00b6 Represents some UI which can be parented to an ancestor, usually via Children . The most simple kind of child is a single instance, though arrays can be used to parent multiple instances at once and state objects can be used to make the children dynamic. Instance | {[ any ]: Child } | StateObject < Child > Example Usage \u00b6 -- all of the following fit the definition of Child local child1 : Child = New \"Folder\" {} local child2 : Child = { New \"Folder\" {}, New \"Folder\" {}, New \"Folder\" {} } local child3 : Child = Computed ( function () return New \"Folder\" {} end ) local child4 : Child = { Computed ( function () return New \"Folder\" {} end ), { New \"Folder\" {}, New \"Folder\" {}} }","title":"Child"},{"location":"api-reference/instances/child/#child-type-since-v02","text":"Represents some UI which can be parented to an ancestor, usually via Children . The most simple kind of child is a single instance, though arrays can be used to parent multiple instances at once and state objects can be used to make the children dynamic. Instance | {[ any ]: Child } | StateObject < Child >","title":"Child type since v0.2"},{"location":"api-reference/instances/child/#example-usage","text":"-- all of the following fit the definition of Child local child1 : Child = New \"Folder\" {} local child2 : Child = { New \"Folder\" {}, New \"Folder\" {}, New \"Folder\" {} } local child3 : Child = Computed ( function () return New \"Folder\" {} end ) local child4 : Child = { Computed ( function () return New \"Folder\" {} end ), { New \"Folder\" {}, New \"Folder\" {}} }","title":"Example Usage"},{"location":"api-reference/instances/children/","text":"Fusion Instances Children special key since v0.1 \u00b6 Allows parenting children to an instance, both statically and dynamically. Example Usage \u00b6 local example = New \"Folder\" { [ Children ] = New \"StringValue\" { Value = \"I'm parented to the Folder!\" } } Processing Children \u00b6 A 'child' is defined (recursively) as: an instance a state object containing children an array of children Since this definition is recursive, arrays and state objects can be nested; that is, the following code is valid: local example = New \"Folder\" { [ Children ] = { { { New \"StringValue\" { Value = \"I'm parented to the Folder!\" } } } } } This behaviour is especially useful when working with components - the following component can return multiple instances to be parented without disrupting the code next to it: local function Component ( props ) return { New \"TextLabel\" { LayoutOrder = 1 , Text = \"Instance one\" }, New \"TextLabel\" { LayoutOrder = 2 , Text = \"Instance two\" } } end local parent = New \"Frame\" { Children = { New \"UIListLayout\" { SortOrder = \"LayoutOrder\" }, Component {} } } When using a state object as a child, Children will interpret the stored value as children and watch for changes. When the value of the state object changes, it'll unparent the old children and parent the new children. Note As with bound properties, updates are deferred to the next render step, and so parenting won't occur right away. local child1 = New \"Folder\" { Name = \"Child one\" } local child2 = New \"Folder\" { Name = \"Child two\" } local childState = Value ( child1 ) local parent = New \"Folder\" { [ Children ] = childState } print ( parent : GetChildren ()) -- { Child one } childState : set ( child2 ) wait ( 1 ) -- wait for deferred updates to run print ( parent : GetChildren ()) -- { Child two } Warning When using state objects, note that old children won't be destroyed, only unparented - it's up to you to decide if/when children need to be destroyed. Technical Details \u00b6 This special key runs at the descendants stage. On cleanup, all children are unparented, as if wrapped in a state object that has changed to nil.","title":"Children"},{"location":"api-reference/instances/children/#children-special-key-since-v01","text":"Allows parenting children to an instance, both statically and dynamically.","title":"Children special key since v0.1"},{"location":"api-reference/instances/children/#example-usage","text":"local example = New \"Folder\" { [ Children ] = New \"StringValue\" { Value = \"I'm parented to the Folder!\" } }","title":"Example Usage"},{"location":"api-reference/instances/children/#processing-children","text":"A 'child' is defined (recursively) as: an instance a state object containing children an array of children Since this definition is recursive, arrays and state objects can be nested; that is, the following code is valid: local example = New \"Folder\" { [ Children ] = { { { New \"StringValue\" { Value = \"I'm parented to the Folder!\" } } } } } This behaviour is especially useful when working with components - the following component can return multiple instances to be parented without disrupting the code next to it: local function Component ( props ) return { New \"TextLabel\" { LayoutOrder = 1 , Text = \"Instance one\" }, New \"TextLabel\" { LayoutOrder = 2 , Text = \"Instance two\" } } end local parent = New \"Frame\" { Children = { New \"UIListLayout\" { SortOrder = \"LayoutOrder\" }, Component {} } } When using a state object as a child, Children will interpret the stored value as children and watch for changes. When the value of the state object changes, it'll unparent the old children and parent the new children. Note As with bound properties, updates are deferred to the next render step, and so parenting won't occur right away. local child1 = New \"Folder\" { Name = \"Child one\" } local child2 = New \"Folder\" { Name = \"Child two\" } local childState = Value ( child1 ) local parent = New \"Folder\" { [ Children ] = childState } print ( parent : GetChildren ()) -- { Child one } childState : set ( child2 ) wait ( 1 ) -- wait for deferred updates to run print ( parent : GetChildren ()) -- { Child two } Warning When using state objects, note that old children won't be destroyed, only unparented - it's up to you to decide if/when children need to be destroyed.","title":"Processing Children"},{"location":"api-reference/instances/children/#technical-details","text":"This special key runs at the descendants stage. On cleanup, all children are unparented, as if wrapped in a state object that has changed to nil.","title":"Technical Details"},{"location":"api-reference/instances/cleanup/","text":"Fusion Instances Cleanup special key since v0.2 \u00b6 Cleans up all items given to it when the instance is destroyed, equivalent to passing the items to Fusion.cleanup . Example Usage \u00b6 local example1 = New \"Folder\" { [ Cleanup ] = function () print ( \"I'm in danger!\" ) end } local example2 = New \"Folder\" { [ Cleanup ] = example1 } local example3 = New \"Folder\" { [ Cleanup ] = { RunService . RenderStepped : Connect ( print ), function () print ( \"I'm in danger also!\" ) end , example2 } } example3 : Destroy () Technical Details \u00b6 This special key runs at the observer stage.","title":"Cleanup"},{"location":"api-reference/instances/cleanup/#cleanup-special-key-since-v02","text":"Cleans up all items given to it when the instance is destroyed, equivalent to passing the items to Fusion.cleanup .","title":"Cleanup special key since v0.2"},{"location":"api-reference/instances/cleanup/#example-usage","text":"local example1 = New \"Folder\" { [ Cleanup ] = function () print ( \"I'm in danger!\" ) end } local example2 = New \"Folder\" { [ Cleanup ] = example1 } local example3 = New \"Folder\" { [ Cleanup ] = { RunService . RenderStepped : Connect ( print ), function () print ( \"I'm in danger also!\" ) end , example2 } } example3 : Destroy ()","title":"Example Usage"},{"location":"api-reference/instances/cleanup/#technical-details","text":"This special key runs at the observer stage.","title":"Technical Details"},{"location":"api-reference/instances/component/","text":"Fusion Instances Component type since v0.2 \u00b6 The standard type signature for UI components. They accept a property table and return a child type . ( props : {[ any ]: any }) -> Child Example Usage \u00b6 -- create a Button component local function Button ( props ) return New \"TextButton\" { Text = props . Text } end -- the Button component is compatible with the Component type local myComponent : Component = Button","title":"Component"},{"location":"api-reference/instances/component/#component-type-since-v02","text":"The standard type signature for UI components. They accept a property table and return a child type . ( props : {[ any ]: any }) -> Child","title":"Component type since v0.2"},{"location":"api-reference/instances/component/#example-usage","text":"-- create a Button component local function Button ( props ) return New \"TextButton\" { Text = props . Text } end -- the Button component is compatible with the Component type local myComponent : Component = Button","title":"Example Usage"},{"location":"api-reference/instances/hydrate/","text":"Fusion Instances Hydrate function since v0.2 \u00b6 Given an instance, returns a component which modifies that instance. The property table may specify properties to set on the instance, or include special keys for more advanced operations. ( target : Instance ) -> Component Parameters \u00b6 target - the instance which the component should modify Returns \u00b6 A component function. When called, it populates the target instance using the property table, then returns the target instance. Example Usage \u00b6 local myButton : TextButton = Hydrate ( PlayerGui . ScreenGui . TextButton ) { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Hello, world!\" , [ OnEvent \"Activated\" ] = function () print ( \"The button was clicked!\" ) end , [ OnChange \"Name\" ] = function ( newName ) print ( \"The button was renamed to:\" , newName ) end , [ Children ] = New \"UICorner\" { CornerRadius = UDim . new ( 0 , 8 ) } } Property Table Processing \u00b6 The props table uses a mix of string and special keys to specify attributes of the instance which should be set. String keys are treated as property declarations - values passed in will be set upon the instance: local example = Hydrate ( workspace . Part ) { -- sets the Position property Position = Vector3 . new ( 1 , 2 , 3 ) } Passing a state object to a string key will bind the property value; when the value of the object changes, the property will update to match on the next resumption step: local myName = Value ( \"Bob\" ) local example = Hydrate ( workspace . Part ) { -- initially, the Name will be set to Bob Name = myName } -- change the state object to store \"John\" -- on the next resumption step, the part's Name will change to John myName : set ( \"John\" ) Special keys, such as Children or OnEvent , may also be used as keys in the property table. For more information about how special keys work, see the SpecialKey page.","title":"Hydrate"},{"location":"api-reference/instances/hydrate/#hydrate-function-since-v02","text":"Given an instance, returns a component which modifies that instance. The property table may specify properties to set on the instance, or include special keys for more advanced operations. ( target : Instance ) -> Component","title":"Hydrate function since v0.2"},{"location":"api-reference/instances/hydrate/#parameters","text":"target - the instance which the component should modify","title":"Parameters"},{"location":"api-reference/instances/hydrate/#returns","text":"A component function. When called, it populates the target instance using the property table, then returns the target instance.","title":"Returns"},{"location":"api-reference/instances/hydrate/#example-usage","text":"local myButton : TextButton = Hydrate ( PlayerGui . ScreenGui . TextButton ) { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Hello, world!\" , [ OnEvent \"Activated\" ] = function () print ( \"The button was clicked!\" ) end , [ OnChange \"Name\" ] = function ( newName ) print ( \"The button was renamed to:\" , newName ) end , [ Children ] = New \"UICorner\" { CornerRadius = UDim . new ( 0 , 8 ) } }","title":"Example Usage"},{"location":"api-reference/instances/hydrate/#property-table-processing","text":"The props table uses a mix of string and special keys to specify attributes of the instance which should be set. String keys are treated as property declarations - values passed in will be set upon the instance: local example = Hydrate ( workspace . Part ) { -- sets the Position property Position = Vector3 . new ( 1 , 2 , 3 ) } Passing a state object to a string key will bind the property value; when the value of the object changes, the property will update to match on the next resumption step: local myName = Value ( \"Bob\" ) local example = Hydrate ( workspace . Part ) { -- initially, the Name will be set to Bob Name = myName } -- change the state object to store \"John\" -- on the next resumption step, the part's Name will change to John myName : set ( \"John\" ) Special keys, such as Children or OnEvent , may also be used as keys in the property table. For more information about how special keys work, see the SpecialKey page.","title":"Property Table Processing"},{"location":"api-reference/instances/new/","text":"Fusion Instances New function since v0.1 \u00b6 Given a class name, returns a component which creates instances of that class. The property table may specify properties to set on the instance, or include special keys for more advanced operations. ( className : string ) -> Component Parameters \u00b6 className - the instance class that should be created Returns \u00b6 A component function. When called, it creates a new instance of the given class, populates it using the property table, and returns it. Example Usage \u00b6 local myButton : TextButton = New \"TextButton\" { Parent = Players . LocalPlayer . PlayerGui , Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Hello, world!\" , [ OnEvent \"Activated\" ] = function () print ( \"The button was clicked!\" ) end , [ OnChange \"Name\" ] = function ( newName ) print ( \"The button was renamed to:\" , newName ) end , [ Children ] = New \"UICorner\" { CornerRadius = UDim . new ( 0 , 8 ) } } Property Table Processing \u00b6 The props table uses a mix of string and special keys to specify attributes of the instance which should be set. String keys are treated as property declarations - values passed in will be set upon the instance: local example = New \"Part\" { -- sets the Position property Position = Vector3 . new ( 1 , 2 , 3 ) } Passing a state object to a string key will bind the property value; when the value of the object changes, the property will update to match on the next resumption step: local myName = State ( \"Bob\" ) local example = New \"Part\" { -- initially, the Name will be set to Bob Name = myName } -- change the state object to store \"John\" -- on the next resumption step, the part's Name will change to John myName : set ( \"John\" ) Special keys, such as Children or OnEvent , may also be used as keys in the property table. For more information about how special keys work, see the SpecialKey page. Default Properties \u00b6 The New function provides its own set of 'sensible default' property values for some class types, which will be used in place of Roblox defaults. This is done to opt out of some legacy features and unhelpful defaults. You can see the default properties Fusion uses here.","title":"New"},{"location":"api-reference/instances/new/#new-function-since-v01","text":"Given a class name, returns a component which creates instances of that class. The property table may specify properties to set on the instance, or include special keys for more advanced operations. ( className : string ) -> Component","title":"New function since v0.1"},{"location":"api-reference/instances/new/#parameters","text":"className - the instance class that should be created","title":"Parameters"},{"location":"api-reference/instances/new/#returns","text":"A component function. When called, it creates a new instance of the given class, populates it using the property table, and returns it.","title":"Returns"},{"location":"api-reference/instances/new/#example-usage","text":"local myButton : TextButton = New \"TextButton\" { Parent = Players . LocalPlayer . PlayerGui , Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Hello, world!\" , [ OnEvent \"Activated\" ] = function () print ( \"The button was clicked!\" ) end , [ OnChange \"Name\" ] = function ( newName ) print ( \"The button was renamed to:\" , newName ) end , [ Children ] = New \"UICorner\" { CornerRadius = UDim . new ( 0 , 8 ) } }","title":"Example Usage"},{"location":"api-reference/instances/new/#property-table-processing","text":"The props table uses a mix of string and special keys to specify attributes of the instance which should be set. String keys are treated as property declarations - values passed in will be set upon the instance: local example = New \"Part\" { -- sets the Position property Position = Vector3 . new ( 1 , 2 , 3 ) } Passing a state object to a string key will bind the property value; when the value of the object changes, the property will update to match on the next resumption step: local myName = State ( \"Bob\" ) local example = New \"Part\" { -- initially, the Name will be set to Bob Name = myName } -- change the state object to store \"John\" -- on the next resumption step, the part's Name will change to John myName : set ( \"John\" ) Special keys, such as Children or OnEvent , may also be used as keys in the property table. For more information about how special keys work, see the SpecialKey page.","title":"Property Table Processing"},{"location":"api-reference/instances/new/#default-properties","text":"The New function provides its own set of 'sensible default' property values for some class types, which will be used in place of Roblox defaults. This is done to opt out of some legacy features and unhelpful defaults. You can see the default properties Fusion uses here.","title":"Default Properties"},{"location":"api-reference/instances/onchange/","text":"Fusion Instances OnChange function since v0.1 \u00b6 Given a property name, returns a special key which connects to that property's change events. It should be used with a handler callback, which may accept the new value of the property. ( propertyName : string ) -> SpecialKey Parameters \u00b6 propertyName - The name of the property to listen for changes to. Returns \u00b6 A special key which runs at the observer stage. When applied to an instance, it connects to the property change signal on the instance for the given property. The handler is run with the property's value after every change. Example Usage \u00b6 New \"TextBox\" { [ OnChange \"Text\" ] = function ( newText ) print ( \"You typed:\" , newText ) end }","title":"OnChange"},{"location":"api-reference/instances/onchange/#onchange-function-since-v01","text":"Given a property name, returns a special key which connects to that property's change events. It should be used with a handler callback, which may accept the new value of the property. ( propertyName : string ) -> SpecialKey","title":"OnChange function since v0.1"},{"location":"api-reference/instances/onchange/#parameters","text":"propertyName - The name of the property to listen for changes to.","title":"Parameters"},{"location":"api-reference/instances/onchange/#returns","text":"A special key which runs at the observer stage. When applied to an instance, it connects to the property change signal on the instance for the given property. The handler is run with the property's value after every change.","title":"Returns"},{"location":"api-reference/instances/onchange/#example-usage","text":"New \"TextBox\" { [ OnChange \"Text\" ] = function ( newText ) print ( \"You typed:\" , newText ) end }","title":"Example Usage"},{"location":"api-reference/instances/onevent/","text":"Fusion Instances OnEvent function since v0.1 \u00b6 Given an event name, returns a special key which connects to events of that name. It should be used with a handler callback, which may accept arguments from the event. ( eventName : string ) -> SpecialKey Parameters \u00b6 eventName - the name of the event to connect to Returns \u00b6 A special key which runs at the observer stage. When applied to an instance, it connects to the event on the instance of the given name. The handler is run with the event's arguments after every firing. Example Usage \u00b6 New \"TextButton\" { [ OnEvent \"Activated\" ] = function (...) print ( \"The button was clicked! Arguments:\" , ...) end }","title":"OnEvent"},{"location":"api-reference/instances/onevent/#onevent-function-since-v01","text":"Given an event name, returns a special key which connects to events of that name. It should be used with a handler callback, which may accept arguments from the event. ( eventName : string ) -> SpecialKey","title":"OnEvent function since v0.1"},{"location":"api-reference/instances/onevent/#parameters","text":"eventName - the name of the event to connect to","title":"Parameters"},{"location":"api-reference/instances/onevent/#returns","text":"A special key which runs at the observer stage. When applied to an instance, it connects to the event on the instance of the given name. The handler is run with the event's arguments after every firing.","title":"Returns"},{"location":"api-reference/instances/onevent/#example-usage","text":"New \"TextButton\" { [ OnEvent \"Activated\" ] = function (...) print ( \"The button was clicked! Arguments:\" , ...) end }","title":"Example Usage"},{"location":"api-reference/instances/out/","text":"Fusion Instances Out function since v0.2 \u00b6 Given a property name, returns a special key which outputs the value of properties with that name. It should be used with a value . ( propertyName : string ) -> SpecialKey Parameters \u00b6 propertyName - The name of the property to output the value of. Returns \u00b6 A special key which runs at the observer stage. When applied to an instance, it sets the value object equal to the property with the given name. It then listens for further changes and updates the value object accordingly. Example Usage \u00b6 local userText = Value () New \"TextBox\" { [ Out \"Text\" ] = userText } Observer ( userText ): onChange ( function () print ( \"The user typed:\" , peek ( userText )) end )","title":"Out"},{"location":"api-reference/instances/out/#out-function-since-v02","text":"Given a property name, returns a special key which outputs the value of properties with that name. It should be used with a value . ( propertyName : string ) -> SpecialKey","title":"Out function since v0.2"},{"location":"api-reference/instances/out/#parameters","text":"propertyName - The name of the property to output the value of.","title":"Parameters"},{"location":"api-reference/instances/out/#returns","text":"A special key which runs at the observer stage. When applied to an instance, it sets the value object equal to the property with the given name. It then listens for further changes and updates the value object accordingly.","title":"Returns"},{"location":"api-reference/instances/out/#example-usage","text":"local userText = Value () New \"TextBox\" { [ Out \"Text\" ] = userText } Observer ( userText ): onChange ( function () print ( \"The user typed:\" , peek ( userText )) end )","title":"Example Usage"},{"location":"api-reference/instances/ref/","text":"Fusion Instances Ref special key since v0.2 \u00b6 When applied to an instance, outputs the instance to a state object. It should be used with a value . Example Usage \u00b6 local myRef = Value () New \"Part\" { [ Ref ] = myRef } print ( peek ( ref )) --> Part Technical Details \u00b6 This special key runs at the observer stage. On cleanup, the state object is reset to nil, in order to avoid potential memory leaks.","title":"Ref"},{"location":"api-reference/instances/ref/#ref-special-key-since-v02","text":"When applied to an instance, outputs the instance to a state object. It should be used with a value .","title":"Ref special key since v0.2"},{"location":"api-reference/instances/ref/#example-usage","text":"local myRef = Value () New \"Part\" { [ Ref ] = myRef } print ( peek ( ref )) --> Part","title":"Example Usage"},{"location":"api-reference/instances/ref/#technical-details","text":"This special key runs at the observer stage. On cleanup, the state object is reset to nil, in order to avoid potential memory leaks.","title":"Technical Details"},{"location":"api-reference/instances/specialkey/","text":"Fusion Instances SpecialKey type since v0.2 \u00b6 The standard interface for special keys that can be used in property tables for instance processing. Compatible with the New and Hydrate functions. { type : \"SpecialKey\" , kind : string , stage : \"self\" | \"descendants\" | \"ancestor\" | \"observer\" , apply : ( self : SpecialKey , value : any , applyTo : Instance , cleanupTasks : { Task } ) -> () } Fields \u00b6 type - identifies this table as a special key kind - gives a developer-friendly name to the object for debugging stage - determines when the special key should apply itself during the hydration process apply - the method that will be called to apply the special key to an instance Example Usage \u00b6 local Example = {} Example . type = \"SpecialKey\" Example . kind = \"Example\" Example . stage = \"observer\" function Example : apply ( value , applyTo , cleanupTasks ) local conn = applyTo : GetAttributeChangedSignal ( \"Foo\" ): Connect ( function () print ( \"My value is\" , value ) end ) table.insert ( cleanupTasks , conn ) end Stages \u00b6 When using New and Hydrate , properties are applied in the following order: String keys, except Parent Special keys with stage = \"self\" Special keys with stage = \"descendants\" Parent, if provided Special keys with stage = \"ancestor\" Special keys with stage = \"observer\" There are multiple motivations for splitting special keys into stages like these: Before we parent descendants to the instance, we want to initialise all of the instance's properties that don't depend on anything else Before we parent the instance to an ancestor, we want to parent and initialise all of the instance's descendants as fully as possible Before we attach handlers to anything, we want to parent to and initialise the instance's ancestor as fully as possible For these reasons, the roles of each stage are as follows: self \u00b6 The self stage is used for special keys that run before descendants are parented. This is typically used for special keys that operate on the instance itself in a vacuum. descendants \u00b6 The descendants stage is used for special keys that need to deal with descendants, but which don't need to know about the ancestry. This is important because parenting descendants after the instance is parented to an ancestor can be more expensive in terms of performance. ancestor \u00b6 The ancestor stage is used for special keys that deal with the ancestor of the instance. This is the last stage that should be used for initialising the instance, and occurs after the Parent has been set. observer \u00b6 The observer stage is used for special keys that watch the instance for changes or export references to the instance. This stage is where any event handlers should be connected, as initialisation should be done by this point.","title":"SpecialKey"},{"location":"api-reference/instances/specialkey/#specialkey-type-since-v02","text":"The standard interface for special keys that can be used in property tables for instance processing. Compatible with the New and Hydrate functions. { type : \"SpecialKey\" , kind : string , stage : \"self\" | \"descendants\" | \"ancestor\" | \"observer\" , apply : ( self : SpecialKey , value : any , applyTo : Instance , cleanupTasks : { Task } ) -> () }","title":"SpecialKey type since v0.2"},{"location":"api-reference/instances/specialkey/#fields","text":"type - identifies this table as a special key kind - gives a developer-friendly name to the object for debugging stage - determines when the special key should apply itself during the hydration process apply - the method that will be called to apply the special key to an instance","title":"Fields"},{"location":"api-reference/instances/specialkey/#example-usage","text":"local Example = {} Example . type = \"SpecialKey\" Example . kind = \"Example\" Example . stage = \"observer\" function Example : apply ( value , applyTo , cleanupTasks ) local conn = applyTo : GetAttributeChangedSignal ( \"Foo\" ): Connect ( function () print ( \"My value is\" , value ) end ) table.insert ( cleanupTasks , conn ) end","title":"Example Usage"},{"location":"api-reference/instances/specialkey/#stages","text":"When using New and Hydrate , properties are applied in the following order: String keys, except Parent Special keys with stage = \"self\" Special keys with stage = \"descendants\" Parent, if provided Special keys with stage = \"ancestor\" Special keys with stage = \"observer\" There are multiple motivations for splitting special keys into stages like these: Before we parent descendants to the instance, we want to initialise all of the instance's properties that don't depend on anything else Before we parent the instance to an ancestor, we want to parent and initialise all of the instance's descendants as fully as possible Before we attach handlers to anything, we want to parent to and initialise the instance's ancestor as fully as possible For these reasons, the roles of each stage are as follows:","title":"Stages"},{"location":"api-reference/instances/specialkey/#self","text":"The self stage is used for special keys that run before descendants are parented. This is typically used for special keys that operate on the instance itself in a vacuum.","title":"self"},{"location":"api-reference/instances/specialkey/#descendants","text":"The descendants stage is used for special keys that need to deal with descendants, but which don't need to know about the ancestry. This is important because parenting descendants after the instance is parented to an ancestor can be more expensive in terms of performance.","title":"descendants"},{"location":"api-reference/instances/specialkey/#ancestor","text":"The ancestor stage is used for special keys that deal with the ancestor of the instance. This is the last stage that should be used for initialising the instance, and occurs after the Parent has been set.","title":"ancestor"},{"location":"api-reference/instances/specialkey/#observer","text":"The observer stage is used for special keys that watch the instance for changes or export references to the instance. This stage is where any event handlers should be connected, as initialisation should be done by this point.","title":"observer"},{"location":"api-reference/state/","text":"Fusion State \u00b6 Fundamental state objects and utilities for working with reactive graphs. Types \u00b6 CanBeState Dependency Dependent StateObject Use Functions \u00b6 cleanup doNothing peek State Objects \u00b6 Computed ForKeys ForPairs ForValues Observer Value","title":"Index"},{"location":"api-reference/state/#state","text":"Fundamental state objects and utilities for working with reactive graphs.","title":"State"},{"location":"api-reference/state/#types","text":"CanBeState Dependency Dependent StateObject Use","title":"Types"},{"location":"api-reference/state/#functions","text":"cleanup doNothing peek","title":"Functions"},{"location":"api-reference/state/#state-objects","text":"Computed ForKeys ForPairs ForValues Observer Value","title":"State Objects"},{"location":"api-reference/state/canbestate/","text":"Fusion State CanBeState type since v0.2 \u00b6 A value which may either be a state object or a constant. Provided as a convenient shorthand for indicating that constant-ness is not important. StateObject < T > | T Example Usage \u00b6 local function printItem ( item : CanBeState < string > ) if typeof ( item ) == \"string\" then -- constant print ( \"Got constant: \" , item ) else -- state object print ( \"Got state object: \" , peek ( item )) end end local constant = \"Hello\" local state = Value ( \"World\" ) printItem ( constant ) --> Got constant: Hello printItem ( state ) --> Got state object: World","title":"CanBeState"},{"location":"api-reference/state/canbestate/#canbestate-type-since-v02","text":"A value which may either be a state object or a constant. Provided as a convenient shorthand for indicating that constant-ness is not important. StateObject < T > | T","title":"CanBeState type since v0.2"},{"location":"api-reference/state/canbestate/#example-usage","text":"local function printItem ( item : CanBeState < string > ) if typeof ( item ) == \"string\" then -- constant print ( \"Got constant: \" , item ) else -- state object print ( \"Got state object: \" , peek ( item )) end end local constant = \"Hello\" local state = Value ( \"World\" ) printItem ( constant ) --> Got constant: Hello printItem ( state ) --> Got state object: World","title":"Example Usage"},{"location":"api-reference/state/cleanup/","text":"Fusion State cleanup function since v0.2 \u00b6 Attempts to destroy all destructible objects passed to it. (... any ) -> () Parameters \u00b6 ... - Any objects that need to be destroyed. Example Usage \u00b6 Fusion . cleanup ( workspace . Part1 , RunService . RenderStepped : Connect ( print ), function () print ( \"I will be run!\" ) end ) Destruction Behaviour \u00b6 Destruction behaviour varies by type: if Instance , :Destroy() is called ...else if RBXScriptConnection , :Disconnect() is called ...else if function , it is called ...else if {destroy: (self) -> ()} , :destroy() is called ...else if {Destroy: (self) -> ()} , :Destroy() is called ...else if {any} , Fusion.cleanup is called on all members ...else nothing occurs.","title":"cleanup"},{"location":"api-reference/state/cleanup/#cleanup-function-since-v02","text":"Attempts to destroy all destructible objects passed to it. (... any ) -> ()","title":"cleanup function since v0.2"},{"location":"api-reference/state/cleanup/#parameters","text":"... - Any objects that need to be destroyed.","title":"Parameters"},{"location":"api-reference/state/cleanup/#example-usage","text":"Fusion . cleanup ( workspace . Part1 , RunService . RenderStepped : Connect ( print ), function () print ( \"I will be run!\" ) end )","title":"Example Usage"},{"location":"api-reference/state/cleanup/#destruction-behaviour","text":"Destruction behaviour varies by type: if Instance , :Destroy() is called ...else if RBXScriptConnection , :Disconnect() is called ...else if function , it is called ...else if {destroy: (self) -> ()} , :destroy() is called ...else if {Destroy: (self) -> ()} , :Destroy() is called ...else if {any} , Fusion.cleanup is called on all members ...else nothing occurs.","title":"Destruction Behaviour"},{"location":"api-reference/state/computed/","text":"Fusion State Computed state object since v0.1 \u00b6 Calculates a single value based on the returned values from other state objects. ( processor : ( Use ) -> ( T , M ), destructor : (( T , M ) -> ()) ? ) -> Computed < T , M > Parameters \u00b6 processor: (Use) -> (T, M) - computes and returns values to be returned from the computed object, optionally returning extra values for the destructor alone destructor: ((T, M) -> ())? - disposes of values generated by processor when they are no longer in use Example Usage \u00b6 local numCoins = Value ( 50 ) local doubleCoins = Computed ( function ( use ) return use ( numCoins ) * 2 end ) print ( peek ( doubleCoins )) --> 100 numCoins : set ( 2 ) print ( peek ( doubleCoins )) --> 4 Dependency Management \u00b6 By default, computed objects run their processor function once during construction, then cache the result indefinitely. To specify the calculation should re-run when a state object changes value, the objects can be passed to the use callback passed to the processor function. The use callback will unwrap the value as normal, but any state objects will become dependencies of the computed object. Destructors \u00b6 The destructor callback, if provided, is called when the computed object swaps out an old value for a newly-generated one. It is called with the old value as the first parameter, and - if provided - an extra value returned from processor as a customisable second parameter. Destructors are required when working with data types that require destruction, such as instances. Otherwise, they are optional, so not all calculations have to specify destruction behaviour. Fusion guarantees that values passed to destructors by default will never be used again by the library, so it is safe to finalise them. This does not apply to the customisable second parameter, which the user is responsible for handling properly.","title":"Computed"},{"location":"api-reference/state/computed/#computed-state-object-since-v01","text":"Calculates a single value based on the returned values from other state objects. ( processor : ( Use ) -> ( T , M ), destructor : (( T , M ) -> ()) ? ) -> Computed < T , M >","title":"Computed state object since v0.1"},{"location":"api-reference/state/computed/#parameters","text":"processor: (Use) -> (T, M) - computes and returns values to be returned from the computed object, optionally returning extra values for the destructor alone destructor: ((T, M) -> ())? - disposes of values generated by processor when they are no longer in use","title":"Parameters"},{"location":"api-reference/state/computed/#example-usage","text":"local numCoins = Value ( 50 ) local doubleCoins = Computed ( function ( use ) return use ( numCoins ) * 2 end ) print ( peek ( doubleCoins )) --> 100 numCoins : set ( 2 ) print ( peek ( doubleCoins )) --> 4","title":"Example Usage"},{"location":"api-reference/state/computed/#dependency-management","text":"By default, computed objects run their processor function once during construction, then cache the result indefinitely. To specify the calculation should re-run when a state object changes value, the objects can be passed to the use callback passed to the processor function. The use callback will unwrap the value as normal, but any state objects will become dependencies of the computed object.","title":"Dependency Management"},{"location":"api-reference/state/computed/#destructors","text":"The destructor callback, if provided, is called when the computed object swaps out an old value for a newly-generated one. It is called with the old value as the first parameter, and - if provided - an extra value returned from processor as a customisable second parameter. Destructors are required when working with data types that require destruction, such as instances. Otherwise, they are optional, so not all calculations have to specify destruction behaviour. Fusion guarantees that values passed to destructors by default will never be used again by the library, so it is safe to finalise them. This does not apply to the customisable second parameter, which the user is responsible for handling properly.","title":"Destructors"},{"location":"api-reference/state/dependency/","text":"Fusion State Dependency type since v0.2 \u00b6 A graph object which can send updates to dependents on the reactive graph. Most often used with state objects , though the reactive graph does not require objects to store state. { dependentSet : Set < Dependent > } Example Usage \u00b6 -- these are examples of objects which are dependencies local value : Dependency = Value ( 2 ) local computed : Dependency = Computed ( function ( use ) return use ( value ) * 2 end ) -- dependencies can be used with some internal functions such as updateAll() updateAll ( value )","title":"Dependency"},{"location":"api-reference/state/dependency/#dependency-type-since-v02","text":"A graph object which can send updates to dependents on the reactive graph. Most often used with state objects , though the reactive graph does not require objects to store state. { dependentSet : Set < Dependent > }","title":"Dependency type since v0.2"},{"location":"api-reference/state/dependency/#example-usage","text":"-- these are examples of objects which are dependencies local value : Dependency = Value ( 2 ) local computed : Dependency = Computed ( function ( use ) return use ( value ) * 2 end ) -- dependencies can be used with some internal functions such as updateAll() updateAll ( value )","title":"Example Usage"},{"location":"api-reference/state/dependent/","text":"Fusion State Dependent type since v0.2 \u00b6 A graph object which can receive updates from dependecies on the reactive graph. Most often used with state objects , though the reactive graph does not require objects to store state. { dependencySet : Set < Dependency > , update : ( self ) -> boolean } Fields \u00b6 dependencySet - stores the graph objects which this object can receive updates from Methods \u00b6 since v0.2 Dependent:update() \u00b6 Called when this object receives an update from one or more dependencies. If this object is a dependency, and updates should be propagated to further dependencies, this method should return true. Otherwise, to block further updates from occuring (for example, because this object did not change value), this method should return false. () -> boolean Example Usage \u00b6 -- these are examples of objects which are dependents local computed : Dependent = Computed ( function ( use ) return \"foo\" end ) local observer : Dependent = Observer ( computed )","title":"Dependent"},{"location":"api-reference/state/dependent/#dependent-type-since-v02","text":"A graph object which can receive updates from dependecies on the reactive graph. Most often used with state objects , though the reactive graph does not require objects to store state. { dependencySet : Set < Dependency > , update : ( self ) -> boolean }","title":"Dependent type since v0.2"},{"location":"api-reference/state/dependent/#fields","text":"dependencySet - stores the graph objects which this object can receive updates from","title":"Fields"},{"location":"api-reference/state/dependent/#methods","text":"since v0.2","title":"Methods"},{"location":"api-reference/state/dependent/#dependentupdate","text":"Called when this object receives an update from one or more dependencies. If this object is a dependency, and updates should be propagated to further dependencies, this method should return true. Otherwise, to block further updates from occuring (for example, because this object did not change value), this method should return false. () -> boolean","title":"Dependent:update()"},{"location":"api-reference/state/dependent/#example-usage","text":"-- these are examples of objects which are dependents local computed : Dependent = Computed ( function ( use ) return \"foo\" end ) local observer : Dependent = Observer ( computed )","title":"Example Usage"},{"location":"api-reference/state/donothing/","text":"Fusion State doNothing function since v0.2 \u00b6 No-op function - does nothing at all, and returns nothing at all. Intended for use as a destructor when no destruction is needed. (... any ) -> () Parameters \u00b6 ... - Any objects. Example Usage \u00b6 local foo = Computed ( function ( use ) return workspace . Part end , Fusion . doNothing )","title":"doNothing"},{"location":"api-reference/state/donothing/#donothing-function-since-v02","text":"No-op function - does nothing at all, and returns nothing at all. Intended for use as a destructor when no destruction is needed. (... any ) -> ()","title":"doNothing function since v0.2"},{"location":"api-reference/state/donothing/#parameters","text":"... - Any objects.","title":"Parameters"},{"location":"api-reference/state/donothing/#example-usage","text":"local foo = Computed ( function ( use ) return workspace . Part end , Fusion . doNothing )","title":"Example Usage"},{"location":"api-reference/state/forkeys/","text":"Fusion State ForKeys state object since v0.2 \u00b6 Processes a table from another state object by transforming its keys only. ( input : CanBeState < {[ KI ]: V } > , keyProcessor : ( Use , KI ) -> ( KO , M ), keyDestructor : (( KO , M ) -> ()) ? ) -> ForKeys < KI , KO , V , M > Parameters \u00b6 input: CanBeState<{[KI]: V}> - the table to be processed, either as a state object or a constant value keyProcessor: (Use, KI) -> (KO, M) - transforms input keys into new keys, optionally providing metadata for the destructor alone keyDestructor: ((KO, M) -> ())? - disposes of values generated by keyProcessor when they are no longer in use Example Usage \u00b6 local data = Value ({ one = 1 , two = 2 , three = 3 , four = 4 }) local transformed = ForKeys ( data , function ( use , key ) local newKey = string.upper ( key ) return newKey end ) print ( peek ( transformed )) --> {ONE = 1, TWO = 2 ... } Dependency Management \u00b6 By default, ForKeys runs the processor function once per key in the input, then caches the result indefinitely. To specify the calculation should re-run for the key when a state object changes value, the objects can be passed to the use callback passed to the processor function for that key. The use callback will unwrap the value as normal, but any state objects will become dependencies of that key. Destructors \u00b6 The keyDestructor callback, if provided, is called when this object swaps out an old key for a newly-generated one. It is called with the old key as the first parameter, and - if provided - an extra value returned from keyProcessor as a customisable second parameter. Destructors are required when working with data types that require destruction, such as instances. Otherwise, they are optional, so not all calculations have to specify destruction behaviour. Fusion guarantees that values passed to destructors by default will never be used again by the library, so it is safe to finalise them. This does not apply to the customisable second parameter, which the user is responsible for handling properly. Optimisations \u00b6 ForKeys does not allow access to the values of the input table. This guarantees that all generated keys are completely independent of any values. This means keys only need to be calculated when they're added to the input table - all other changes are simply forwarded to the output table. Since keys are also unique, all calculations are unique, so caching and reuse are not required.","title":"ForKeys"},{"location":"api-reference/state/forkeys/#forkeys-state-object-since-v02","text":"Processes a table from another state object by transforming its keys only. ( input : CanBeState < {[ KI ]: V } > , keyProcessor : ( Use , KI ) -> ( KO , M ), keyDestructor : (( KO , M ) -> ()) ? ) -> ForKeys < KI , KO , V , M >","title":"ForKeys state object since v0.2"},{"location":"api-reference/state/forkeys/#parameters","text":"input: CanBeState<{[KI]: V}> - the table to be processed, either as a state object or a constant value keyProcessor: (Use, KI) -> (KO, M) - transforms input keys into new keys, optionally providing metadata for the destructor alone keyDestructor: ((KO, M) -> ())? - disposes of values generated by keyProcessor when they are no longer in use","title":"Parameters"},{"location":"api-reference/state/forkeys/#example-usage","text":"local data = Value ({ one = 1 , two = 2 , three = 3 , four = 4 }) local transformed = ForKeys ( data , function ( use , key ) local newKey = string.upper ( key ) return newKey end ) print ( peek ( transformed )) --> {ONE = 1, TWO = 2 ... }","title":"Example Usage"},{"location":"api-reference/state/forkeys/#dependency-management","text":"By default, ForKeys runs the processor function once per key in the input, then caches the result indefinitely. To specify the calculation should re-run for the key when a state object changes value, the objects can be passed to the use callback passed to the processor function for that key. The use callback will unwrap the value as normal, but any state objects will become dependencies of that key.","title":"Dependency Management"},{"location":"api-reference/state/forkeys/#destructors","text":"The keyDestructor callback, if provided, is called when this object swaps out an old key for a newly-generated one. It is called with the old key as the first parameter, and - if provided - an extra value returned from keyProcessor as a customisable second parameter. Destructors are required when working with data types that require destruction, such as instances. Otherwise, they are optional, so not all calculations have to specify destruction behaviour. Fusion guarantees that values passed to destructors by default will never be used again by the library, so it is safe to finalise them. This does not apply to the customisable second parameter, which the user is responsible for handling properly.","title":"Destructors"},{"location":"api-reference/state/forkeys/#optimisations","text":"ForKeys does not allow access to the values of the input table. This guarantees that all generated keys are completely independent of any values. This means keys only need to be calculated when they're added to the input table - all other changes are simply forwarded to the output table. Since keys are also unique, all calculations are unique, so caching and reuse are not required.","title":"Optimisations"},{"location":"api-reference/state/forpairs/","text":"Fusion State ForPairs state object since v0.2 \u00b6 Processes a table from another state object by transforming its keys and values. ( input : CanBeState < {[ KI ]: VI } > , pairProcessor : ( Use , KI , VI ) -> ( KO , VO , M ), pairDestructor : (( KO , VO , M ) -> ()) ? ) -> ForPairs < KI , VI , KO , VO , M > Parameters \u00b6 input: CanBeState<{[KI]: VI}> - the table to be processed, either as a state object or a constant value pairProcessor: (Use, KI, VI) -> (KO, VO, M) - transforms input key-value pairs into new key-value pairs, optionally providing metadata for the destructor alone pairDestructor: ((KO, VO, M) -> ())? - disposes of values generated by pairProcessor when they are no longer in use Example Usage \u00b6 local data = Value ({ one = 1 , two = 2 , three = 3 , four = 4 }) local transformed = ForPairs ( data , function ( use , key , value ) local newKey = value local newValue = string.upper ( key ) return newKey , newValue end ) print ( peek ( transformed )) --> {[1] = \"ONE\", [2] = \"TWO\" ... } Dependency Management \u00b6 By default, ForPairs runs the processor function once per key/value pair in the input, then caches the result indefinitely. To specify the calculation should re-run for the key/value pair when a state object changes value, the objects can be passed to the use callback passed to the processor function for that key/value pair. The use callback will unwrap the value as normal, but any state objects will become dependencies of that key/value pair. Destructors \u00b6 The pairDestructor callback, if provided, is called when this object swaps out an old key-value pair for a newly-generated one. It is called with the old pair as the first and second parameters, and - if provided - an extra value returned from pairProcessor as a customisable third parameter. Destructors are required when working with data types that require destruction, such as instances. Otherwise, they are optional, so not all calculations have to specify destruction behaviour. Fusion guarantees that values passed to destructors by default will never be used again by the library, so it is safe to finalise them. This does not apply to the customisable third parameter, which the user is responsible for handling properly. Optimisations \u00b6 ForPairs is the least restrictive of the For objects, allowing full access to the key-value pairs being processed. This means that very little optimisation is applied - values are always locked to the specific key they were generated for, and any change in the input's key or value will prompt a recalculation. For other optimisations, consider using ForValues or ForKeys , which impose stricter restrictions to allow for less frequent updates and greater reuse.","title":"ForPairs"},{"location":"api-reference/state/forpairs/#forpairs-state-object-since-v02","text":"Processes a table from another state object by transforming its keys and values. ( input : CanBeState < {[ KI ]: VI } > , pairProcessor : ( Use , KI , VI ) -> ( KO , VO , M ), pairDestructor : (( KO , VO , M ) -> ()) ? ) -> ForPairs < KI , VI , KO , VO , M >","title":"ForPairs state object since v0.2"},{"location":"api-reference/state/forpairs/#parameters","text":"input: CanBeState<{[KI]: VI}> - the table to be processed, either as a state object or a constant value pairProcessor: (Use, KI, VI) -> (KO, VO, M) - transforms input key-value pairs into new key-value pairs, optionally providing metadata for the destructor alone pairDestructor: ((KO, VO, M) -> ())? - disposes of values generated by pairProcessor when they are no longer in use","title":"Parameters"},{"location":"api-reference/state/forpairs/#example-usage","text":"local data = Value ({ one = 1 , two = 2 , three = 3 , four = 4 }) local transformed = ForPairs ( data , function ( use , key , value ) local newKey = value local newValue = string.upper ( key ) return newKey , newValue end ) print ( peek ( transformed )) --> {[1] = \"ONE\", [2] = \"TWO\" ... }","title":"Example Usage"},{"location":"api-reference/state/forpairs/#dependency-management","text":"By default, ForPairs runs the processor function once per key/value pair in the input, then caches the result indefinitely. To specify the calculation should re-run for the key/value pair when a state object changes value, the objects can be passed to the use callback passed to the processor function for that key/value pair. The use callback will unwrap the value as normal, but any state objects will become dependencies of that key/value pair.","title":"Dependency Management"},{"location":"api-reference/state/forpairs/#destructors","text":"The pairDestructor callback, if provided, is called when this object swaps out an old key-value pair for a newly-generated one. It is called with the old pair as the first and second parameters, and - if provided - an extra value returned from pairProcessor as a customisable third parameter. Destructors are required when working with data types that require destruction, such as instances. Otherwise, they are optional, so not all calculations have to specify destruction behaviour. Fusion guarantees that values passed to destructors by default will never be used again by the library, so it is safe to finalise them. This does not apply to the customisable third parameter, which the user is responsible for handling properly.","title":"Destructors"},{"location":"api-reference/state/forpairs/#optimisations","text":"ForPairs is the least restrictive of the For objects, allowing full access to the key-value pairs being processed. This means that very little optimisation is applied - values are always locked to the specific key they were generated for, and any change in the input's key or value will prompt a recalculation. For other optimisations, consider using ForValues or ForKeys , which impose stricter restrictions to allow for less frequent updates and greater reuse.","title":"Optimisations"},{"location":"api-reference/state/forvalues/","text":"Fusion State ForValues state object since v0.2 \u00b6 Processes a table from another state object by transforming its values only. ( input : CanBeState < {[ K ]: VI } > , valueProcessor : ( Use , VI ) -> ( VO , M ), valueDestructor : (( VO , M ) -> ()) ? ) -> ForValues < K , VI , VO , M > Parameters \u00b6 input: CanBeState<{[K]: VI}> - the table to be processed, either as a state object or a constant value valueProcessor: (Use, VI) -> (VO, M) - transforms input values into new values, optionally providing metadata for the destructor alone valueDestructor: ((VO, M) -> ())? - disposes of values generated by valueProcessor when they are no longer in use Example Usage \u00b6 local data = Value ({ one = 1 , two = 2 , three = 3 , four = 4 }) local transformed = ForValues ( data , function ( use , value ) local newValue = value * 2 return newValue end ) print ( peek ( transformed )) --> {ONE = 2, TWO = 4 ... } Dependency Management \u00b6 By default, ForValues runs the processor function once per value in the input, then caches the result indefinitely. To specify the calculation should re-run for the value when a state object changes value, the objects can be passed to the use callback passed to the processor function for that value. The use callback will unwrap the value as normal, but any state objects will become dependencies of that value. Destructors \u00b6 The valueDestructor callback, if provided, is called when this object swaps out an old value for a newly-generated one. It is called with the old value as the first parameter, and - if provided - an extra value returned from valueProcessor as a customisable second parameter. Destructors are required when working with data types that require destruction, such as instances. Otherwise, they are optional, so not all calculations have to specify destruction behaviour. Fusion guarantees that values passed to destructors by default will never be used again by the library, so it is safe to finalise them. This does not apply to the customisable second parameter, which the user is responsible for handling properly. Optimisations \u00b6 ForValues does not allow access to the keys of the input table. This guarantees that all generated values are completely independent of the key they were generated for. This means that values may be moved between keys instead of being destroyed when their original key changes value. Values are only reused once - values aren't copied when there are multiple occurences of the same input.","title":"ForValues"},{"location":"api-reference/state/forvalues/#forvalues-state-object-since-v02","text":"Processes a table from another state object by transforming its values only. ( input : CanBeState < {[ K ]: VI } > , valueProcessor : ( Use , VI ) -> ( VO , M ), valueDestructor : (( VO , M ) -> ()) ? ) -> ForValues < K , VI , VO , M >","title":"ForValues state object since v0.2"},{"location":"api-reference/state/forvalues/#parameters","text":"input: CanBeState<{[K]: VI}> - the table to be processed, either as a state object or a constant value valueProcessor: (Use, VI) -> (VO, M) - transforms input values into new values, optionally providing metadata for the destructor alone valueDestructor: ((VO, M) -> ())? - disposes of values generated by valueProcessor when they are no longer in use","title":"Parameters"},{"location":"api-reference/state/forvalues/#example-usage","text":"local data = Value ({ one = 1 , two = 2 , three = 3 , four = 4 }) local transformed = ForValues ( data , function ( use , value ) local newValue = value * 2 return newValue end ) print ( peek ( transformed )) --> {ONE = 2, TWO = 4 ... }","title":"Example Usage"},{"location":"api-reference/state/forvalues/#dependency-management","text":"By default, ForValues runs the processor function once per value in the input, then caches the result indefinitely. To specify the calculation should re-run for the value when a state object changes value, the objects can be passed to the use callback passed to the processor function for that value. The use callback will unwrap the value as normal, but any state objects will become dependencies of that value.","title":"Dependency Management"},{"location":"api-reference/state/forvalues/#destructors","text":"The valueDestructor callback, if provided, is called when this object swaps out an old value for a newly-generated one. It is called with the old value as the first parameter, and - if provided - an extra value returned from valueProcessor as a customisable second parameter. Destructors are required when working with data types that require destruction, such as instances. Otherwise, they are optional, so not all calculations have to specify destruction behaviour. Fusion guarantees that values passed to destructors by default will never be used again by the library, so it is safe to finalise them. This does not apply to the customisable second parameter, which the user is responsible for handling properly.","title":"Destructors"},{"location":"api-reference/state/forvalues/#optimisations","text":"ForValues does not allow access to the keys of the input table. This guarantees that all generated values are completely independent of the key they were generated for. This means that values may be moved between keys instead of being destroyed when their original key changes value. Values are only reused once - values aren't copied when there are multiple occurences of the same input.","title":"Optimisations"},{"location":"api-reference/state/observer/","text":"Fusion State Observer graph object since v0.2 \u00b6 Observes various updates and events on a given dependency. ( observe : Dependency ) -> Observer Parameters \u00b6 observe: Dependency - the dependency this observer should respond to Object Methods \u00b6 since v0.2 Observer:onChange() \u00b6 Connects the given callback as a change handler, and returns a function which will disconnect the callback. The callback will run whenever the observed dependency is updated. ( callback : () -> ()) -> (() -> ()) Parameters \u00b6 callback - The function to call when a change is observed Connection memory leaks Make sure to disconnect any change handlers made using this function once you're done using them. As long as a change handler is connected, this observer and the dependency it observes will be held in memory in case further changes occur. This means, if you don't call the disconnect function, you may end up accidentally holding your state objects in memory forever after you're done using them. since v0.3 Observer:onBind() \u00b6 Connects the given callback as a change handler, and returns a function which will disconnect the callback. The callback is run immediately, and re-run whenever the observed dependency is updated. ( callback : () -> ()) -> (() -> ()) Parameters \u00b6 callback - The function to call when a change is observed and when the observer is created Connection memory leaks Make sure to disconnect any change handlers made using this function once you're done using them. As long as a change handler is connected, this observer and the dependency it observes will be held in memory in case further changes occur. This means, if you don't call the disconnect function, you may end up accidentally holding your state objects in memory forever after you're done using them. Example Usage \u00b6 local numCoins = Value ( 50 ) local coinObserver = Observer ( numCoins ) local disconnect = coinObserver : onChange ( function () print ( \"coins is now:\" , peek ( numCoins )) end ) numCoins : set ( 25 ) -- prints 'coins is now: 25' -- always clean up your connections! disconnect () local someValue = Value ( \"\" ) function update () someObject . Text = peek ( someValue ) end local disconnect = Observer ( someValue ): onBind ( update ) -- always clean up your connections! disconnect ()","title":"Observer"},{"location":"api-reference/state/observer/#observer-graph-object-since-v02","text":"Observes various updates and events on a given dependency. ( observe : Dependency ) -> Observer","title":"Observer graph object since v0.2"},{"location":"api-reference/state/observer/#parameters","text":"observe: Dependency - the dependency this observer should respond to","title":"Parameters"},{"location":"api-reference/state/observer/#object-methods","text":"since v0.2","title":"Object Methods"},{"location":"api-reference/state/observer/#observeronchange","text":"Connects the given callback as a change handler, and returns a function which will disconnect the callback. The callback will run whenever the observed dependency is updated. ( callback : () -> ()) -> (() -> ())","title":"Observer:onChange()"},{"location":"api-reference/state/observer/#parameters_1","text":"callback - The function to call when a change is observed Connection memory leaks Make sure to disconnect any change handlers made using this function once you're done using them. As long as a change handler is connected, this observer and the dependency it observes will be held in memory in case further changes occur. This means, if you don't call the disconnect function, you may end up accidentally holding your state objects in memory forever after you're done using them. since v0.3","title":"Parameters"},{"location":"api-reference/state/observer/#observeronbind","text":"Connects the given callback as a change handler, and returns a function which will disconnect the callback. The callback is run immediately, and re-run whenever the observed dependency is updated. ( callback : () -> ()) -> (() -> ())","title":"Observer:onBind()"},{"location":"api-reference/state/observer/#parameters_2","text":"callback - The function to call when a change is observed and when the observer is created Connection memory leaks Make sure to disconnect any change handlers made using this function once you're done using them. As long as a change handler is connected, this observer and the dependency it observes will be held in memory in case further changes occur. This means, if you don't call the disconnect function, you may end up accidentally holding your state objects in memory forever after you're done using them.","title":"Parameters"},{"location":"api-reference/state/observer/#example-usage","text":"local numCoins = Value ( 50 ) local coinObserver = Observer ( numCoins ) local disconnect = coinObserver : onChange ( function () print ( \"coins is now:\" , peek ( numCoins )) end ) numCoins : set ( 25 ) -- prints 'coins is now: 25' -- always clean up your connections! disconnect () local someValue = Value ( \"\" ) function update () someObject . Text = peek ( someValue ) end local disconnect = Observer ( someValue ): onBind ( update ) -- always clean up your connections! disconnect ()","title":"Example Usage"},{"location":"api-reference/state/peek/","text":"Fusion State peek function since v0.3 \u00b6 The most basic use callback , which returns the interior value of state objects without adding any dependencies. < T > ( target : CanBeState < T > ) -> T Parameters \u00b6 target: CanBeState<T> - The argument to attempt to unwrap. Returns \u00b6 If the argument is a state object, returns the interior value of the state object. Otherwise, returns the argument itself. Example Usage \u00b6 local thing = Value ( 5 ) print ( peek ( thing )) --> 5","title":"peek"},{"location":"api-reference/state/peek/#peek-function-since-v03","text":"The most basic use callback , which returns the interior value of state objects without adding any dependencies. < T > ( target : CanBeState < T > ) -> T","title":"peek function since v0.3"},{"location":"api-reference/state/peek/#parameters","text":"target: CanBeState<T> - The argument to attempt to unwrap.","title":"Parameters"},{"location":"api-reference/state/peek/#returns","text":"If the argument is a state object, returns the interior value of the state object. Otherwise, returns the argument itself.","title":"Returns"},{"location":"api-reference/state/peek/#example-usage","text":"local thing = Value ( 5 ) print ( peek ( thing )) --> 5","title":"Example Usage"},{"location":"api-reference/state/stateobject/","text":"Fusion State StateObject type since v0.2 \u00b6 A dependency that provides a single stateful value; the dependency updates when the value changes state. Note that state objects do not expose a public interface for accessing their interior value - the standard way of doing this is by using a use callback such as the peek function . Dependency & { type : \"State\" , kind : string } Fields \u00b6 type - uniquely identifies state objects for runtime type checks kind - holds a more specific type name for different kinds of state object Example Usage \u00b6 -- these are examples of objects which are state objects local value : StateObject = Value ( 5 ) local computed : StateObject = Computed ( function ( use ) return \"foo\" end )","title":"StateObject"},{"location":"api-reference/state/stateobject/#stateobject-type-since-v02","text":"A dependency that provides a single stateful value; the dependency updates when the value changes state. Note that state objects do not expose a public interface for accessing their interior value - the standard way of doing this is by using a use callback such as the peek function . Dependency & { type : \"State\" , kind : string }","title":"StateObject type since v0.2"},{"location":"api-reference/state/stateobject/#fields","text":"type - uniquely identifies state objects for runtime type checks kind - holds a more specific type name for different kinds of state object","title":"Fields"},{"location":"api-reference/state/stateobject/#example-usage","text":"-- these are examples of objects which are state objects local value : StateObject = Value ( 5 ) local computed : StateObject = Computed ( function ( use ) return \"foo\" end )","title":"Example Usage"},{"location":"api-reference/state/use/","text":"Fusion State Use type since v0.3 \u00b6 The general function signature for unwrapping state objects while transparently passing through other (constant) values. Functions of this shape are often referred to as 'use callbacks', and are often provided by dependency capturers such as computeds for the purposes of tracking used state objects in a processor function. < T > ( target : CanBeState < T > ) -> T Example Usage \u00b6 local foo : Value < number > = Value ( 2 ) local doubleFoo = Computed ( function ( use : Fusion . Use ) return use ( foo ) * 2 end )","title":"Use"},{"location":"api-reference/state/use/#use-type-since-v03","text":"The general function signature for unwrapping state objects while transparently passing through other (constant) values. Functions of this shape are often referred to as 'use callbacks', and are often provided by dependency capturers such as computeds for the purposes of tracking used state objects in a processor function. < T > ( target : CanBeState < T > ) -> T","title":"Use type since v0.3"},{"location":"api-reference/state/use/#example-usage","text":"local foo : Value < number > = Value ( 2 ) local doubleFoo = Computed ( function ( use : Fusion . Use ) return use ( foo ) * 2 end )","title":"Example Usage"},{"location":"api-reference/state/value/","text":"Fusion State Value state object since v0.2 \u00b6 Stores a single value which can be updated at any time. ( initialValue : T ) -> Value < T > Parameters \u00b6 initialValue - The value that should be initially stored after construction. Methods \u00b6 since v0.2 Value:set() \u00b6 Replaces the currently stored value, updating any other state objects that depend on this value object. The value is stored directly, and no cloning or alteration is done. If the new value is the same as the old value, other state objects won't be updated. ( newValue : T ) -> () Parameters \u00b6 newValue - The new value to be stored. Table sameness Updates are always sent out when setting a table value, because it's much more difficult to evaluate if two tables are the same. Therefore, this method is conservative and labels all tables as different, even compared to themselves. Legacy parameter: force Originally, a second force parameter was available in Fusion 0.1 so that updates could forcibly be sent out, even when the new value was the same as the old value. This is because Fusion 0.1 used equality to evaluate sameness for all data types, including tables. This was problematic as many users attempted to get the table value, modify it, and :set() it back into the object, which would not cause an update as the table reference did not change. Fusion 0.2 uses a different sameness definition for tables to alleviate this problem. As such, there is no longer a good reason to use this parameter, and so it is not currently recommended for use. For backwards compatibility, it will remain for the time being, but do not depend on it for new work. Example Usage \u00b6 local numCoins = Value ( 50 ) -- start off with 50 coins print ( peek ( numCoins )) --> 50 numCoins : set ( 10 ) print ( peek ( numCoins )) --> 10","title":"Value"},{"location":"api-reference/state/value/#value-state-object-since-v02","text":"Stores a single value which can be updated at any time. ( initialValue : T ) -> Value < T >","title":"Value state object since v0.2"},{"location":"api-reference/state/value/#parameters","text":"initialValue - The value that should be initially stored after construction.","title":"Parameters"},{"location":"api-reference/state/value/#methods","text":"since v0.2","title":"Methods"},{"location":"api-reference/state/value/#valueset","text":"Replaces the currently stored value, updating any other state objects that depend on this value object. The value is stored directly, and no cloning or alteration is done. If the new value is the same as the old value, other state objects won't be updated. ( newValue : T ) -> ()","title":"Value:set()"},{"location":"api-reference/state/value/#parameters_1","text":"newValue - The new value to be stored. Table sameness Updates are always sent out when setting a table value, because it's much more difficult to evaluate if two tables are the same. Therefore, this method is conservative and labels all tables as different, even compared to themselves. Legacy parameter: force Originally, a second force parameter was available in Fusion 0.1 so that updates could forcibly be sent out, even when the new value was the same as the old value. This is because Fusion 0.1 used equality to evaluate sameness for all data types, including tables. This was problematic as many users attempted to get the table value, modify it, and :set() it back into the object, which would not cause an update as the table reference did not change. Fusion 0.2 uses a different sameness definition for tables to alleviate this problem. As such, there is no longer a good reason to use this parameter, and so it is not currently recommended for use. For backwards compatibility, it will remain for the time being, but do not depend on it for new work.","title":"Parameters"},{"location":"api-reference/state/value/#example-usage","text":"local numCoins = Value ( 50 ) -- start off with 50 coins print ( peek ( numCoins )) --> 50 numCoins : set ( 10 ) print ( peek ( numCoins )) --> 10","title":"Example Usage"},{"location":"examples/","text":"Examples \u00b6 Welcome to the Examples section! Here, you can find various open-source examples and projects, so you can see how Fusion works in a real setting. The Cookbook \u00b6 Oftentimes, you might be stuck on a small problem. You want to create something specific, but don't know how to do it with Fusion's tools. The cookbook can help with that! It's a collection of snippets which show you how to do various small tasks with Fusion, like processing arrays, applying animations and responding to different events. Visit the cookbook to see what's available. Open-Source Projects \u00b6 Fusion Wordle \u00b6 See how Fusion can be used to build a mobile-first UI-centric game, with server validation, spring animations and sounds. Play and edit the game on Roblox. Fusion Obby \u00b6 See how Fusion can be used to build a minimal interface for an obby, with an animated checkpoint counter and simulated confetti. Play and edit the game on Roblox.","title":"Home"},{"location":"examples/#examples","text":"Welcome to the Examples section! Here, you can find various open-source examples and projects, so you can see how Fusion works in a real setting.","title":"Examples"},{"location":"examples/#the-cookbook","text":"Oftentimes, you might be stuck on a small problem. You want to create something specific, but don't know how to do it with Fusion's tools. The cookbook can help with that! It's a collection of snippets which show you how to do various small tasks with Fusion, like processing arrays, applying animations and responding to different events. Visit the cookbook to see what's available.","title":"The Cookbook"},{"location":"examples/#open-source-projects","text":"","title":"Open-Source Projects"},{"location":"examples/#fusion-wordle","text":"See how Fusion can be used to build a mobile-first UI-centric game, with server validation, spring animations and sounds. Play and edit the game on Roblox.","title":"Fusion Wordle"},{"location":"examples/#fusion-obby","text":"See how Fusion can be used to build a minimal interface for an obby, with an animated checkpoint counter and simulated confetti. Play and edit the game on Roblox.","title":"Fusion Obby"},{"location":"examples/cookbook/","text":"Cookbook \u00b6 Oftentimes, you might be stuck on a small problem. You want to create something specific, but don't know how to do it with Fusion's tools. The cookbook can help with that! It's a collection of snippets which show you how to do various small tasks with Fusion, like processing arrays, applying animations and responding to different events. Navigation \u00b6 Using the sidebar to the left, you can browse all of the cookbook examples by name.","title":"Cookbook"},{"location":"examples/cookbook/#cookbook","text":"Oftentimes, you might be stuck on a small problem. You want to create something specific, but don't know how to do it with Fusion's tools. The cookbook can help with that! It's a collection of snippets which show you how to do various small tasks with Fusion, like processing arrays, applying animations and responding to different events.","title":"Cookbook"},{"location":"examples/cookbook/#navigation","text":"Using the sidebar to the left, you can browse all of the cookbook examples by name.","title":"Navigation"},{"location":"examples/cookbook/animated-computed/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 -- [Fusion imports omitted for clarity] -- Oftentimes we calculate values for a single purpose, such as the position of -- a single UI element. These values are often calculated inline, like this: local menuBar = New \"Frame\" { AnchorPoint = Computed ( function ( use ) return if use ( menuIsOpen ) then Vector2 . new ( 0.5 , 0 ) else Vector2 . new ( 0.5 , - 1 ) end ) } -- If you want to animate these inline values, you can pass them through an -- object such as Spring and Tween- you don't have to do it separately. local menuBar = New \"Frame\" { -- Use tweens for highly controllable animations: AnchorPoint = Tween ( Computed ( function ( use ) return if use ( menuIsOpen ) then Vector2 . new ( 0.5 , 0 ) else Vector2 . new ( 0.5 , - 1 ) end ), TweenInfo . new ( 0.2 , Enum . EasingStyle . Sine , Enum . EasingDirection . InOut )), -- Or use springs for more natural and responsive movement: AnchorPoint = Spring ( Computed ( function ( use ) return if use ( menuIsOpen ) then Vector2 . new ( 0.5 , 0 ) else Vector2 . new ( 0.5 , - 1 ) end ), 20 , 0.5 ) } -- The equivalent 'expanded' code looks like this: local anchorPoint = Computed ( function ( use ) return if use ( menuIsOpen ) then Vector2 . new ( 0.5 , 0 ) else Vector2 . new ( 0.5 , - 1 ) end ) local smoothAnchorPoint = Spring ( anchorPoint , 20 , 0.5 ) -- or equivalent Tween local menuBar = New \"Frame\" { AnchorPoint = smoothAnchorPoint } -- Keep in mind that you probably shouldn't use inline animation for everything. -- Sometimes you need to use the expanded form, or the expanded form would be -- more efficient, and that's okay - choose what works best for your code :)","title":"Animated Computed"},{"location":"examples/cookbook/button-component/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 -- [Fusion imports omitted for clarity] -- This is a relatively complete example of a button component. -- It handles many common interactions such as hovering and clicking. -- This should be a generally useful template for assembling components of your -- own. Unless you're prototyping, it's probably wise to stick to some good -- guidelines; the Tutorials have some tips if you don't have any existing -- guidelines of your own. -- Defining the names of properties the button accepts, and their types. This is -- useful for autocomplete and helps catch some typos, but is optional. export type Props = { -- some generic properties we'll allow other code to control directly Name : CanBeState < string > ? , LayoutOrder : CanBeState < number > ? , Position : CanBeState < UDim2 > ? , AnchorPoint : CanBeState < Vector2 > ? , Size : CanBeState < UDim2 > ? , AutomaticSize : CanBeState < Enum . AutomaticSize > ? , ZIndex : CanBeState < number > ? , -- button-specific properties Text : CanBeState < string > ? , OnClick : (() -> ()) ? , Disabled : CanBeState < boolean > ? } -- Returns `Child` to match Fusion's `Component` type. This should work for most -- use cases, and offers the greatest encapsulation as you're able to swap out -- your return type for an array or state object if you want to. local function Button ( props : Props ): Child -- We should generally be careful about storing state in widely reused -- components, as the Tutorials explain, but for contained use cases such as -- hover states, it should be perfectly fine. local isHovering = Value ( false ) local isHeldDown = Value ( false ) return New \"TextButton\" { Name = props . Name , LayoutOrder = props . LayoutOrder , Position = props . Position , AnchorPoint = props . AnchorPoint , Size = props . Size , AutomaticSize = props . AutomaticSize , ZIndex = props . ZIndex , Text = props . Text , TextColor3 = Color3 . fromHex ( \"FFFFFF\" ), BackgroundColor3 = Spring ( Computed ( function ( use ) if use ( props . Disabled ) then return Color3 . fromHex ( \"CCCCCC\" ) else local baseColour = Color3 . fromHex ( \"0085FF\" ) -- darken/lighten when hovered or held down if use ( isHeldDown ) then baseColour = baseColour : Lerp ( Color3 . new ( 0 , 0 , 0 ), 0.25 ) elseif use ( isHovering ) then baseColour = baseColour : Lerp ( Color3 . new ( 1 , 1 , 1 ), 0.25 ) end return baseColour end end ), 20 ), [ OnEvent \"Activated\" ] = function () if props . OnClick ~= nil and not peek ( props . Disabled ) then -- We're explicitly calling this function with no arguments to -- match the types we specified above. If we just passed it -- straight into the event, the function would receive arguments -- from the Activated event, which might not be desirable. props . OnClick () end end , [ OnEvent \"MouseButton1Down\" ] = function () isHeldDown : set ( true ) -- it's good UX to give immediate feedback end , [ OnEvent \"MouseButton1Up\" ] = function () isHeldDown : set ( false ) end , [ OnEvent \"MouseEnter\" ] = function () -- Roblox calls this event even if the button is being covered by -- other UI. For simplicity, we won't worry about that. isHovering : set ( true ) end , [ OnEvent \"MouseLeave\" ] = function () isHovering : set ( false ) -- If the button is being held down, but the cursor moves off the -- button, then we won't receive the mouse up event. To make sure -- the button doesn't get stuck held down, we'll release it if the -- cursor leaves the button. isHeldDown : set ( false ) end , [ Children ] = { New \"UICorner\" { CornerRadius = UDim . new ( 0 , 4 ) }, New \"UIPadding\" { PaddingTop = UDim . new ( 0 , 6 ), PaddingBottom = UDim . new ( 0 , 6 ), PaddingLeft = UDim . new ( 0 , 6 ), PaddingRight = UDim . new ( 0 , 6 ) } } } end return Button","title":"Button Component"},{"location":"examples/cookbook/drag-and-drop/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 local GuiService = game : GetService ( \"GuiService\" ) local HttpService = game : GetService ( \"HttpService\" ) local UserInputService = game : GetService ( \"UserInputService\" ) -- [Fusion imports omitted for clarity] -- This example shows a full drag-and-drop implementation for mouse input only. -- Extending this system to generically work with other input types, such as -- touch gestures or gamepads, is left as an exercise to the reader. However, it -- should robustly support dragging many types of UI around flexibly. -- To ensure best accessibility, any interactions you implement shouldn't force -- the player to hold the mouse button down. Either allow drag-and-drop using -- single inputs, or provide a non-dragging alternative; this will ensure that -- players with reduced motor ability aren't locked out of UI functions. -- We're going to need to account for the UI inset sometimes. We cache it here. local TOP_LEFT_INSET = GuiService : GetGuiInset () -- To reflect the current position of the cursor on-screen, we'll use a state -- object that's updated using UserInputService. local mousePos = Value ( UserInputService : GetMouseLocation () - TOP_LEFT_INSET ) local mousePosConn = UserInputService . InputChanged : Connect ( function ( inputObject ) if inputObject . UserInputType == Enum . UserInputType . MouseMovement then mousePos : set ( Vector2 . new ( inputObject . Position . X , inputObject . Position . Y )) end end ) -- We need to keep drag of which item is currently being dragged. Only one item -- can be dragged at a time. This type stores all the information needed: export type CurrentlyDragging = { -- Each draggable item will have a unique ID; the ID stored here represents -- which item is being dragged right now. We'll use strings for this, but -- you could use numbers if that's more convenient for you. id : string , -- When a drag is started, we store the mouse's offset relative to the item -- being dragged. When the mouse moves, we can then apply the same offset to -- make it look like the item is 'pinned' to the cursor. offset : Vector2 } -- This state object stores the above during a drag, or `nil` when not dragging. local currentlyDragging : Value < CurrentlyDragging ? > = Value ( nil ) -- Now we need a component to encapsulate all of our dragging behaviour, such -- as moving our UI between different parents, placing it at the mouse cursor, -- managing sizing, and so on. export type DraggableProps = { -- This should uniquely identify the draggable item apart from all other -- draggable items. This is constant and so shouldn't be a state object. ID : string , -- It doesn't make sense for a draggable item to have a constant parent. You -- wouldn't be able to drop it anywhere else, so we enforce that Parent is a -- state object for our own convenience. Parent : StateObject < Instance ? > , -- When an item is being dragged, it needs to appear above all other UI. We -- will create an overlay frame that fills the screen to achieve this. OverlayFrame : Instance , -- To start a drag, we'll need to know where the top-left corner of the item -- is, so we can calculate `currentlyDragging.offset`. We'll allow the -- calling code to pass through a Value object to [Out \"AbsolutePosition\"]. OutAbsolutePosition : Value < Vector2 ? > ? , Name : CanBeState < string > ? , LayoutOrder : CanBeState < number > ? , Position : CanBeState < UDim2 > ? , AnchorPoint : CanBeState < Vector2 > ? , Size : CanBeState < UDim2 > ? , AutomaticSize : CanBeState < Enum . AutomaticSize > ? , ZIndex : CanBeState < number > ? , [ Children ]: Child } local function Draggable ( props : DraggableProps ): Child -- If we need something to be cleaned up when our item is destroyed, we can -- add it to this array. It'll be passed to `[Cleanup]` later. local cleanupTasks = {} -- This acts like `currentlyDragging`, but filters out anything without a -- matching ID, so it'll only exist when this specific item is dragged. local thisDragging = Computed ( function ( use ) local dragInfo = use ( currentlyDragging ) return if dragInfo ~= nil and dragInfo . id == props . ID then dragInfo else nil end ) -- Our item controls its own parent - one of the few times you'll see this -- done in Fusion. This means we don't have to destroy and re-build the item -- when it moves to a new location. local itemParent = Computed ( function ( use ) return if use ( thisDragging ) ~= nil then props . OverlayFrame else use ( props . Parent ) end , Fusion . doNothing ) -- If we move a scaled UI into the `overlayBox`, by default it will stretch -- to the screen size. Ideally we want it to preserve its current size while -- it's being dragged, so we need to track the parent's size and calculate -- the item size ourselves. -- To start with, we'll store the parent's absolute size. This takes a bit -- of legwork to get right, and we need to remember the UI might not have a -- parent which we can measure the size of - we'll represent that as `nil`. -- Feel free to extract this into a separate function if you want to. local parentSize = Value ( nil ) do -- We'll call this whenever the parent's AbsoluteSize changes, or when -- the parent changes (because different parents might have different -- absolute sizes, if any) local function recalculateParentSize () local parent = peek ( props . Parent ) local parentHasSize = parent ~= nil and parent : IsA ( \"GuiObject\" ) parentSize : set ( if parentHasSize then parent . AbsoluteSize else nil ) end -- We don't just need to connect to the AbsoluteSize changed event of -- the parent we have *right now*! If the parent changes, we need to -- disconnect the old event and re-connect on the new parent, which we -- do here. local parentSizeConn = nil local function rebindToParentSize () if parentSizeConn ~= nil then parentSizeConn : Disconnect () parentSizeConn = nil end local parent = peek ( props . Parent ) local parentHasSize = parent ~= nil and parent : IsA ( \"GuiObject\" ) if parentHasSize then parentSizeConn = parent : GetPropertyChangedSignal ( \"AbsoluteSize\" ): Connect ( recalculateParentSize ) end recalculateParentSize () end local disconnect = Observer ( props . Parent ): onBind ( rebindToParentSize ) -- When the item gets destroyed, we need to disconnect that observer and -- our AbsoluteSize change event (if any is active right now) table.insert ( cleanupTasks , function () disconnect () if parentSizeConn ~= nil then parentSizeConn : Disconnect () parentSizeConn = nil end end ) end -- Now that we have a reliable parent size, we can calculate the item's size -- without worrying about all of those event connections. local itemSize = Computed ( function ( use ) local udim2 = use ( props . Size ) or UDim2 . fromOffset ( 0 , 0 ) local scaleSize = use ( parentSize ) or Vector2 . zero -- might be nil! return UDim2 . fromOffset ( udim2 . X . Scale * scaleSize . X + udim2 . X . Offset , udim2 . Y . Scale * scaleSize . Y + udim2 . Y . Offset ) end ) -- Similarly, we'll need to override the item's position while it's being -- dragged. Happily, this is simpler to do :) local itemPosition = Computed ( function ( use ) local dragInfo = use ( thisDragging ) if dragInfo == nil then return use ( props . Position ) or UDim2 . fromOffset ( 0 , 0 ) else -- `dragInfo.offset` stores the distance from the top-left corner -- of the item to the mouse position. Subtracting the offset from -- the mouse position therefore gives us the item's position. local position = use ( mousePos ) - dragInfo . offset return UDim2 . fromOffset ( position . X , position . Y ) end end ) return New \"Frame\" { Name = props . Name or \"Draggable\" , LayoutOrder = props . LayoutOrder , AnchorPoint = props . AnchorPoint , AutomaticSize = props . AutomaticSize , ZIndex = props . ZIndex , Parent = itemParent , Position = itemPosition , Size = itemSize , BackgroundTransparency = 1 , [ Out \"AbsolutePosition\" ] = props . OutAbsolutePosition , [ Children ] = props [ Children ] } end -- The hard part is over! Now we just need to create some draggable items and -- start/stop drags in response to mouse events. We'll use a very basic example. -- Let's make some to-do items. They'll show up in two lists - one for -- incomplete tasks, and another for complete tasks. You'll be able to drag -- items between the lists to mark them as complete. The lists will be sorted -- alphabetically so we don't have to deal with calculating where the items -- should be placed when they're dropped. export type TodoItem = { id : string , text : string , completed : Value < boolean > } local todoItems : Value < TodoItem > = { { -- You can use HttpService to easily generate unique IDs statelessly. id = HttpService : GenerateGUID (), text = \"Wake up today\" , completed = Value ( true ) }, { id = HttpService : GenerateGUID (), text = \"Read the Fusion docs\" , completed = Value ( true ) }, { id = HttpService : GenerateGUID (), text = \"Take over the universe\" , completed = Value ( false ) } } local function getTodoItemForID ( id : string ): TodoItem ? for _ , item in todoItems do if item . id == id then return item end end return nil end -- These represent the individual draggable to-do item entries in the lists. -- This is where we'll use our `Draggable` component! export type TodoEntryProps = { Item : TodoItem , Parent : StateObject < Instance ? > , OverlayFrame : Instance , } local function TodoEntry ( props : TodoEntryProps ): Child local absolutePosition = Value ( nil ) -- Using our item's ID, we can figure out if we're being dragged to apply -- some styling for dragged items only! local isDragging = Computed ( function ( use ) local dragInfo = use ( currentlyDragging ) return dragInfo ~= nil and dragInfo . id == props . Item . id end ) return Draggable { ID = props . Item . id , Parent = props . Parent , OverlayFrame = props . OverlayFrame , OutAbsolutePosition = absolutePosition , Name = props . Item . text , Size = UDim2 . new ( 1 , 0 , 0 , 50 ), [ Children ] = New \"TextButton\" { Name = \"TodoEntry\" , Size = UDim2 . fromScale ( 1 , 1 ), BackgroundColor3 = Computed ( function ( use ) if use ( isDragging ) then return Color3 . new ( 1 , 1 , 1 ) elseif use ( props . Item . completed ) then return Color3 . new ( 0 , 1 , 0 ) else return Color3 . new ( 1 , 0 , 0 ) end end ), Text = props . Item . text , TextSize = 28 , -- This is where we'll detect mouse down. When the mouse is pressed -- over this item, we should pick it up. [ OnEvent \"MouseButton1Down\" ] = function () -- only start a drag if we're not already dragging if peek ( currentlyDragging ) == nil then local itemPos = peek ( absolutePosition ) or Vector2 . zero local offset = peek ( mousePos ) - itemPos currentlyDragging : set ({ id = props . Item . id , offset = offset }) end end -- We're not going to detect mouse up here, because in some rare -- cases the event could be dropped due to lag between the item's -- position and the cursor position. We'll deal with this at a -- global level instead. } } end -- Now we should construct our two task lists for housing our to-do entries. -- Notice that they don't manage the entries themselves! The entries don't -- belong to these lists after all, so that'd be nonsense :) -- When we release our mouse, we need to know where to drop any dragged item we -- have. This will tell us if we're hovering over either list. local dropAction = Value ( nil ) local incompleteList = New \"ScrollingFrame\" { Name = \"IncompleteTasks\" , Position = UDim2 . fromScale ( 0.1 , 0.1 ), Size = UDim2 . fromScale ( 0.35 , 0.9 ), BackgroundTransparency = 0.75 , BackgroundColor3 = Color3 . new ( 1 , 0 , 0 ), [ OnEvent \"MouseEnter\" ] = function () dropAction : set ( \"incomplete\" ) end , [ OnEvent \"MouseLeave\" ] = function () if peek ( dropAction ) == \"incomplete\" then dropAction : set ( nil ) -- only clear this if it's not overwritten yet end end , [ Children ] = { New \"UIListLayout\" { SortOrder = \"Name\" , Padding = UDim . new ( 0 , 5 ) } } } local completedList = New \"ScrollingFrame\" { Name = \"CompletedTasks\" , Position = UDim2 . fromScale ( 0.55 , 0.1 ), Size = UDim2 . fromScale ( 0.35 , 0.9 ), BackgroundTransparency = 0.75 , BackgroundColor3 = Color3 . new ( 0 , 1 , 0 ), [ OnEvent \"MouseEnter\" ] = function () dropAction : set ( \"completed\" ) end , [ OnEvent \"MouseLeave\" ] = function () if peek ( dropAction ) == \"completed\" then dropAction : set ( nil ) -- only clear this if it's not overwritten yet end end , [ Children ] = { New \"UIListLayout\" { SortOrder = \"Name\" , Padding = UDim . new ( 0 , 5 ) } } } -- Now we can write a mouse up handler to drop our items. local mouseUpConn = UserInputService . InputEnded : Connect ( function ( inputObject ) if inputObject . UserInputType ~= Enum . UserInputType . MouseButton1 then return end local dragInfo = peek ( currentlyDragging ) if dragInfo == nil then return end local item = getTodoItemForID ( dragInfo . id ) local action = peek ( dropAction ) if item ~= nil then if action == \"incomplete\" then item . completed : set ( false ) elseif action == \"completed\" then item . completed : set ( true ) end end currentlyDragging : set ( nil ) end ) -- We'll need to construct an overlay frame for our items to live in while they -- get dragged around. local overlayFrame = New \"Frame\" { Size = UDim2 . fromScale ( 1 , 1 ), ZIndex = 10 , BackgroundTransparency = 1 } -- Let's construct the items themselves! Because we're constructing them at the -- global level like this, they're only created and destroyed when they're added -- and removed from the list. local allEntries = ForValues ( todoItems , function ( use , item ) return TodoEntry { Item = item , Parent = Computed ( function () return if use ( item . completed ) then completedList else incompleteList end , Fusion . doNothing ), OverlayFrame = overlayFrame } end , Fusion . cleanup ) -- Finally, construct the whole UI :) local ui = New \"ScreenGui\" { Parent = game : GetService ( \"Players\" ). LocalPlayer . PlayerGui , [ Cleanup ] = { mousePosConn , mouseUpConn }, [ Children ] = { overlayFrame , incompleteList , completedList -- We don't have to pass `allEntries` in here - they manage their own -- parenting thanks to `Draggable` :) } }","title":"Drag & Drop"},{"location":"examples/cookbook/fetch-data-from-server/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 -- [Fusion imports omitted for clarity] -- This code assumes that there is a RemoteFunction at this location, which -- accepts a user ID and will return a string with that user's bio text. -- The server implementation is not shown here. local FetchUserBio = game : GetService ( \"ReplicatedStorage\" ). FetchUserBio -- Creating a Value object to store the user ID we're currently looking at local currentUserID = Value ( 1670764 ) -- If we could instantly calculate the user's bio text, we could use a Computed -- here. However, fetching data from the server takes time, which means we can't -- use Computed without introducing serious consistency errors into our program. -- Instead, we fall back to using an observer to manually manage our own value: local currentUserBio = Value ( nil ) -- Using a scope to hide our management code from the rest of the script: do local lastFetchTime = nil local function fetch () local fetchTime = os.clock () lastFetchTime = fetchTime currentUserBio : set ( nil ) -- set to a default value to indicate loading task . spawn ( function () local bio = FetchUserBio : InvokeServer ( peek ( currentUserID )) -- If these two are not equal, then that means another fetch was -- started while we were waiting for the server to return a value. -- In that case, the more recent call will be more up-to-date, so we -- shouldn't overwrite it. This adds a nice layer of reassurance, -- but if your value doesn't change often, this might be optional. if lastFetchTime == fetchTime then currentUserBio : set ( bio ) end end ) end fetch () -- get the bio for the initial user ID -- when the user ID changes, reload the bio local disconnect = Observer ( currentUserID ): onChange ( fetch ) -- Don't forget to call `disconnect` when you're done with `currentUserBio`. -- That's not included in this code snippet, but it's important if you want -- to avoid leaking memory. end -- Now, you can use `currentUserBio` just like any other state object! Note that -- `nil` is used to represent a bio that hasn't loaded yet, so you'll want to -- handle that case before passing it into any code that expects a solid value. local bioLabel = New \"TextLabel\" { Text = Computed ( function ( use ) return use ( currentUserBio ) or \"Loading user bio...\" end ) }","title":"Fetch Data From Server"},{"location":"examples/cookbook/light-and-dark-theme/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 -- [Fusion imports omitted for clarity] -- Defining some theme colours. Something to note; I'm intentionally putting the -- actual colour names as the topmost keys here, and putting `light` and `dark` -- keys inside the colours. If you did it the other way around, then there's no -- single source of truth for what colour names are available, and it's hard to -- keep in sync. If a theme doesn't have a colour, it's better to explicitly not -- specify it under the colour name. local THEME_COLOURS = { background = { light = Color3 . fromHex ( \"FFFFFF\" ), dark = Color3 . fromHex ( \"2D2D2D\" ) }, text = { light = Color3 . fromHex ( \"2D2D2D\" ), dark = Color3 . fromHex ( \"FFFFFF\" ) }, -- [etc, for all the colours you'd want] } -- This will control which colours we're using at the moment. You could expose -- this to the rest of your code directly, or calculate it using a Computed. local currentTheme = Value ( \"light\" ) -- Now we'll create a Computed for every theme colour, which will pick a colour -- from `THEME_COLS` based on our `currentTheme`. local currentColours = {} for colourName , colourOptions in THEME_COLOURS do currentColours [ colourName ] = Computed ( function ( use ) return colourOptions [ use ( currentTheme )] end ) end -- Now you can expose `colourOptions` to the rest of your code, preferably under -- a convenient name :) local text = New \"TextLabel\" { TextColor3 = currentColours . text }","title":"Light & Dark Theme"},{"location":"examples/cookbook/loading-spinner/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 local RunService = game : GetService ( \"RunService\" ) -- [Fusion imports omitted for clarity] -- Loading spinners generally don't use transition-based animations like tweens. -- Instead, they animate continuously and independently, so we'll need to set up -- our own animation clock that will drive the animation. -- We can set up one clock and use it everywhere. local timer = Value ( os.clock ()) local timerConn = RunService . RenderStepped : Connect ( function () -- Remember to disconnect this event when you're done using it! timer : set ( os.clock ()) end ) -- Our loading spinner will consist of an image which rotates around. You could -- do something more complex or intricate for spice, but in the interest of -- providing a simple starting point, let's keep it simple. local spinner = New \"ImageLabel\" { Position = UDim2 . fromScale ( 0.5 , 0.5 ), AnchorPoint = Vector2 . new ( 0.5 , 0.5 ), Size = UDim2 . fromOffset ( 50 , 50 ), BackgroundTransparency = 1 , Image = \"rbxassetid://your-loading-spinner-image\" , -- replace this! -- As the timer runs, this will automatically update and rotate our image. Rotation = Computed ( function ( use ) local time = use ( timer ) local angle = time * 180 -- Spin at a rate of 180 degrees per second angle %= 360 -- Don't need to go beyond 360 degrees; wrap instead return angle end ), -- If your `timer` is only used by this one loading spinner, you can clean -- up the `timerConn` here. If you're re-using one timer for all of your -- spinners, you don't need to do this here. [ Cleanup ] = timerConn }","title":"Loading Spinner"},{"location":"examples/cookbook/player-list/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 -- [Fusion imports omitted for clarity] type Set < T > = {[ T ]: true } -- Defining a component for each row of the player list. -- Each row represents a player currently logged into the server. -- We set the `Name` to the player's name so the rows can be sorted by name. type PlayerListRowProps = { Player : Player } local function PlayerListRow ( props : PlayerListRowProps ) return New \"TextLabel\" { Name = props . Player . DisplayName , Size = UDim2 . new ( 1 , 0 , 0 , 25 ), BackgroundTransparency = 1 , Text = props . Player . DisplayName , TextColor3 = Color3 . new ( 1 , 1 , 1 ), Font = Enum . Font . GothamMedium , FontSize = 16 , TextXAlignment = \"Right\" , TextTruncate = \"AtEnd\" , [ Children ] = New \"UIPadding\" { PaddingLeft = UDim . new ( 0 , 10 ), PaddingRight = UDim . new ( 0 , 10 ) } } end -- Defining a component for the entire player list. -- It should take in a set of all logged-in players, and it should be a state -- object so the set of players can change as players join and leave. type PlayerListProps = { PlayerSet : Fusion . StateObject < Set < Player >> } local function PlayerList ( props : PlayerListProps ) return New \"Frame\" { Name = \"PlayerList\" , Position = UDim2 . fromScale ( 1 , 0 ), AnchorPoint = Vector2 . new ( 1 , 0 ), Size = UDim2 . fromOffset ( 300 , 0 ), AutomaticSize = \"Y\" , BackgroundTransparency = 0.5 , BackgroundColor3 = Color3 . new ( 0 , 0 , 0 ), [ Children ] = { New \"UICorner\" {}, New \"UIListLayout\" { SortOrder = \"Name\" , FillDirection = \"Vertical\" }, ForPairs ( props . PlayerSet , function ( use , player , _ ) return player , PlayerListRow { Player = player } end , Fusion . cleanup ) } } end -- To create the PlayerList component, first we need a state object that stores -- the set of logged-in players, and updates as players join and leave. local Players = game : GetService ( \"Players\" ) local playerSet = Value () local function updatePlayerSet () local newPlayerSet = {} for _ , player in Players : GetPlayers () do newPlayerSet [ player ] = true end playerSet : set ( newPlayerSet ) end local playerConnections = { Players . PlayerAdded : Connect ( updatePlayerSet ), Players . PlayerRemoving : Connect ( updatePlayerSet ) } updatePlayerSet () -- Now, we can create the component and pass in `playerSet`. -- Don't forget to clean up your connections when your UI is destroyed; to do -- that, we're using the `[Cleanup]` key to clean up `playerConnections` later. local gui = New \"ScreenGui\" { Name = \"PlayerListGui\" , Parent = Players . LocalPlayer : FindFirstChildOfClass ( \"PlayerGui\" ), [ Cleanup ] = playerConnections , [ Children ] = PlayerList { PlayerSet = playerSet } }","title":"Player List"},{"location":"extras/","text":"Extras \u00b6 Welcome to the Extras section! Here, you can find guidelines and assets for Fusion branding, download backgrounds and wallpapers for your devices, and more! Commonly Used \u00b6 Backgrounds Brand Guidelines","title":"Home"},{"location":"extras/#extras","text":"Welcome to the Extras section! Here, you can find guidelines and assets for Fusion branding, download backgrounds and wallpapers for your devices, and more!","title":"Extras"},{"location":"extras/#commonly-used","text":"Backgrounds Brand Guidelines","title":"Commonly Used"},{"location":"extras/backgrounds/","text":"All backgrounds are PNG format, and have been optimised for these resolutions: Ultrawide (7680 x 1440) Widescreen (2560 x 1440) 3:2 (2256 x 1504) Mobile (1125 x 2436) These backgrounds are intended for personal use only! These backgrounds are, and remain, the copyright of Elttob. You may not use these, commercially or otherwise, without explicit written consent. Isosceles \u00b6 A pattern of isosceles triangles distributed along the bottom, with the Fusion gradient. Background is hex colour #1D1D1F, and so might not be ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile Extrusion \u00b6 A Fusion logo, with extruded fill lines coming out of the logo. Background is hex colour #0D0D0F, and so might not be ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile Construction \u00b6 The Fusion logo, with construction lines shown and other geometric patterns. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile Glow \u00b6 A centred Fusion logo emitting light on a dark background. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile Glow (Alternate) \u00b6 A centred Fusion logo emitting light on a dark background. Uses an alternate design of the logo, which is now used for livestreams. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Backgrounds"},{"location":"extras/backgrounds/#isosceles","text":"A pattern of isosceles triangles distributed along the bottom, with the Fusion gradient. Background is hex colour #1D1D1F, and so might not be ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Isosceles"},{"location":"extras/backgrounds/#extrusion","text":"A Fusion logo, with extruded fill lines coming out of the logo. Background is hex colour #0D0D0F, and so might not be ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Extrusion"},{"location":"extras/backgrounds/#construction","text":"The Fusion logo, with construction lines shown and other geometric patterns. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Construction"},{"location":"extras/backgrounds/#glow","text":"A centred Fusion logo emitting light on a dark background. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Glow"},{"location":"extras/backgrounds/#glow-alternate","text":"A centred Fusion logo emitting light on a dark background. Uses an alternate design of the logo, which is now used for livestreams. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Glow (Alternate)"},{"location":"extras/brand-guidelines/","text":"The Fusion branding is designed to be simplistic, modern, easy to recognise and distinctive. Colours \u00b6 Primaries \u00b6 These colours are used in the Fusion logo and most illustrations. They might not be suitable for text or all backgrounds. FusionDoc greys \u00b6 These colours are used by the FusionDoc theme on this website for all grey tones used on pages. FusionDoc accents \u00b6 These colours are used by the FusionDoc theme on this website for accent colours on links and interactive elements. Best Practices \u00b6 We would love you to use the Fusion branding in your own work, but please be mindful that you use it appropriately. If you're not sure, feel free to reach out over Discord or Twitter - it's always better to ask first to be secure! These aren't hard and fast rules, and we can't and don't want to police how people use our stuff. Instead, these are provided as best practices to follow. We'll add any common examples or questions to this list over time. Brand Confusion \u00b6 Fusion's logo and name are designed to represent Fusion's official projects. Please don't use them to represent things that are not Fusion; for example, if you build your own UI library, it's better to design a new logo. In general, prefer to keep some distance between your project branding and Fusion's branding, enough distance that people don't get confused about who makes what, or whether a project is officially supported or not. It's a good litmus test to imagine a first-time user who knows nothing about Fusion, and how they will perceive your project. Don't do this In this example, someone made their own UI library and named it Fusion 2. Note that this is an extreme example for demonstration purposes - most violations of this principle are probably more subtle. This is bad because people might mistakenly think the official Fusion project approves or provides support for this unrelated project, which would cause many headaches and is dishonest about the relationship between the two libraries. Plus, in this example, we reserve the right to update Fusion to version 2 at any time, which would immediately cause a naming conflict. Instead, do this This logo makes it more clear that the project is not a port of, update to or bindings for the Fusion library. Instead, it's a completely distinct project which only takes inspiration from Fusion, but is otherwise unrelated. It's okay for the logo to remind people of Fusion's design. Remember - you don't have to be completely original, just distinct enough that it isn't confusing for people. Acceptable, but be careful Here, this plugin is using the Fusion logo to represent a 'Convert to Fusion' action. This is fine, because users will understand the Fusion logo represents the thing being converted to. However, be careful, as free-standing uses of the Fusion icon like this can easily become confusing. Make sure people understand the logo represents Fusion, and not the plugin, so confusion between the two is minimised.","title":"Brand Guidelines"},{"location":"extras/brand-guidelines/#colours","text":"","title":"Colours"},{"location":"extras/brand-guidelines/#primaries","text":"These colours are used in the Fusion logo and most illustrations. They might not be suitable for text or all backgrounds.","title":"Primaries"},{"location":"extras/brand-guidelines/#fusiondoc-greys","text":"These colours are used by the FusionDoc theme on this website for all grey tones used on pages.","title":"FusionDoc greys"},{"location":"extras/brand-guidelines/#fusiondoc-accents","text":"These colours are used by the FusionDoc theme on this website for accent colours on links and interactive elements.","title":"FusionDoc accents"},{"location":"extras/brand-guidelines/#best-practices","text":"We would love you to use the Fusion branding in your own work, but please be mindful that you use it appropriately. If you're not sure, feel free to reach out over Discord or Twitter - it's always better to ask first to be secure! These aren't hard and fast rules, and we can't and don't want to police how people use our stuff. Instead, these are provided as best practices to follow. We'll add any common examples or questions to this list over time.","title":"Best Practices"},{"location":"extras/brand-guidelines/#brand-confusion","text":"Fusion's logo and name are designed to represent Fusion's official projects. Please don't use them to represent things that are not Fusion; for example, if you build your own UI library, it's better to design a new logo. In general, prefer to keep some distance between your project branding and Fusion's branding, enough distance that people don't get confused about who makes what, or whether a project is officially supported or not. It's a good litmus test to imagine a first-time user who knows nothing about Fusion, and how they will perceive your project. Don't do this In this example, someone made their own UI library and named it Fusion 2. Note that this is an extreme example for demonstration purposes - most violations of this principle are probably more subtle. This is bad because people might mistakenly think the official Fusion project approves or provides support for this unrelated project, which would cause many headaches and is dishonest about the relationship between the two libraries. Plus, in this example, we reserve the right to update Fusion to version 2 at any time, which would immediately cause a naming conflict. Instead, do this This logo makes it more clear that the project is not a port of, update to or bindings for the Fusion library. Instead, it's a completely distinct project which only takes inspiration from Fusion, but is otherwise unrelated. It's okay for the logo to remind people of Fusion's design. Remember - you don't have to be completely original, just distinct enough that it isn't confusing for people. Acceptable, but be careful Here, this plugin is using the Fusion logo to represent a 'Convert to Fusion' action. This is fine, because users will understand the Fusion logo represents the thing being converted to. However, be careful, as free-standing uses of the Fusion icon like this can easily become confusing. Make sure people understand the logo represents Fusion, and not the plugin, so confusion between the two is minimised.","title":"Brand Confusion"},{"location":"tutorials/","text":"Welcome to the Fusion tutorial section! Here, you'll learn how to build great things with Fusion, even if you're a complete newcomer to the library. But first, something important... Do not use Fusion for real-world production work unless you're 100,000% willing and able to withstand large breaking changes. Fusion is in beta right now! You will encounter: bugs in core features updates that completely remove existing features changes in behaviour between versions changing advice on coding conventions and how to structure your project This is not a bad thing! Moving fast with Fusion at this early stage means we can quickly abandon counterproductive ideas and features, and discover much more solid foundations to build upon. Don't be discouraged from Fusion though; feel free to follow along with our development and try using the library in your own time! More stable, long-term Fusion versions will be available once Fusion exits beta testing. What You Need To Know \u00b6 These tutorials assume: You're comfortable with Roblox and the Luau scripting language. These tutorials aren't an introduction to scripting! If you'd like to learn, check out the Roblox DevHub . You're familiar with how UI works on Roblox. You don't have to be a designer - knowing about UI instances, events and data types like UDim2 and Color3 will be good enough. Of course, based on your existing knowledge, you may find some tutorials easier or harder. Fusion's built to be easy to learn, but it may still take a bit of time to absorb some concepts, so don't be discouraged Installing Fusion \u00b6 Fusion is distributed as a single module script. Before starting, you'll need to add this module script to your game. Here's how: If you edit scripts in Roblox Studio... \u00b6 Head over to Fusion's 'Releases' page . Click the 'Assets' dropdown to view the downloadable files: Now, click on the Fusion.rbxm file to download it. This contains the module as a Roblox model: Head into Roblox Studio to import the model; if you're just following the tutorials, an empty baseplate will do. Right-click on ReplicatedStorage , and select 'Insert from File': Select the Fusion.rbxm file you just downloaded. You should see the module script appear in ReplicatedStorage - you're ready to go! If you edit scripts externally... (advanced) \u00b6 If you use an external editor to write scripts, and synchronise them into Roblox using a plugin, you can use these alternate steps instead: Steps (click to expand) Head over to Fusion's 'Releases' page . Under 'Assets', download Source code (zip) . Inside is a copy of the Fusion GitHub repository. Inside the zip, copy the src folder - it may be inside another folder. Paste src into your local project, preferably in your shared folder if you have one. Rename the folder from src to Fusion . Once everything is set up, you should see Fusion appear in Studio when you next synchronise your project. Setting Up A Test Script \u00b6 Now that you've installed Fusion, you can set up a local script for testing. Here's how: Create a LocalScript in StarterGui or StarterPlayerScripts . Remove the default code, and paste the following code in: 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) Press 'Play' - if there are no errors, everything was set up correctly! My script didn't work! (click to expand) Fusion is not a valid member of ReplicatedStorage \"ReplicatedStorage\" If you're seeing this error, then your script can't find Fusion. This code assumes you've installed Fusion into ReplicatedStorage . If you've installed Fusion elsewhere, you'll need to tweak the require() on line 2 to point to the correct location. If line 2 looks like it points to the correct location, refer back to the previous section and double-check you've set everything up properly. Make sure you have a ModuleScript inside ReplicatedStorage called \"Fusion\". Where To Get Help \u00b6 Fusion is built to be easy to use, and we want these tutorials to be as useful and comprehensive as possible. However, maybe you're stuck on a cursed issue and really need some help; or perhaps you're looking to get a better overall understanding of Fusion! Whatever you're looking for, here are some resources for you to get help: The Roblox OSS Discord has a #fusion channel Check out our Discussions page on GitHub Open an issue if you run into bugs or have feature requests","title":"Get Started"},{"location":"tutorials/#what-you-need-to-know","text":"These tutorials assume: You're comfortable with Roblox and the Luau scripting language. These tutorials aren't an introduction to scripting! If you'd like to learn, check out the Roblox DevHub . You're familiar with how UI works on Roblox. You don't have to be a designer - knowing about UI instances, events and data types like UDim2 and Color3 will be good enough. Of course, based on your existing knowledge, you may find some tutorials easier or harder. Fusion's built to be easy to learn, but it may still take a bit of time to absorb some concepts, so don't be discouraged","title":"What You Need To Know"},{"location":"tutorials/#installing-fusion","text":"Fusion is distributed as a single module script. Before starting, you'll need to add this module script to your game. Here's how:","title":"Installing Fusion"},{"location":"tutorials/#if-you-edit-scripts-in-roblox-studio","text":"Head over to Fusion's 'Releases' page . Click the 'Assets' dropdown to view the downloadable files: Now, click on the Fusion.rbxm file to download it. This contains the module as a Roblox model: Head into Roblox Studio to import the model; if you're just following the tutorials, an empty baseplate will do. Right-click on ReplicatedStorage , and select 'Insert from File': Select the Fusion.rbxm file you just downloaded. You should see the module script appear in ReplicatedStorage - you're ready to go!","title":"If you edit scripts in Roblox Studio..."},{"location":"tutorials/#if-you-edit-scripts-externally-advanced","text":"If you use an external editor to write scripts, and synchronise them into Roblox using a plugin, you can use these alternate steps instead: Steps (click to expand) Head over to Fusion's 'Releases' page . Under 'Assets', download Source code (zip) . Inside is a copy of the Fusion GitHub repository. Inside the zip, copy the src folder - it may be inside another folder. Paste src into your local project, preferably in your shared folder if you have one. Rename the folder from src to Fusion . Once everything is set up, you should see Fusion appear in Studio when you next synchronise your project.","title":"If you edit scripts externally... (advanced)"},{"location":"tutorials/#setting-up-a-test-script","text":"Now that you've installed Fusion, you can set up a local script for testing. Here's how: Create a LocalScript in StarterGui or StarterPlayerScripts . Remove the default code, and paste the following code in: 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) Press 'Play' - if there are no errors, everything was set up correctly! My script didn't work! (click to expand) Fusion is not a valid member of ReplicatedStorage \"ReplicatedStorage\" If you're seeing this error, then your script can't find Fusion. This code assumes you've installed Fusion into ReplicatedStorage . If you've installed Fusion elsewhere, you'll need to tweak the require() on line 2 to point to the correct location. If line 2 looks like it points to the correct location, refer back to the previous section and double-check you've set everything up properly. Make sure you have a ModuleScript inside ReplicatedStorage called \"Fusion\".","title":"Setting Up A Test Script"},{"location":"tutorials/#where-to-get-help","text":"Fusion is built to be easy to use, and we want these tutorials to be as useful and comprehensive as possible. However, maybe you're stuck on a cursed issue and really need some help; or perhaps you're looking to get a better overall understanding of Fusion! Whatever you're looking for, here are some resources for you to get help: The Roblox OSS Discord has a #fusion channel Check out our Discussions page on GitHub Open an issue if you run into bugs or have feature requests","title":"Where To Get Help"},{"location":"tutorials/animation/springs/","text":"Springs follow the value of other state objects using a physical spring simulation. This can be used for 'springy' effects, or for smoothing out movement naturally without abrupt changes in direction. Usage \u00b6 To use Spring in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Spring = Fusion . Spring To create a new spring object, call the Spring function and pass it a state object to move towards: local goal = Value ( 0 ) local animated = Spring ( target ) The spring will smoothly follow the 'goal' state object over time. As with other state objects, you can peek() at its value at any time: print ( peek ( animated )) --> 0.26425... To configure how the spring moves, you can provide a speed and damping ratio to use. Both are optional, and both can be state objects if desired: local goal = Value ( 0 ) local speed = 25 local damping = Value ( 0.5 ) local animated = Spring ( target , speed , damping ) You can use many different kinds of values with springs, not just numbers. Vectors, CFrames, Color3s, UDim2s and other number-based types are supported; each number inside the type is animated individually. local goalPosition = Value ( UDim2 . new ( 0.5 , 0 , 0 , 0 )) local animated = Spring ( target , 25 , 0.5 ) Damping Ratio \u00b6 The damping ratio (a.k.a damping) of the spring changes the friction in the physics simulation. Lower values allow the spring to move freely and oscillate up and down, while higher values restrict movement. Zero damping \u00b6 Zero damping means no friction is applied, so the spring will oscillate forever without losing energy. This is generally not useful. Underdamping \u00b6 A damping between 0 and 1 means some friction is applied. The spring will still oscillate, but it will lose energy and eventually settle at the goal. Critical damping \u00b6 A damping of exactly 1 means just enough friction is applied to stop the spring from oscillating. It reaches its goal as quickly as possible without going past. This is also commonly known as critical damping. Overdamping \u00b6 A damping above 1 applies excessive friction to the spring. The spring behaves like it's moving through honey, glue or some other viscous fluid. Overdamping reduces the effect of velocity changes, and makes movement more rigid. Speed \u00b6 The speed of the spring scales how much time it takes for the spring to move. Doubling the speed makes it move twice as fast; halving the speed makes it move twice as slow. Interruption \u00b6 Springs do not share the same interruption problems as tweens. When the goal changes, springs are guaranteed to preserve both position and velocity, reducing jank: This also means springs are suitable for following rapidly changing values:","title":"Springs"},{"location":"tutorials/animation/springs/#usage","text":"To use Spring in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Spring = Fusion . Spring To create a new spring object, call the Spring function and pass it a state object to move towards: local goal = Value ( 0 ) local animated = Spring ( target ) The spring will smoothly follow the 'goal' state object over time. As with other state objects, you can peek() at its value at any time: print ( peek ( animated )) --> 0.26425... To configure how the spring moves, you can provide a speed and damping ratio to use. Both are optional, and both can be state objects if desired: local goal = Value ( 0 ) local speed = 25 local damping = Value ( 0.5 ) local animated = Spring ( target , speed , damping ) You can use many different kinds of values with springs, not just numbers. Vectors, CFrames, Color3s, UDim2s and other number-based types are supported; each number inside the type is animated individually. local goalPosition = Value ( UDim2 . new ( 0.5 , 0 , 0 , 0 )) local animated = Spring ( target , 25 , 0.5 )","title":"Usage"},{"location":"tutorials/animation/springs/#damping-ratio","text":"The damping ratio (a.k.a damping) of the spring changes the friction in the physics simulation. Lower values allow the spring to move freely and oscillate up and down, while higher values restrict movement.","title":"Damping Ratio"},{"location":"tutorials/animation/springs/#zero-damping","text":"Zero damping means no friction is applied, so the spring will oscillate forever without losing energy. This is generally not useful.","title":"Zero damping"},{"location":"tutorials/animation/springs/#underdamping","text":"A damping between 0 and 1 means some friction is applied. The spring will still oscillate, but it will lose energy and eventually settle at the goal.","title":"Underdamping"},{"location":"tutorials/animation/springs/#critical-damping","text":"A damping of exactly 1 means just enough friction is applied to stop the spring from oscillating. It reaches its goal as quickly as possible without going past. This is also commonly known as critical damping.","title":"Critical damping"},{"location":"tutorials/animation/springs/#overdamping","text":"A damping above 1 applies excessive friction to the spring. The spring behaves like it's moving through honey, glue or some other viscous fluid. Overdamping reduces the effect of velocity changes, and makes movement more rigid.","title":"Overdamping"},{"location":"tutorials/animation/springs/#speed","text":"The speed of the spring scales how much time it takes for the spring to move. Doubling the speed makes it move twice as fast; halving the speed makes it move twice as slow.","title":"Speed"},{"location":"tutorials/animation/springs/#interruption","text":"Springs do not share the same interruption problems as tweens. When the goal changes, springs are guaranteed to preserve both position and velocity, reducing jank: This also means springs are suitable for following rapidly changing values:","title":"Interruption"},{"location":"tutorials/animation/tweens/","text":"Tweens follow the value of other state objects using a pre-made animation curve. This can be used for basic, predictable animations. Usage \u00b6 To use Tween in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Tween = Fusion . Tween To create a new tween object, call the Tween function and pass it a state object to move towards: local goal = Value ( 0 ) local animated = Tween ( target ) The tween will smoothly follow the 'goal' state object over time. As with other state objects, you can peek() at its value at any time: print ( peek ( animated )) --> 0.26425... To configure how the tween moves, you can provide a TweenInfo to change the shape of the animation curve. It's optional, and it can be a state object if desired: local goal = Value ( 0 ) local style = TweenInfo . new ( 0.5 , Enum . EasingStyle . Quad ) local animated = Tween ( target , style ) You can use many different kinds of values with tweens, not just numbers. Vectors, CFrames, Color3s, UDim2s and other number-based types are supported; each number inside the type is animated individually. local goalPosition = Value ( UDim2 . new ( 0.5 , 0 , 0 , 0 )) local animated = Tween ( target , TweenInfo . new ( 0.5 , Enum . EasingStyle . Quad )) Time \u00b6 The first parameter of TweenInfo is time. This specifies how long it should take for the value to animate to the goal, in seconds. Easing Style \u00b6 The second parameter of TweenInfo is easing style. By setting this to various Enum.EasingStyle values, you can select different pre-made animation curves. Easing Direction \u00b6 The third parameter of TweenInfo is easing direction. This can be set to one of three values to control how the tween starts and stops: Enum.EasingDirection.Out makes the tween animate out smoothly. Enum.EasingDirection.In makes the tween animate in smoothly. Enum.EasingDirection.InOut makes the tween animate in and out smoothly. Repeats \u00b6 The fourth parameter of TweenInfo is repeat count. This can be used to loop the animation a number of times. Setting the repeat count to a negative number causes it to loop infinitely. This is not generally useful for transition animations. Reversing \u00b6 The fifth parameter of TweenInfo is a reversing option. When enabled, the animation will return to the starting point. This is not typically useful because the animation doesn't end at the goal value, and might not end at the start value either if the animation is interrupted. Delay \u00b6 The sixth and final parameter of TweenInfo is delay. Increasing this delay adds empty space before the beginning of the animation curve. It's important to note this is not the same as a true delay. This option does not delay the input signal - it only makes the tween animation longer. Interruption \u00b6 Because tweens are built from pre-made, fixed animation curves, you should avoid interrupting those animation curves before they're finished. Interrupting a tween halfway through leads to abrupt changes in velocity, which can cause your animation to feel janky: Tweens also can't track constantly changing targets very well. That's because the tween is always getting interrupted as it gets started, so it never has time to play out much of its animation. These issues arise because tweens don't 'remember' their previous velocity when they start animating towards a new goal. If you need velocity to be remembered, it's a much better idea to use springs, which can preserve their momentum.","title":"Tweens"},{"location":"tutorials/animation/tweens/#usage","text":"To use Tween in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Tween = Fusion . Tween To create a new tween object, call the Tween function and pass it a state object to move towards: local goal = Value ( 0 ) local animated = Tween ( target ) The tween will smoothly follow the 'goal' state object over time. As with other state objects, you can peek() at its value at any time: print ( peek ( animated )) --> 0.26425... To configure how the tween moves, you can provide a TweenInfo to change the shape of the animation curve. It's optional, and it can be a state object if desired: local goal = Value ( 0 ) local style = TweenInfo . new ( 0.5 , Enum . EasingStyle . Quad ) local animated = Tween ( target , style ) You can use many different kinds of values with tweens, not just numbers. Vectors, CFrames, Color3s, UDim2s and other number-based types are supported; each number inside the type is animated individually. local goalPosition = Value ( UDim2 . new ( 0.5 , 0 , 0 , 0 )) local animated = Tween ( target , TweenInfo . new ( 0.5 , Enum . EasingStyle . Quad ))","title":"Usage"},{"location":"tutorials/animation/tweens/#time","text":"The first parameter of TweenInfo is time. This specifies how long it should take for the value to animate to the goal, in seconds.","title":"Time"},{"location":"tutorials/animation/tweens/#easing-style","text":"The second parameter of TweenInfo is easing style. By setting this to various Enum.EasingStyle values, you can select different pre-made animation curves.","title":"Easing Style"},{"location":"tutorials/animation/tweens/#easing-direction","text":"The third parameter of TweenInfo is easing direction. This can be set to one of three values to control how the tween starts and stops: Enum.EasingDirection.Out makes the tween animate out smoothly. Enum.EasingDirection.In makes the tween animate in smoothly. Enum.EasingDirection.InOut makes the tween animate in and out smoothly.","title":"Easing Direction"},{"location":"tutorials/animation/tweens/#repeats","text":"The fourth parameter of TweenInfo is repeat count. This can be used to loop the animation a number of times. Setting the repeat count to a negative number causes it to loop infinitely. This is not generally useful for transition animations.","title":"Repeats"},{"location":"tutorials/animation/tweens/#reversing","text":"The fifth parameter of TweenInfo is a reversing option. When enabled, the animation will return to the starting point. This is not typically useful because the animation doesn't end at the goal value, and might not end at the start value either if the animation is interrupted.","title":"Reversing"},{"location":"tutorials/animation/tweens/#delay","text":"The sixth and final parameter of TweenInfo is delay. Increasing this delay adds empty space before the beginning of the animation curve. It's important to note this is not the same as a true delay. This option does not delay the input signal - it only makes the tween animation longer.","title":"Delay"},{"location":"tutorials/animation/tweens/#interruption","text":"Because tweens are built from pre-made, fixed animation curves, you should avoid interrupting those animation curves before they're finished. Interrupting a tween halfway through leads to abrupt changes in velocity, which can cause your animation to feel janky: Tweens also can't track constantly changing targets very well. That's because the tween is always getting interrupted as it gets started, so it never has time to play out much of its animation. These issues arise because tweens don't 'remember' their previous velocity when they start animating towards a new goal. If you need velocity to be remembered, it's a much better idea to use springs, which can preserve their momentum.","title":"Interruption"},{"location":"tutorials/components/callbacks/","text":"Normally, components are controlled by the code creating them. This is called top-down control, and is the primary flow of control in Fusion. However, sometimes components need to talk back to their controlling code, for example to report when button clicks occur. In Luau \u00b6 Callbacks are functions which you pass into other functions. They're part of normal Luau code. workspace . ChildAdded : Connect ( function () -- this function is a callback! end ) They're useful because they allow the function to 'call back' into your code, so your code can do something in response: local function printMessage () print ( \"Hello, world!\" ) end -- Here, we're passing `printMessage` as a callback -- `task.delay` will call it after 5 seconds task . delay ( 5 , printMessage ) If your function accepts a callback, then you can call it like any other function. Luau will execute the function, then return to your code. In this example, the fiveTimes function calls a callback five times: Script code Output local function fiveTimes ( callback ) for x = 1 , 5 do callback ( x ) end end fiveTimes ( function ( num ) print ( \"The number is\" , num ) end ) The number is 1 The number is 2 The number is 3 The number is 4 The number is 5 In Fusion \u00b6 Components can use callbacks the same way. Consider this button component; when the button is clicked, the button needs to run some external code: local function Button ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 0.25 , 0.5 , 1 ), Position = props . Position , Size = props . Size , Text = props . Text , TextColor3 = Color3 . new ( 1 , 1 , 1 ), [ OnEvent \"Activated\" ] = -- ??? } end It can ask the controlling code to provide a callback in props , called OnClick: local button = Button { Text = \"Hello, world!\" , OnClick = function () print ( \"The button was clicked\" ) end } Assuming that callback is passed in, the callback can be passed directly into [OnEvent] , because [OnEvent] accepts functions: local function Button ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 0.25 , 0.5 , 1 ), Position = props . Position , Size = props . Size , Text = props . Text , TextColor3 = Color3 . new ( 1 , 1 , 1 ), [ OnEvent \"Activated\" ] = props . OnClick } end Alternatively, we can call props.OnClick manually, which is useful if you want to do your own processing first: local function Button ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 0.25 , 0.5 , 1 ), Position = props . Position , Size = props . Size , Text = props . Text , TextColor3 = Color3 . new ( 1 , 1 , 1 ), [ OnEvent \"Activated\" ] = function () -- don't send clicks if the button is disabled if not peek ( props . Disabled ) then props . OnClick () end end } end This is the primary way components talk to their controlling code in Fusion.","title":"Callbacks"},{"location":"tutorials/components/callbacks/#in-luau","text":"Callbacks are functions which you pass into other functions. They're part of normal Luau code. workspace . ChildAdded : Connect ( function () -- this function is a callback! end ) They're useful because they allow the function to 'call back' into your code, so your code can do something in response: local function printMessage () print ( \"Hello, world!\" ) end -- Here, we're passing `printMessage` as a callback -- `task.delay` will call it after 5 seconds task . delay ( 5 , printMessage ) If your function accepts a callback, then you can call it like any other function. Luau will execute the function, then return to your code. In this example, the fiveTimes function calls a callback five times: Script code Output local function fiveTimes ( callback ) for x = 1 , 5 do callback ( x ) end end fiveTimes ( function ( num ) print ( \"The number is\" , num ) end ) The number is 1 The number is 2 The number is 3 The number is 4 The number is 5","title":"In Luau"},{"location":"tutorials/components/callbacks/#in-fusion","text":"Components can use callbacks the same way. Consider this button component; when the button is clicked, the button needs to run some external code: local function Button ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 0.25 , 0.5 , 1 ), Position = props . Position , Size = props . Size , Text = props . Text , TextColor3 = Color3 . new ( 1 , 1 , 1 ), [ OnEvent \"Activated\" ] = -- ??? } end It can ask the controlling code to provide a callback in props , called OnClick: local button = Button { Text = \"Hello, world!\" , OnClick = function () print ( \"The button was clicked\" ) end } Assuming that callback is passed in, the callback can be passed directly into [OnEvent] , because [OnEvent] accepts functions: local function Button ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 0.25 , 0.5 , 1 ), Position = props . Position , Size = props . Size , Text = props . Text , TextColor3 = Color3 . new ( 1 , 1 , 1 ), [ OnEvent \"Activated\" ] = props . OnClick } end Alternatively, we can call props.OnClick manually, which is useful if you want to do your own processing first: local function Button ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 0.25 , 0.5 , 1 ), Position = props . Position , Size = props . Size , Text = props . Text , TextColor3 = Color3 . new ( 1 , 1 , 1 ), [ OnEvent \"Activated\" ] = function () -- don't send clicks if the button is disabled if not peek ( props . Disabled ) then props . OnClick () end end } end This is the primary way components talk to their controlling code in Fusion.","title":"In Fusion"},{"location":"tutorials/components/children/","text":"Using components, you can assemble more complex instance hierarchies by combining simpler, self-contained parts. To do that, you should pay attention to how instances are passed between components. Returning Children \u00b6 Components return a child when you call them. That means anything you return from a component should be supported by [Children] . That means you can return one (and only one): instance array of children or state object containing a child This should be familiar from parenting instances using [Children] . To recap: Allowed You can return one value per component. -- returns *one* instance local function Component () return New \"Frame\" {} end -- returns *one* array local function Component () return { New \"Frame\" {}, New \"Frame\" {}, New \"Frame\" {} } end -- returns *one* state object local function Component () return ForValues ({ 1 , 2 , 3 }, function ( use , number ) return New \"Frame\" {} end ) end Allowed Inside arrays or state objects, you can mix and match different children. -- mix of arrays, instances and state objects local function Component () return { New \"Frame\" {}, { New \"Frame\" {}, ForValues ( ... ) } ForValues ( ... ) } end Not allowed Don't return multiple values straight from your function. Prefer to use an array instead. -- returns *multiple* instances (not surrounded by curly braces!) local function Component () return New \"Frame\" {}, New \"Frame\" {}, New \"Frame\" {} end Luau does not support multiple return values consistently. They can get lost easily if you're not careful. Parenting Components \u00b6 Components return the same values which [Children] uses. That means they're directly compatible, and you can insert a component anywhere you'd normally insert an instance. You can pass in one component on its own... local ui = New \"ScreenGui\" { [ Children ] = Button { Text = \"Hello, world!\" } } ...you can include components as part of an array.. local ui = New \"ScreenGui\" { [ Children ] = { New \"UIListLayout\" {}, Button { Text = \"Hello, world!\" }, Button { Text = \"Hello, again!\" } } } ...and you can return them from state objects, too. local ui = New \"ScreenGui\" { [ Children ] = { New \"UIListLayout\" {}, ForValues ({ \"Hello\" , \"world\" , \"from\" , \"Fusion\" }, function ( use , text ) return Button { Text = text } end ) } } Accepting Children \u00b6 Some components, for example pop-ups, might contain lots of different content: Ideally, you would be able to reuse the pop-up 'container', while placing your own content inside. The simplest way to do this is to pass children through to [Children] . For example, if you accept a table of props , you can add a [Children] key: local function PopUp ( props ) return New \"Frame\" { -- ... some other properties ... -- Since `props` is a table, and `[Children]` is a key, you can use it -- yourself as a key in `props`: [ Children ] = props [ Children ] } end Later on, when a pop-up is created, children can now be parented into that instance: local popUp = PopUp { [ Children ] = { Label { Text = \"New item collected\" }, ItemPreview { Item = Items . BRICK }, Button { Text = \"Add to inventory\" } } } You're not limited to passing it straight into [Children] . If you need to add other children, you can still use arrays and state objects as normal: local function PopUp ( props ) return New \"Frame\" { -- ... some other properties ... [ Children ] = { -- the component provides some children here New \"UICorner\" { CornerRadius = UDim . new ( 0 , 8 ) }, -- include children from outside the component here props [ Children ] } } end","title":"Children"},{"location":"tutorials/components/children/#returning-children","text":"Components return a child when you call them. That means anything you return from a component should be supported by [Children] . That means you can return one (and only one): instance array of children or state object containing a child This should be familiar from parenting instances using [Children] . To recap: Allowed You can return one value per component. -- returns *one* instance local function Component () return New \"Frame\" {} end -- returns *one* array local function Component () return { New \"Frame\" {}, New \"Frame\" {}, New \"Frame\" {} } end -- returns *one* state object local function Component () return ForValues ({ 1 , 2 , 3 }, function ( use , number ) return New \"Frame\" {} end ) end Allowed Inside arrays or state objects, you can mix and match different children. -- mix of arrays, instances and state objects local function Component () return { New \"Frame\" {}, { New \"Frame\" {}, ForValues ( ... ) } ForValues ( ... ) } end Not allowed Don't return multiple values straight from your function. Prefer to use an array instead. -- returns *multiple* instances (not surrounded by curly braces!) local function Component () return New \"Frame\" {}, New \"Frame\" {}, New \"Frame\" {} end Luau does not support multiple return values consistently. They can get lost easily if you're not careful.","title":"Returning Children"},{"location":"tutorials/components/children/#parenting-components","text":"Components return the same values which [Children] uses. That means they're directly compatible, and you can insert a component anywhere you'd normally insert an instance. You can pass in one component on its own... local ui = New \"ScreenGui\" { [ Children ] = Button { Text = \"Hello, world!\" } } ...you can include components as part of an array.. local ui = New \"ScreenGui\" { [ Children ] = { New \"UIListLayout\" {}, Button { Text = \"Hello, world!\" }, Button { Text = \"Hello, again!\" } } } ...and you can return them from state objects, too. local ui = New \"ScreenGui\" { [ Children ] = { New \"UIListLayout\" {}, ForValues ({ \"Hello\" , \"world\" , \"from\" , \"Fusion\" }, function ( use , text ) return Button { Text = text } end ) } }","title":"Parenting Components"},{"location":"tutorials/components/children/#accepting-children","text":"Some components, for example pop-ups, might contain lots of different content: Ideally, you would be able to reuse the pop-up 'container', while placing your own content inside. The simplest way to do this is to pass children through to [Children] . For example, if you accept a table of props , you can add a [Children] key: local function PopUp ( props ) return New \"Frame\" { -- ... some other properties ... -- Since `props` is a table, and `[Children]` is a key, you can use it -- yourself as a key in `props`: [ Children ] = props [ Children ] } end Later on, when a pop-up is created, children can now be parented into that instance: local popUp = PopUp { [ Children ] = { Label { Text = \"New item collected\" }, ItemPreview { Item = Items . BRICK }, Button { Text = \"Add to inventory\" } } } You're not limited to passing it straight into [Children] . If you need to add other children, you can still use arrays and state objects as normal: local function PopUp ( props ) return New \"Frame\" { -- ... some other properties ... [ Children ] = { -- the component provides some children here New \"UICorner\" { CornerRadius = UDim . new ( 0 , 8 ) }, -- include children from outside the component here props [ Children ] } } end","title":"Accepting Children"},{"location":"tutorials/components/reusing-ui/","text":"Up until this point, you have been creating and parenting instances directly without much organisation or code reuse. However, those two factors will become increasingly important as you start building more game-ready UIs. These next few pages won't introduce new features of Fusion, but instead will focus on techniques for making your UI more modular, portable and easy to maintain. Components \u00b6 One of the greatest advantages of libraries like Fusion is that UI and code are the same thing. Any tool you can use on one, you can use on the other. To reduce repetition in your codebases, you'll often use functions to run small reusable blocks of code, sometimes with parameters you can change. You can use functions to organise your UI code, too. For example, consider this function, which generates a button based on some props the user passes in: local function Button ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 0 , 0.25 , 1 ), Position = props . Position , AnchorPoint = props . AnchorPoint , Size = props . Size , LayoutOrder = props . LayoutOrder , Text = props . ButtonText , TextSize = 28 , TextColor3 = Color3 . new ( 1 , 1 , 1 ), [ Children ] = UICorner { CornerRadius = UDim2 . new ( 0 , 8 ) } } end You can call this function later to generate as many buttons as you need: -- this is just a regular Lua function call! local helloBtn = Button { ButtonText = \"Hello\" , Size = UDim2 . fromOffset ( 200 , 50 ) } helloBtn . Parent = Players . LocalPlayer . PlayerGui . ScreenGui This is the primary way UI is reused in Fusion. These kinds of functions are common enough that they have a special name: components . Specifically, components are functions which return a child. In the above example, Button is a component, because it's a function that returns a TextButton. Modules \u00b6 It's common to save different components inside of different ModuleScripts. There's a number of advantages to this: it's easier to find the source code for a specific component it keep each script shorter and simpler it makes sure components are properly independent, and can't interfere it encourages reusing components everywhere, not just in one script Here's an example of how you could split up some components into modules: Main script PopUp.lua Message.lua Button.lua 1 2 3 4 5 6 7 8 9 10 local PopUp = require ( script . Parent . PopUp ) local ui = New \"ScreenGui\" { -- ...some properties... [ Children ] = PopUp { Message = \"Hello, world!\" , DismissText = \"Close\" } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 local Message = require ( script . Parent . Message ) local Button = require ( script . Parent . Button ) local function PopUp ( props ) return New \"Frame\" { -- ...some properties... [ Children ] = { Message { Text = props . Message } Button { Text = props . DismissText } } } end return PopUp 1 2 3 4 5 6 7 8 9 10 11 12 local function Message ( props ) return New \"TextLabel\" { AutomaticSize = \"XY\" , BackgroundTransparency = 1 , -- ...some properties... Text = props . Text } end return Message 1 2 3 4 5 6 7 8 9 10 11 12 local function Button ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 0.25 , 0.5 , 1 ), AutoButtonColor = true , -- ...some properties... Text = props . Text } end return Button You can further group your modules using folders if you need more organisation. It might be scary at first to see a large list of modules, but because you can browse visually by names and folders, it's almost always better than having one long script.","title":"Reusing UI"},{"location":"tutorials/components/reusing-ui/#components","text":"One of the greatest advantages of libraries like Fusion is that UI and code are the same thing. Any tool you can use on one, you can use on the other. To reduce repetition in your codebases, you'll often use functions to run small reusable blocks of code, sometimes with parameters you can change. You can use functions to organise your UI code, too. For example, consider this function, which generates a button based on some props the user passes in: local function Button ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 0 , 0.25 , 1 ), Position = props . Position , AnchorPoint = props . AnchorPoint , Size = props . Size , LayoutOrder = props . LayoutOrder , Text = props . ButtonText , TextSize = 28 , TextColor3 = Color3 . new ( 1 , 1 , 1 ), [ Children ] = UICorner { CornerRadius = UDim2 . new ( 0 , 8 ) } } end You can call this function later to generate as many buttons as you need: -- this is just a regular Lua function call! local helloBtn = Button { ButtonText = \"Hello\" , Size = UDim2 . fromOffset ( 200 , 50 ) } helloBtn . Parent = Players . LocalPlayer . PlayerGui . ScreenGui This is the primary way UI is reused in Fusion. These kinds of functions are common enough that they have a special name: components . Specifically, components are functions which return a child. In the above example, Button is a component, because it's a function that returns a TextButton.","title":"Components"},{"location":"tutorials/components/reusing-ui/#modules","text":"It's common to save different components inside of different ModuleScripts. There's a number of advantages to this: it's easier to find the source code for a specific component it keep each script shorter and simpler it makes sure components are properly independent, and can't interfere it encourages reusing components everywhere, not just in one script Here's an example of how you could split up some components into modules: Main script PopUp.lua Message.lua Button.lua 1 2 3 4 5 6 7 8 9 10 local PopUp = require ( script . Parent . PopUp ) local ui = New \"ScreenGui\" { -- ...some properties... [ Children ] = PopUp { Message = \"Hello, world!\" , DismissText = \"Close\" } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 local Message = require ( script . Parent . Message ) local Button = require ( script . Parent . Button ) local function PopUp ( props ) return New \"Frame\" { -- ...some properties... [ Children ] = { Message { Text = props . Message } Button { Text = props . DismissText } } } end return PopUp 1 2 3 4 5 6 7 8 9 10 11 12 local function Message ( props ) return New \"TextLabel\" { AutomaticSize = \"XY\" , BackgroundTransparency = 1 , -- ...some properties... Text = props . Text } end return Message 1 2 3 4 5 6 7 8 9 10 11 12 local function Button ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 0.25 , 0.5 , 1 ), AutoButtonColor = true , -- ...some properties... Text = props . Text } end return Button You can further group your modules using folders if you need more organisation. It might be scary at first to see a large list of modules, but because you can browse visually by names and folders, it's almost always better than having one long script.","title":"Modules"},{"location":"tutorials/components/state/","text":"Components can hold their own data privately using state objects. This can be useful, but you should be careful when adding state. Creating State Objects \u00b6 Inside a component, state objects can be created and used the same way as usual: local HOVER_COLOUR = Color3 . new ( 0.5 , 0.75 , 1 ) local REST_COLOUR = Color3 . new ( 0.25 , 0.5 , 1 ) local function Button ( props ) local isHovering = Value ( false ) return New \"TextButton\" { BackgroundColor3 = Computed ( function ( use ) return if use ( isHovering ) then HOVER_COLOUR else REST_COLOUR end ), [ OnEvent \"MouseEnter\" ] = function () isHovering : set ( true ) end , [ OnEvent \"MouseLeave\" ] = function () isHovering : set ( false ) end , -- ... some properties ... } end Like regular Luau, state objects stay around as long as they're being used. Once your component is destroyed and your code no longer uses the objects, they'll be cleaned up. Top-Down Control \u00b6 Remember that Fusion mainly works with a top-down flow of control. It's a good idea to keep that in mind when adding state to components. When you're making reusable components, it's more flexible if your component can be controlled externally. Components that control themselves entirely are hard to use and customise. Consider the example of a check box. Each check box often reflects a state object under the hood: It might seem logical to store the state object inside the check box: local function CheckBox ( props ) local isChecked = Value ( false ) return New \"ImageButton\" { -- ... some properties ... } end However, hiding away important state in components causes a few problems: to control the appearance of the check box, you're forced to change the internal state clicking the check box has hard-coded behaviour, which is bad if you need to intercept the click (e.g. to show a confirmation dialogue) if you already had a state object for that setting, now the check box has a duplicate state object representing the same setting Therefore, it's better for the controlling code to hold the state object, and use callbacks to switch the value when the check box is clicked: local playMusic = Value ( true ) local checkBox = CheckBox { Text = \"Play music\" , IsChecked = playMusic , OnClick = function () playMusic : set ( not peek ( playMusic )) end } The control is always top-down here; the check box's appearance is fully controlled by the creator. The creator of the check box decides to switch the setting when the check box is clicked. The check box itself is an inert, visual element; it just shows a graphic and reports clicks. Setting up the check box this way also allows for more complex behaviour later on. Suppose we wanted to group together multiple options under a 'main' check box, so you can turn them all on/off at once. The appearance of that check box would not be controlled by a single state, but instead reflects the combination of multiple states. We can use a Computed for that: local playMusic = Value ( true ) local playSFX = Value ( false ) local playNarration = Value ( true ) local checkBox = CheckBox { Text = \"Play sounds\" , Appearance = Computed ( function ( use ) local anyChecked = use ( playMusic ) or use ( playSFX ) or use ( playNarration ) local allChecked = use ( playMusic ) and use ( playSFX ) and use ( playNarration ) if not anyChecked then return \"unchecked\" elseif not allChecked then return \"partially-checked\" else return \"checked\" end end ) } We can then implement the 'check all'/'uncheck all' behaviour inside OnClick : local playMusic = Value ( true ) local playSFX = Value ( false ) local playNarration = Value ( true ) local checkBox = CheckBox { -- ... same properties as before ... OnClick = function () local allChecked = peek ( playMusic ) and peek ( playSFX ) and peek ( playNarration ) playMusic : set ( not allChecked ) playSFX : set ( not allChecked ) playNarration : set ( not allChecked ) end } By keeping the check box 'stateless', we can make it behave much more flexibly. Best Practices \u00b6 Those examples lead us into the golden rule when adding state to components. Golden Rule It's better for reusable components to reflect program state. They should not usually contain program state. State objects are best suited to self-contained use cases, such as implementing hover effects, animations or responsive design. As such, you should think about whether you really need to add state to components, or whether it's better to add it higher up. At first, this might be difficult to do well, but with experience you'll have a better intuition for it. Remember that you can always rewrite your code if it becomes a problem!","title":"State"},{"location":"tutorials/components/state/#creating-state-objects","text":"Inside a component, state objects can be created and used the same way as usual: local HOVER_COLOUR = Color3 . new ( 0.5 , 0.75 , 1 ) local REST_COLOUR = Color3 . new ( 0.25 , 0.5 , 1 ) local function Button ( props ) local isHovering = Value ( false ) return New \"TextButton\" { BackgroundColor3 = Computed ( function ( use ) return if use ( isHovering ) then HOVER_COLOUR else REST_COLOUR end ), [ OnEvent \"MouseEnter\" ] = function () isHovering : set ( true ) end , [ OnEvent \"MouseLeave\" ] = function () isHovering : set ( false ) end , -- ... some properties ... } end Like regular Luau, state objects stay around as long as they're being used. Once your component is destroyed and your code no longer uses the objects, they'll be cleaned up.","title":"Creating State Objects"},{"location":"tutorials/components/state/#top-down-control","text":"Remember that Fusion mainly works with a top-down flow of control. It's a good idea to keep that in mind when adding state to components. When you're making reusable components, it's more flexible if your component can be controlled externally. Components that control themselves entirely are hard to use and customise. Consider the example of a check box. Each check box often reflects a state object under the hood: It might seem logical to store the state object inside the check box: local function CheckBox ( props ) local isChecked = Value ( false ) return New \"ImageButton\" { -- ... some properties ... } end However, hiding away important state in components causes a few problems: to control the appearance of the check box, you're forced to change the internal state clicking the check box has hard-coded behaviour, which is bad if you need to intercept the click (e.g. to show a confirmation dialogue) if you already had a state object for that setting, now the check box has a duplicate state object representing the same setting Therefore, it's better for the controlling code to hold the state object, and use callbacks to switch the value when the check box is clicked: local playMusic = Value ( true ) local checkBox = CheckBox { Text = \"Play music\" , IsChecked = playMusic , OnClick = function () playMusic : set ( not peek ( playMusic )) end } The control is always top-down here; the check box's appearance is fully controlled by the creator. The creator of the check box decides to switch the setting when the check box is clicked. The check box itself is an inert, visual element; it just shows a graphic and reports clicks. Setting up the check box this way also allows for more complex behaviour later on. Suppose we wanted to group together multiple options under a 'main' check box, so you can turn them all on/off at once. The appearance of that check box would not be controlled by a single state, but instead reflects the combination of multiple states. We can use a Computed for that: local playMusic = Value ( true ) local playSFX = Value ( false ) local playNarration = Value ( true ) local checkBox = CheckBox { Text = \"Play sounds\" , Appearance = Computed ( function ( use ) local anyChecked = use ( playMusic ) or use ( playSFX ) or use ( playNarration ) local allChecked = use ( playMusic ) and use ( playSFX ) and use ( playNarration ) if not anyChecked then return \"unchecked\" elseif not allChecked then return \"partially-checked\" else return \"checked\" end end ) } We can then implement the 'check all'/'uncheck all' behaviour inside OnClick : local playMusic = Value ( true ) local playSFX = Value ( false ) local playNarration = Value ( true ) local checkBox = CheckBox { -- ... same properties as before ... OnClick = function () local allChecked = peek ( playMusic ) and peek ( playSFX ) and peek ( playNarration ) playMusic : set ( not allChecked ) playSFX : set ( not allChecked ) playNarration : set ( not allChecked ) end } By keeping the check box 'stateless', we can make it behave much more flexibly.","title":"Top-Down Control"},{"location":"tutorials/components/state/#best-practices","text":"Those examples lead us into the golden rule when adding state to components. Golden Rule It's better for reusable components to reflect program state. They should not usually contain program state. State objects are best suited to self-contained use cases, such as implementing hover effects, animations or responsive design. As such, you should think about whether you really need to add state to components, or whether it's better to add it higher up. At first, this might be difficult to do well, but with experience you'll have a better intuition for it. Remember that you can always rewrite your code if it becomes a problem!","title":"Best Practices"},{"location":"tutorials/fundamentals/computeds/","text":"Computeds are state objects that can process values from other state objects. You pass in a callback to define a calculation. Then, you can use peek() to read the result of the calculation at any time. local numCoins = Value ( 50 ) local itemPrice = Value ( 10 ) local finalCoins = Computed ( function ( use ) return use ( numCoins ) - use ( itemPrice ) end ) print ( peek ( finalCoins )) --> 40 numCoins : set ( 25 ) itemPrice : set ( 15 ) print ( peek ( finalCoins )) --> 10 Usage \u00b6 To use Computed in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Computed = Fusion . Computed To create a new computed object, call the Computed function. You need to give it a callback representing the calculation - for now, we'll add two numbers: local hardMaths = Computed ( function ( use ) return 1 + 1 end ) The value the callback returns will be stored as the computed's value. You can get the computed's current value using peek() : print ( peek ( hardMaths )) --> 2 The calculation is only run once by default. If you try and use peek() inside the calculation, your code won't work: local number = Value ( 2 ) local double = Computed ( function ( use ) return peek ( number ) * 2 end ) -- The calculation runs once by default. print ( peek ( number ), peek ( double )) --> 2 4 -- The calculation won't re-run! Oh no! number : set ( 10 ) print ( peek ( number ), peek ( double )) --> 10 4 This is where the use parameter comes in (see line 2 above). If you want your calculation to re-run when your objects change value, pass the object to use() : local number = Value ( 2 ) local double = Computed ( function ( use ) use ( number ) -- the calculation will re-run when `number` changes value return peek ( number ) * 2 end ) print ( peek ( number ), peek ( double )) --> 2 4 -- Now it re-runs! number : set ( 10 ) print ( peek ( number ), peek ( double )) --> 10 20 For convenience, use() will also read the value, just like peek() , so you can easily replace peek() calls with use() calls: local number = Value ( 2 ) local double = Computed ( function ( use ) return use ( number ) * 2 -- works identically to before end ) When To Use This \u00b6 Computeds are more specialist than regular values and observers. They're designed for a single purpose: they make it easier and more efficient to derive new values from existing state objects. Derived values show up in a lot of places throughout UIs. For example, you might want to insert a death counter into a string. Therefore, the contents of the string are derived from the death counter: While you can do this with values and observers alone, your code could get messy. Consider the following code that doesn't use computeds - the intent is to create a derived value, finalCoins , which equals numCoins - itemPrice at all times: 1 2 3 4 5 6 7 8 9 local numCoins = Value ( 50 ) local itemPrice = Value ( 10 ) local finalCoins = Value ( peek ( numCoins ) - peek ( itemPrice )) local function updateFinalCoins () finalCoins : set ( peek ( numCoins ) - peek ( itemPrice )) end Observer ( numCoins ): onChange ( updateFinalCoins ) Observer ( itemPrice ): onChange ( updateFinalCoins ) There are a few problems with this code currently: It's not immediately clear what's happening at a glance; there's lots of boilerplate code obscuring what the intent of the code is. The logic for calculating finalCoins is duplicated twice - on lines 4 and 6. You have to manage updating the value yourself using observers. This is an easy place for desynchronisation bugs to slip in. Another part of the code base could call finalCoins:set() and mess with the value. When written with computeds, the above problems are largely solved: 1 2 3 4 5 6 local numCoins = Value ( 50 ) local itemPrice = Value ( 10 ) local finalCoins = Computed ( function ( use ) return use ( numCoins ) - use ( itemPrice ) end ) The intent is immediately clear - this is a derived value. The logic is only specified once, in one callback. The computed updates itself when a state object you use() changes value. The callback is the only thing that can change the value - there is no :set() method. A warning about delays in computed callbacks One small caveat of computeds is that you must return the value immediately. If you need to send a request to the server or perform a long-running calculation, you shouldn't use computeds. The reason for this is consistency between variables. When all computeds run immediately (i.e. without yielding), all of your variables will behave consistently: local numCoins = Value ( 50 ) local isEnoughCoins = Computed ( function ( use ) return use ( numCoins ) > 25 end ) local message = Computed ( function ( use ) if use ( isEnoughCoins ) then return use ( numCoins ) .. \" is enough coins.\" else return use ( numCoins ) .. \" is NOT enough coins.\" end end ) print ( peek ( message )) --> 50 is enough coins. numCoins : set ( 2 ) print ( peek ( message )) --> 2 is NOT enough coins. If a delay is introduced, then inconsistencies and nonsense values could quickly appear: local numCoins = Value ( 50 ) local isEnoughCoins = Computed ( function ( use ) task . wait ( 5 ) -- Don't do this! This is just for the example return use ( numCoins ) > 25 end ) local message = Computed ( function ( use ) if use ( isEnoughCoins ) then return use ( numCoins ) .. \" is enough coins.\" else return use ( numCoins ) .. \" is NOT enough coins.\" end end ) print ( peek ( message )) --> 50 is enough coins. numCoins : set ( 2 ) print ( peek ( message )) --> 2 is enough coins. For this reason, yielding in computed callbacks is disallowed. If you have to introduce a delay, for example when invoking a RemoteFunction, consider using values and observers. local numCoins = Value ( 50 ) local isEnoughCoins = Value ( nil ) local function updateIsEnoughCoins () isEnoughCoins : set ( nil ) -- indicate that we're calculating the value task . wait ( 5 ) -- this is now ok isEnoughCoins : set ( peek ( numCoins ) > 25 ) end task . spawn ( updateIsEnoughCoins ) Observer ( numCoins ): onChange ( updateIsEnoughCoins ) local message = Computed ( function () if peek ( isEnoughCoins ) == nil then return \"Loading...\" elseif peek ( isEnoughCoins ) then return peek ( numCoins ) .. \" is enough coins.\" else return peek ( numCoins ) .. \" is NOT enough coins.\" end end ) print ( peek ( message )) --> 50 is enough coins. numCoins : set ( 2 ) print ( peek ( message )) --> Loading... task . wait ( 5 ) print ( peek ( message )) --> 2 is NOT enough coins.","title":"Computeds"},{"location":"tutorials/fundamentals/computeds/#usage","text":"To use Computed in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Computed = Fusion . Computed To create a new computed object, call the Computed function. You need to give it a callback representing the calculation - for now, we'll add two numbers: local hardMaths = Computed ( function ( use ) return 1 + 1 end ) The value the callback returns will be stored as the computed's value. You can get the computed's current value using peek() : print ( peek ( hardMaths )) --> 2 The calculation is only run once by default. If you try and use peek() inside the calculation, your code won't work: local number = Value ( 2 ) local double = Computed ( function ( use ) return peek ( number ) * 2 end ) -- The calculation runs once by default. print ( peek ( number ), peek ( double )) --> 2 4 -- The calculation won't re-run! Oh no! number : set ( 10 ) print ( peek ( number ), peek ( double )) --> 10 4 This is where the use parameter comes in (see line 2 above). If you want your calculation to re-run when your objects change value, pass the object to use() : local number = Value ( 2 ) local double = Computed ( function ( use ) use ( number ) -- the calculation will re-run when `number` changes value return peek ( number ) * 2 end ) print ( peek ( number ), peek ( double )) --> 2 4 -- Now it re-runs! number : set ( 10 ) print ( peek ( number ), peek ( double )) --> 10 20 For convenience, use() will also read the value, just like peek() , so you can easily replace peek() calls with use() calls: local number = Value ( 2 ) local double = Computed ( function ( use ) return use ( number ) * 2 -- works identically to before end )","title":"Usage"},{"location":"tutorials/fundamentals/computeds/#when-to-use-this","text":"Computeds are more specialist than regular values and observers. They're designed for a single purpose: they make it easier and more efficient to derive new values from existing state objects. Derived values show up in a lot of places throughout UIs. For example, you might want to insert a death counter into a string. Therefore, the contents of the string are derived from the death counter: While you can do this with values and observers alone, your code could get messy. Consider the following code that doesn't use computeds - the intent is to create a derived value, finalCoins , which equals numCoins - itemPrice at all times: 1 2 3 4 5 6 7 8 9 local numCoins = Value ( 50 ) local itemPrice = Value ( 10 ) local finalCoins = Value ( peek ( numCoins ) - peek ( itemPrice )) local function updateFinalCoins () finalCoins : set ( peek ( numCoins ) - peek ( itemPrice )) end Observer ( numCoins ): onChange ( updateFinalCoins ) Observer ( itemPrice ): onChange ( updateFinalCoins ) There are a few problems with this code currently: It's not immediately clear what's happening at a glance; there's lots of boilerplate code obscuring what the intent of the code is. The logic for calculating finalCoins is duplicated twice - on lines 4 and 6. You have to manage updating the value yourself using observers. This is an easy place for desynchronisation bugs to slip in. Another part of the code base could call finalCoins:set() and mess with the value. When written with computeds, the above problems are largely solved: 1 2 3 4 5 6 local numCoins = Value ( 50 ) local itemPrice = Value ( 10 ) local finalCoins = Computed ( function ( use ) return use ( numCoins ) - use ( itemPrice ) end ) The intent is immediately clear - this is a derived value. The logic is only specified once, in one callback. The computed updates itself when a state object you use() changes value. The callback is the only thing that can change the value - there is no :set() method. A warning about delays in computed callbacks One small caveat of computeds is that you must return the value immediately. If you need to send a request to the server or perform a long-running calculation, you shouldn't use computeds. The reason for this is consistency between variables. When all computeds run immediately (i.e. without yielding), all of your variables will behave consistently: local numCoins = Value ( 50 ) local isEnoughCoins = Computed ( function ( use ) return use ( numCoins ) > 25 end ) local message = Computed ( function ( use ) if use ( isEnoughCoins ) then return use ( numCoins ) .. \" is enough coins.\" else return use ( numCoins ) .. \" is NOT enough coins.\" end end ) print ( peek ( message )) --> 50 is enough coins. numCoins : set ( 2 ) print ( peek ( message )) --> 2 is NOT enough coins. If a delay is introduced, then inconsistencies and nonsense values could quickly appear: local numCoins = Value ( 50 ) local isEnoughCoins = Computed ( function ( use ) task . wait ( 5 ) -- Don't do this! This is just for the example return use ( numCoins ) > 25 end ) local message = Computed ( function ( use ) if use ( isEnoughCoins ) then return use ( numCoins ) .. \" is enough coins.\" else return use ( numCoins ) .. \" is NOT enough coins.\" end end ) print ( peek ( message )) --> 50 is enough coins. numCoins : set ( 2 ) print ( peek ( message )) --> 2 is enough coins. For this reason, yielding in computed callbacks is disallowed. If you have to introduce a delay, for example when invoking a RemoteFunction, consider using values and observers. local numCoins = Value ( 50 ) local isEnoughCoins = Value ( nil ) local function updateIsEnoughCoins () isEnoughCoins : set ( nil ) -- indicate that we're calculating the value task . wait ( 5 ) -- this is now ok isEnoughCoins : set ( peek ( numCoins ) > 25 ) end task . spawn ( updateIsEnoughCoins ) Observer ( numCoins ): onChange ( updateIsEnoughCoins ) local message = Computed ( function () if peek ( isEnoughCoins ) == nil then return \"Loading...\" elseif peek ( isEnoughCoins ) then return peek ( numCoins ) .. \" is enough coins.\" else return peek ( numCoins ) .. \" is NOT enough coins.\" end end ) print ( peek ( message )) --> 50 is enough coins. numCoins : set ( 2 ) print ( peek ( message )) --> Loading... task . wait ( 5 ) print ( peek ( message )) --> 2 is NOT enough coins.","title":"When To Use This"},{"location":"tutorials/fundamentals/destructors/","text":"Destructors are functions that clean up values passed to them. Computed objects use them to clean up old values when they're no longer needed. local function callDestroy ( x ) x : Destroy () end local brick = Computed ( function ( use ) return Instance . new ( \"Part\" ) end , callDestroy ) Memory Management \u00b6 In Luau, most values clean themselves up automatically, because they're managed by the garbage collector: -- This will create a new table in memory: local x = { hello = \"world\" } task . wait ( 5 ) -- The table is destroyed automatically when you stop using it. x = nil However, not all values clean themselves up. Some common 'unmanaged' types are: Instances - need to be :Destroy() ed Event connections - need to be :Disconnect() ed Custom objects - might provide their own :Destroy() methods. The garbage collector doesn't manage these for you, so if you don't clean them up, they could stick around forever: -- We're creating an event connection here. local event = workspace . Changed : Connect ( function () print ( \"Hello!\" ) end ) -- Even if we stop using the event connection in our code, it will continue to -- receive events. It will not be disconnected for you. event = nil State Objects \u00b6 Those types of values are a problem for Computed objects. For example, if they generate fresh instances, they need to destroy those instances too: local className = Value ( \"Frame\" ) -- `instance` will generate a Frame at first local instance = Computed ( function ( use ) return Instance . new ( use ( className )) end ) -- This will cause it to generate a TextLabel - but we didn't destroy the Frame! className : set ( \"TextLabel\" ) This is where destructors help out. You can provide a second function, which Fusion will call to destroy the values we generate: local function callDestroy ( x ) x : Destroy () end local instance = Computed ( function ( use ) return Instance . new ( use ( className )) end , callDestroy ) Destructors aren't limited to typical cleanup behaviour! You can customise what happens during cleanup, or do no cleanup at all: local function moveToServerStorage ( x ) x . Parent = game : GetService ( \"ServerStorage\" ) end local function doNothing ( x ) -- intentionally left blank end Shorthand \u00b6 Most of the time, you'll want to either: destroy/disconnect/clean up the values you generate... ...or leave them alone and do nothing. Fusion provides default destructors for both of these situations. Cleanup \u00b6 Fusion.cleanup is a function which tries to cleans up whatever you pass to it: given an instance, it is :Destroy() ed given an event connection, it is :Disconnect() ed given an object, any :destroy() or :Destroy() methods are run given a function, the function is run given an array, it cleans up everything inside You can use this when generating unmanaged values: local instance = Computed ( function ( use ) return Instance . new ( use ( className )) end , Fusion . cleanup ) Do Nothing \u00b6 Fusion.doNothing is an empty function. It does nothing. You can use this when passing 'through' unmanaged values that you don't control. It makes it clear that your code is supposed to leave the values alone: local instance = Computed ( function ( use ) return workspace : FindFirstChild ( use ( className )) end , Fusion . doNothing )","title":"Destructors"},{"location":"tutorials/fundamentals/destructors/#memory-management","text":"In Luau, most values clean themselves up automatically, because they're managed by the garbage collector: -- This will create a new table in memory: local x = { hello = \"world\" } task . wait ( 5 ) -- The table is destroyed automatically when you stop using it. x = nil However, not all values clean themselves up. Some common 'unmanaged' types are: Instances - need to be :Destroy() ed Event connections - need to be :Disconnect() ed Custom objects - might provide their own :Destroy() methods. The garbage collector doesn't manage these for you, so if you don't clean them up, they could stick around forever: -- We're creating an event connection here. local event = workspace . Changed : Connect ( function () print ( \"Hello!\" ) end ) -- Even if we stop using the event connection in our code, it will continue to -- receive events. It will not be disconnected for you. event = nil","title":"Memory Management"},{"location":"tutorials/fundamentals/destructors/#state-objects","text":"Those types of values are a problem for Computed objects. For example, if they generate fresh instances, they need to destroy those instances too: local className = Value ( \"Frame\" ) -- `instance` will generate a Frame at first local instance = Computed ( function ( use ) return Instance . new ( use ( className )) end ) -- This will cause it to generate a TextLabel - but we didn't destroy the Frame! className : set ( \"TextLabel\" ) This is where destructors help out. You can provide a second function, which Fusion will call to destroy the values we generate: local function callDestroy ( x ) x : Destroy () end local instance = Computed ( function ( use ) return Instance . new ( use ( className )) end , callDestroy ) Destructors aren't limited to typical cleanup behaviour! You can customise what happens during cleanup, or do no cleanup at all: local function moveToServerStorage ( x ) x . Parent = game : GetService ( \"ServerStorage\" ) end local function doNothing ( x ) -- intentionally left blank end","title":"State Objects"},{"location":"tutorials/fundamentals/destructors/#shorthand","text":"Most of the time, you'll want to either: destroy/disconnect/clean up the values you generate... ...or leave them alone and do nothing. Fusion provides default destructors for both of these situations.","title":"Shorthand"},{"location":"tutorials/fundamentals/destructors/#cleanup","text":"Fusion.cleanup is a function which tries to cleans up whatever you pass to it: given an instance, it is :Destroy() ed given an event connection, it is :Disconnect() ed given an object, any :destroy() or :Destroy() methods are run given a function, the function is run given an array, it cleans up everything inside You can use this when generating unmanaged values: local instance = Computed ( function ( use ) return Instance . new ( use ( className )) end , Fusion . cleanup )","title":"Cleanup"},{"location":"tutorials/fundamentals/destructors/#do-nothing","text":"Fusion.doNothing is an empty function. It does nothing. You can use this when passing 'through' unmanaged values that you don't control. It makes it clear that your code is supposed to leave the values alone: local instance = Computed ( function ( use ) return workspace : FindFirstChild ( use ( className )) end , Fusion . doNothing )","title":"Do Nothing"},{"location":"tutorials/fundamentals/observers/","text":"Observers allow you to detect when any state object changes value. You can connect handlers using :onChange() , which returns a function you can call to disconnect it later. local observer = Observer ( health ) local disconnect = observer : onChange ( function () print ( \"The new value is: \" , peek ( health )) end ) task . wait ( 5 ) disconnect () Usage \u00b6 To use Observer in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Observer = Fusion . Observer To create a new observer, call the Observer function with an object to watch: local health = Value ( 100 ) -- This observer will watch `health` for changes: local observer = Observer ( health ) When the watched object changes value, the observer will run all of its handlers. To add a handler, you can use :onChange() : local disconnect = observer : onChange ( function () print ( \"The new value is: \" , peek ( health )) end ) When you're done with the handler, it's very important to disconnect it. The :onChange() method returns a function you can call to disconnect your handler: local disconnect = observer : onChange ( function () print ( \"The new value is: \" , peek ( health )) end ) -- disconnect the above handler after 5 seconds task . wait ( 5 ) disconnect () Why is disconnecting so important? While an observer has at least one active handler, it will hold the watched object in memory forcibly. This is done to make sure that changes aren't missed. Disconnecting your handlers tells Fusion you don't need to track changes any more, which allows it to clean up the observer and the watched object. What Counts As A Change? \u00b6 You might notice that not all calls to Value:set() will cause your observer to run: Script code Output local thing = Value ( \"Hello\" ) Observer ( thing ): onChange ( function () print ( \"=> Thing changed to\" , peek ( thing )) end ) print ( \"Setting thing once...\" ) thing : set ( \"World\" ) print ( \"Setting thing twice...\" ) thing : set ( \"World\" ) print ( \"Setting thing thrice...\" ) thing : set ( \"World\" ) Setting thing once... => Thing changed to World Setting thing twice... Setting thing thrice... When you set the value, if it's the same as the existing value, an update won't be sent out. This means observers won't re-run when you set the value multiple times in a row. In most cases, this leads to improved performance because your code runs less often. However, if you need to override this behaviour, Value:set() accepts a second argument - if you set it to true , an update will be forced: Script code Output local thing = Value ( \"Hello\" ) Observer ( thing ): onChange ( function () print ( \"=> Thing changed to\" , peek ( thing )) end ) print ( \"Setting thing once...\" ) thing : set ( \"World\" ) print ( \"Setting thing twice...\" ) thing : set ( \"World\" ) print ( \"Setting thing thrice (update forced)...\" ) thing : set ( \"World\" , true ) Setting thing once... => Thing changed to World Setting thing twice... Setting thing thrice (update forced)... => Thing changed to World","title":"Observers"},{"location":"tutorials/fundamentals/observers/#usage","text":"To use Observer in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Observer = Fusion . Observer To create a new observer, call the Observer function with an object to watch: local health = Value ( 100 ) -- This observer will watch `health` for changes: local observer = Observer ( health ) When the watched object changes value, the observer will run all of its handlers. To add a handler, you can use :onChange() : local disconnect = observer : onChange ( function () print ( \"The new value is: \" , peek ( health )) end ) When you're done with the handler, it's very important to disconnect it. The :onChange() method returns a function you can call to disconnect your handler: local disconnect = observer : onChange ( function () print ( \"The new value is: \" , peek ( health )) end ) -- disconnect the above handler after 5 seconds task . wait ( 5 ) disconnect () Why is disconnecting so important? While an observer has at least one active handler, it will hold the watched object in memory forcibly. This is done to make sure that changes aren't missed. Disconnecting your handlers tells Fusion you don't need to track changes any more, which allows it to clean up the observer and the watched object.","title":"Usage"},{"location":"tutorials/fundamentals/observers/#what-counts-as-a-change","text":"You might notice that not all calls to Value:set() will cause your observer to run: Script code Output local thing = Value ( \"Hello\" ) Observer ( thing ): onChange ( function () print ( \"=> Thing changed to\" , peek ( thing )) end ) print ( \"Setting thing once...\" ) thing : set ( \"World\" ) print ( \"Setting thing twice...\" ) thing : set ( \"World\" ) print ( \"Setting thing thrice...\" ) thing : set ( \"World\" ) Setting thing once... => Thing changed to World Setting thing twice... Setting thing thrice... When you set the value, if it's the same as the existing value, an update won't be sent out. This means observers won't re-run when you set the value multiple times in a row. In most cases, this leads to improved performance because your code runs less often. However, if you need to override this behaviour, Value:set() accepts a second argument - if you set it to true , an update will be forced: Script code Output local thing = Value ( \"Hello\" ) Observer ( thing ): onChange ( function () print ( \"=> Thing changed to\" , peek ( thing )) end ) print ( \"Setting thing once...\" ) thing : set ( \"World\" ) print ( \"Setting thing twice...\" ) thing : set ( \"World\" ) print ( \"Setting thing thrice (update forced)...\" ) thing : set ( \"World\" , true ) Setting thing once... => Thing changed to World Setting thing twice... Setting thing thrice (update forced)... => Thing changed to World","title":"What Counts As A Change?"},{"location":"tutorials/fundamentals/values/","text":"Values are objects which store single values. You can write to them with their :set() method, and read from them with the peek() function. local health = Value ( 100 ) print ( peek ( health )) --> 100 health : set ( 25 ) print ( peek ( health )) --> 25 Usage \u00b6 To use Value in your code, you first need to import it from the Fusion module, so that you can refer to it by name. You should also import peek for later: 1 2 3 local Fusion = require ( ReplicatedStorage . Fusion ) local Value = Fusion . Value local peek = Fusion . peek To create a new value, call the Value function: local health = Value () -- this will create and return a new Value object By default, new Value objects store nil . If you want the Value object to start with a different value, you can provide one: local health = Value ( 100 ) -- the Value will initially store a value of 100 Fusion provides a global peek() function which returns the value of whatever you give it. For example, it will read the value of our health object: print ( peek ( health )) --> 100 We can change the value using the :set() method on the object itself: health : set ( 25 ) print ( peek ( health )) --> 25 Why Objects? \u00b6 The Problem \u00b6 Imagine some UI in your head. Think about what it looks like, and think about the different variables it's showing to you. Screenshot: GameUIDatabase (Halo Infinite) Your UIs are usually driven by a few internal variables. When those variables change, you want your UI to reflect those changes. Unfortunately, there's no way to listen for those changes in Lua. When you change those variables, it's normally your responsibility to figure out what needs to update, and to send out those updates. Over time, we've come up with many methods of dealing with this inconvenience. Perhaps the simplest are 'setter functions', like these: local ammo = 100 local function setAmmo ( newAmmo ) ammo = newAmmo -- you need to send out updates to every piece of code using `ammo` here updateHUD () updateGunModel () sendAmmoToServer () end But this is clunky and unreliable; what if there's another piece of code using ammo that we've forgotten to update here? How can you guarantee we've covered everything? Moreover, why is the code setting the ammo even concerned with who uses it? Building Better Variables \u00b6 In an ideal world, anyone using ammo should be able to listen for changes, and get notified when someone sets it to a new value. To make this work, we need to fundamentally extend what variables can do. In particular, we need two additional features: We need to save a list of dependents - other places currently using our variable. This is so we know who to notify when the value changes. We need to run some code when the variable is set to a new value. If we can do that, then we can go through the list and notify everyone. To solve this, Fusion introduces the idea of a 'state object'. These are objects that represent a single value, which you can peek() at any time. They also keep a list of dependents; when the object's value changes, it can notify everyone so they can respond to the change. Value is one such state object. It's specifically designed to act like a variable, so it has an extra :set() method. Using that method, you can change the object's value manually. If you set it to a different value than before, it'll notify anyone using the object. This means you can use Value objects like variables, with the added benefit of being able to listen to changes like we wanted! Sharing Variables \u00b6 There is another benefit to using objects too; you can easily share your objects directly with other code. Every usage of that object will refer to the same underlying value: -- someObject is a `Value` object local function printValue ( someObject ) print ( peek ( someObject )) end local health = Value ( 100 ) printValue ( health ) --> 100 local myDogsName = Value ( \"Dan\" ) printValue ( myDogsName ) --> Dan This is something that normal variables can't do by default, and is a benefit exclusive to state objects. In the above code, printValue can operate on any arbitrary variable without knowing what it is, or where it comes from. This is very useful for writing generic, reusable code, and you'll see it used a lot throughout Fusion.","title":"Values"},{"location":"tutorials/fundamentals/values/#usage","text":"To use Value in your code, you first need to import it from the Fusion module, so that you can refer to it by name. You should also import peek for later: 1 2 3 local Fusion = require ( ReplicatedStorage . Fusion ) local Value = Fusion . Value local peek = Fusion . peek To create a new value, call the Value function: local health = Value () -- this will create and return a new Value object By default, new Value objects store nil . If you want the Value object to start with a different value, you can provide one: local health = Value ( 100 ) -- the Value will initially store a value of 100 Fusion provides a global peek() function which returns the value of whatever you give it. For example, it will read the value of our health object: print ( peek ( health )) --> 100 We can change the value using the :set() method on the object itself: health : set ( 25 ) print ( peek ( health )) --> 25","title":"Usage"},{"location":"tutorials/fundamentals/values/#why-objects","text":"","title":"Why Objects?"},{"location":"tutorials/fundamentals/values/#the-problem","text":"Imagine some UI in your head. Think about what it looks like, and think about the different variables it's showing to you. Screenshot: GameUIDatabase (Halo Infinite) Your UIs are usually driven by a few internal variables. When those variables change, you want your UI to reflect those changes. Unfortunately, there's no way to listen for those changes in Lua. When you change those variables, it's normally your responsibility to figure out what needs to update, and to send out those updates. Over time, we've come up with many methods of dealing with this inconvenience. Perhaps the simplest are 'setter functions', like these: local ammo = 100 local function setAmmo ( newAmmo ) ammo = newAmmo -- you need to send out updates to every piece of code using `ammo` here updateHUD () updateGunModel () sendAmmoToServer () end But this is clunky and unreliable; what if there's another piece of code using ammo that we've forgotten to update here? How can you guarantee we've covered everything? Moreover, why is the code setting the ammo even concerned with who uses it?","title":"The Problem"},{"location":"tutorials/fundamentals/values/#building-better-variables","text":"In an ideal world, anyone using ammo should be able to listen for changes, and get notified when someone sets it to a new value. To make this work, we need to fundamentally extend what variables can do. In particular, we need two additional features: We need to save a list of dependents - other places currently using our variable. This is so we know who to notify when the value changes. We need to run some code when the variable is set to a new value. If we can do that, then we can go through the list and notify everyone. To solve this, Fusion introduces the idea of a 'state object'. These are objects that represent a single value, which you can peek() at any time. They also keep a list of dependents; when the object's value changes, it can notify everyone so they can respond to the change. Value is one such state object. It's specifically designed to act like a variable, so it has an extra :set() method. Using that method, you can change the object's value manually. If you set it to a different value than before, it'll notify anyone using the object. This means you can use Value objects like variables, with the added benefit of being able to listen to changes like we wanted!","title":"Building Better Variables"},{"location":"tutorials/fundamentals/values/#sharing-variables","text":"There is another benefit to using objects too; you can easily share your objects directly with other code. Every usage of that object will refer to the same underlying value: -- someObject is a `Value` object local function printValue ( someObject ) print ( peek ( someObject )) end local health = Value ( 100 ) printValue ( health ) --> 100 local myDogsName = Value ( \"Dan\" ) printValue ( myDogsName ) --> Dan This is something that normal variables can't do by default, and is a benefit exclusive to state objects. In the above code, printValue can operate on any arbitrary variable without knowing what it is, or where it comes from. This is very useful for writing generic, reusable code, and you'll see it used a lot throughout Fusion.","title":"Sharing Variables"},{"location":"tutorials/instances/change-events/","text":"OnChange is a function that returns keys to use when hydrating or creating an instance. Those keys let you connect functions to property changed events on the instance. local input = New \"TextBox\" { [ OnChange \"Text\" ] = function ( newText ) print ( \"You typed:\" , newText ) end } Usage \u00b6 To use OnChange in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local OnChange = Fusion . OnChange When you call OnChange with a property name, it will return a special key: local key = OnEvent ( \"Activated\" ) When used in a property table, you can pass in a handler and it will be run when that property changes. The new value of the property is passed in: local input = New \"TextBox\" { [ OnChange ( \"Text\" )] = function ( newText ) print ( \"You typed:\" , newText ) end } If you're using quotes '' \"\" for the event name, the extra parentheses () are optional: local input = New \"TextBox\" { [ OnChange \"Text\" ] = function ( newText ) print ( \"You typed:\" , newText ) end } A warning about using OnChange with state objects When passing a state object as a property, changes will only affect the property on the next frame: local text = Value ( \"Hello\" ) local message = New \"Message\" { Text = text } print ( message . Text ) --> Hello text : set ( \"World\" ) print ( message . Text ) --> Hello task . wait () -- wait for next frame print ( message . Text ) --> World This means OnChange for that property will run your handlers one frame after the state object is changed. This could introduce off-by-one-frame errors. For this case, prefer to use an observer on the state object directly for zero latency. Differences from Roblox API \u00b6 Normally in the Roblox API, when using :GetPropertyChangedSignal() on an instance, the handler callback will not receive any arguments. It's worth noting that OnChange is not identical in that respect. To make working with change events easier, OnChange will pass the new value of the property to the handler callback.","title":"Change Events"},{"location":"tutorials/instances/change-events/#usage","text":"To use OnChange in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local OnChange = Fusion . OnChange When you call OnChange with a property name, it will return a special key: local key = OnEvent ( \"Activated\" ) When used in a property table, you can pass in a handler and it will be run when that property changes. The new value of the property is passed in: local input = New \"TextBox\" { [ OnChange ( \"Text\" )] = function ( newText ) print ( \"You typed:\" , newText ) end } If you're using quotes '' \"\" for the event name, the extra parentheses () are optional: local input = New \"TextBox\" { [ OnChange \"Text\" ] = function ( newText ) print ( \"You typed:\" , newText ) end } A warning about using OnChange with state objects When passing a state object as a property, changes will only affect the property on the next frame: local text = Value ( \"Hello\" ) local message = New \"Message\" { Text = text } print ( message . Text ) --> Hello text : set ( \"World\" ) print ( message . Text ) --> Hello task . wait () -- wait for next frame print ( message . Text ) --> World This means OnChange for that property will run your handlers one frame after the state object is changed. This could introduce off-by-one-frame errors. For this case, prefer to use an observer on the state object directly for zero latency.","title":"Usage"},{"location":"tutorials/instances/change-events/#differences-from-roblox-api","text":"Normally in the Roblox API, when using :GetPropertyChangedSignal() on an instance, the handler callback will not receive any arguments. It's worth noting that OnChange is not identical in that respect. To make working with change events easier, OnChange will pass the new value of the property to the handler callback.","title":"Differences from Roblox API"},{"location":"tutorials/instances/cleanup/","text":"The [Cleanup] key allows you to add cleanup code to an instance you're hydrating or creating. You can also pass in instances or event connections to destroy. local connection = RunService . Heartbeat : Connect ( function () print ( \"Blah blah...\" ) end ) local part = New \"Part\" { [ Cleanup ] = connection } local box = New \"SelectionBox\" { Parent = PlayerGui } local part = New \"Part\" { [ Cleanup ] = box } local part = New \"Part\" { [ Cleanup ] = { function () print ( \"Oh no, I got destroyed. Ouch :(\" ) end , connection , box } } Usage \u00b6 To use Cleanup in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Cleanup = Fusion . Cleanup When using New or Hydrate , you can use [Cleanup] as a key in the property table. Any function you pass in will be run when the instance is destroyed: local folder = New \"Folder\" { [ Cleanup ] = function () print ( \"This folder was destroyed\" ) end } Arrays are supported - their contents will be cleaned up in order: local folder = New \"Folder\" { [ Cleanup ] = { function () print ( \"This will run first\" ) end , function () print ( \"This will run next\" ) end , function () print ( \"This will run last\" ) end } } You may also nest arrays up to any depth - sub-arrays are also run in order: local folder = New \"Folder\" { [ Cleanup ] = { function () print ( \"This will run first\" ) end , { function () print ( \"This will run next\" ) end , function () print ( \"This will run second-to-last\" ) end , }, function () print ( \"This will run last\" ) end } } For convenience, Cleanup allows you to pass some types of value in directly. Passing in an instance will destroy it: local box = New \"SelectionBox\" { Parent = PlayerGui } local part = New \"Part\" { -- `box` will be destroyed when the part is destroyed [ Cleanup ] = box } Passing in an event connection will disconnect it: local connection = RunService . Heartbeat : Connect ( function () print ( \"Blah blah...\" ) end ) local part = New \"Part\" { -- `connection` will be disconnected when the part is destroyed [ Cleanup ] = connection } Finally, passing in anything with a :destroy() or :Destroy() method will have that method called: -- you might receive an object like this from a third party library local object = {} function object : destroy () print ( \"I was destroyed!\" ) end local part = New \"Part\" { -- `object:destroy()` will be called when the part is destroyed [ Cleanup ] = object } Any other kind of value will do nothing by default. Don't Use Destroyed \u00b6 While Roblox does provide it's own Destroyed event, it should not be relied upon for cleaning up correctly in all cases. It only fires when the Destroy method is called, meaning other kinds of destruction are ignored. For example, notice only one of these parts runs their cleanup code: Script code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 local part1 = New \"Part\" { [ OnEvent \"Destroyed\" ] = function () print ( \"=> Part 1 cleaned up\" ) end } local part2 = New \"Part\" { [ OnEvent \"Destroyed\" ] = function () print ( \"=> Part 2 cleaned up\" ) end } print ( \"Destroying part 1...\" ) part1 : Destroy () print ( \"Setting part 2 to nil...\" ) part2 = nil Destroying part 1... => Part 1 cleaned up Setting part 2 to nil... Meanwhile, Fusion's [Cleanup] will work regardless of how your instances were destroyed, meaning you can avoid serious memory leaks: Script code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 local part1 = New \"Part\" { [ Cleanup ] = function () print ( \"=> Part 1 cleaned up\" ) end } local part2 = New \"Part\" { [ Cleanup ] = function () print ( \"=> Part 2 cleaned up\" ) end } print ( \"Destroying part 1...\" ) part1 : Destroy () print ( \"Setting part 2 to nil...\" ) part2 = nil Destroying part 1... => Part 1 cleaned up Setting part 2 to nil... => Part 2 cleaned up","title":"Cleanup"},{"location":"tutorials/instances/cleanup/#usage","text":"To use Cleanup in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Cleanup = Fusion . Cleanup When using New or Hydrate , you can use [Cleanup] as a key in the property table. Any function you pass in will be run when the instance is destroyed: local folder = New \"Folder\" { [ Cleanup ] = function () print ( \"This folder was destroyed\" ) end } Arrays are supported - their contents will be cleaned up in order: local folder = New \"Folder\" { [ Cleanup ] = { function () print ( \"This will run first\" ) end , function () print ( \"This will run next\" ) end , function () print ( \"This will run last\" ) end } } You may also nest arrays up to any depth - sub-arrays are also run in order: local folder = New \"Folder\" { [ Cleanup ] = { function () print ( \"This will run first\" ) end , { function () print ( \"This will run next\" ) end , function () print ( \"This will run second-to-last\" ) end , }, function () print ( \"This will run last\" ) end } } For convenience, Cleanup allows you to pass some types of value in directly. Passing in an instance will destroy it: local box = New \"SelectionBox\" { Parent = PlayerGui } local part = New \"Part\" { -- `box` will be destroyed when the part is destroyed [ Cleanup ] = box } Passing in an event connection will disconnect it: local connection = RunService . Heartbeat : Connect ( function () print ( \"Blah blah...\" ) end ) local part = New \"Part\" { -- `connection` will be disconnected when the part is destroyed [ Cleanup ] = connection } Finally, passing in anything with a :destroy() or :Destroy() method will have that method called: -- you might receive an object like this from a third party library local object = {} function object : destroy () print ( \"I was destroyed!\" ) end local part = New \"Part\" { -- `object:destroy()` will be called when the part is destroyed [ Cleanup ] = object } Any other kind of value will do nothing by default.","title":"Usage"},{"location":"tutorials/instances/cleanup/#dont-use-destroyed","text":"While Roblox does provide it's own Destroyed event, it should not be relied upon for cleaning up correctly in all cases. It only fires when the Destroy method is called, meaning other kinds of destruction are ignored. For example, notice only one of these parts runs their cleanup code: Script code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 local part1 = New \"Part\" { [ OnEvent \"Destroyed\" ] = function () print ( \"=> Part 1 cleaned up\" ) end } local part2 = New \"Part\" { [ OnEvent \"Destroyed\" ] = function () print ( \"=> Part 2 cleaned up\" ) end } print ( \"Destroying part 1...\" ) part1 : Destroy () print ( \"Setting part 2 to nil...\" ) part2 = nil Destroying part 1... => Part 1 cleaned up Setting part 2 to nil... Meanwhile, Fusion's [Cleanup] will work regardless of how your instances were destroyed, meaning you can avoid serious memory leaks: Script code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 local part1 = New \"Part\" { [ Cleanup ] = function () print ( \"=> Part 1 cleaned up\" ) end } local part2 = New \"Part\" { [ Cleanup ] = function () print ( \"=> Part 2 cleaned up\" ) end } print ( \"Destroying part 1...\" ) part1 : Destroy () print ( \"Setting part 2 to nil...\" ) part2 = nil Destroying part 1... => Part 1 cleaned up Setting part 2 to nil... => Part 2 cleaned up","title":"Don't Use Destroyed"},{"location":"tutorials/instances/events/","text":"OnEvent is a function that returns keys to use when hydrating or creating an instance. Those keys let you connect functions to events on the instance. local button = New \"TextButton\" { [ OnEvent \"Activated\" ] = function ( _ , numClicks ) print ( \"The button was pressed\" , numClicks , \"time(s)!\" ) end } Usage \u00b6 To use OnEvent in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local OnEvent = Fusion . OnEvent When you call OnEvent with an event name, it will return a special key: local key = OnEvent ( \"Activated\" ) When that key is used in a property table, you can pass in a handler and it will be connected to the event for you: local button = New \"TextButton\" { [ OnEvent ( \"Activated\" )] = function ( _ , numClicks ) print ( \"The button was pressed\" , numClicks , \"time(s)!\" ) end } If you're using quotes '' \"\" for the event name, the extra parentheses () are optional: local button = New \"TextButton\" { [ OnEvent \"Activated\" ] = function ( _ , numClicks ) print ( \"The button was pressed\" , numClicks , \"time(s)!\" ) end }","title":"Events"},{"location":"tutorials/instances/events/#usage","text":"To use OnEvent in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local OnEvent = Fusion . OnEvent When you call OnEvent with an event name, it will return a special key: local key = OnEvent ( \"Activated\" ) When that key is used in a property table, you can pass in a handler and it will be connected to the event for you: local button = New \"TextButton\" { [ OnEvent ( \"Activated\" )] = function ( _ , numClicks ) print ( \"The button was pressed\" , numClicks , \"time(s)!\" ) end } If you're using quotes '' \"\" for the event name, the extra parentheses () are optional: local button = New \"TextButton\" { [ OnEvent \"Activated\" ] = function ( _ , numClicks ) print ( \"The button was pressed\" , numClicks , \"time(s)!\" ) end }","title":"Usage"},{"location":"tutorials/instances/hydration/","text":"The process of connecting your scripts to a pre-made UI template is known as hydration . This is where logic in your scripts translate into UI effects, for example setting a message inside a TextLabel, moving menus around, or showing and hiding buttons. Screenshot: GameUIDatabase (Halo Infinite) Fusion provides a Hydrate function for hydrating an instance using a table of properties. If you pass in Fusion objects, changes will be applied on the next frame: local showUI = Value ( false ) local ui = Hydrate ( StarterGui . Template : Clone ()) { Name = \"MainGui\" , Enabled = showUI } print ( ui . Name ) --> MainGui print ( ui . Enabled ) --> false showUI : set ( true ) task . wait () -- important: changes are applied on the next frame! print ( ui . Enabled ) --> true Usage \u00b6 To use Hydrate in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Hydrate = Fusion . Hydrate The Hydrate function is called in two parts. First, call the function with the instance you want to hydrate, then pass in the property table: local instance = workspace . Part Hydrate ( instance )({ Color = Color3 . new ( 1 , 0 , 0 ) }) If you're using curly braces {} to pass your properties in, the extra parentheses () are optional: local instance = workspace . Part -- This only works when you're using curly braces {}! Hydrate ( instance ) { Color = Color3 . new ( 1 , 0 , 0 ) } Hydrate returns the instance you give it, so you can use it in declarations: local instance = Hydrate ( workspace . Part ) { Color = Color3 . new ( 1 , 0 , 0 ) } If you pass in constant values for properties, they'll be applied to the instance directly. However, if you pass in a Fusion object (like Value ), then changes will be applied on the next frame: local message = Value ( \"Loading...\" ) Hydrate ( PlayerGui . LoadingText ) { Text = message } print ( PlayerGui . Message . Text ) --> Loading... message : set ( \"All done!\" ) task . wait () -- important: changes are applied on the next frame! print ( PlayerGui . Message . Text ) --> All done!","title":"Hydration"},{"location":"tutorials/instances/hydration/#usage","text":"To use Hydrate in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Hydrate = Fusion . Hydrate The Hydrate function is called in two parts. First, call the function with the instance you want to hydrate, then pass in the property table: local instance = workspace . Part Hydrate ( instance )({ Color = Color3 . new ( 1 , 0 , 0 ) }) If you're using curly braces {} to pass your properties in, the extra parentheses () are optional: local instance = workspace . Part -- This only works when you're using curly braces {}! Hydrate ( instance ) { Color = Color3 . new ( 1 , 0 , 0 ) } Hydrate returns the instance you give it, so you can use it in declarations: local instance = Hydrate ( workspace . Part ) { Color = Color3 . new ( 1 , 0 , 0 ) } If you pass in constant values for properties, they'll be applied to the instance directly. However, if you pass in a Fusion object (like Value ), then changes will be applied on the next frame: local message = Value ( \"Loading...\" ) Hydrate ( PlayerGui . LoadingText ) { Text = message } print ( PlayerGui . Message . Text ) --> Loading... message : set ( \"All done!\" ) task . wait () -- important: changes are applied on the next frame! print ( PlayerGui . Message . Text ) --> All done!","title":"Usage"},{"location":"tutorials/instances/new-instances/","text":"Fusion provides a New function when you're hydrating newly-made instances. It creates a new instance, applies some default properties, then hydrates it with a property table. local message = Value ( \"Hello there!\" ) local ui = New \"TextLabel\" { Name = \"Greeting\" , Parent = PlayerGui . ScreenGui , Text = message } print ( ui . Name ) --> Greeting print ( ui . Text ) --> Hello there! message : set ( \"Goodbye friend!\" ) task . wait () -- important: changes are applied on the next frame! print ( ui . Text ) --> Goodbye friend! Usage \u00b6 To use New in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New The New function is called in two parts. First, call the function with the type of instance, then pass in the property table: local instance = New ( \"Part\" )({ Parent = workspace , Color = Color3 . new ( 1 , 0 , 0 ) }) If you're using curly braces {} for your properties, and quotes '' \"\" for your class type, the extra parentheses () are optional: -- This only works when you're using curly braces {} and quotes '' \"\"! local instance = New \"Part\" { Parent = workspace , Color = Color3 . new ( 1 , 0 , 0 ) } By design, New works just like Hydrate - it will apply properties the same way. See the Hydrate tutorial to learn more. Default Properties \u00b6 When you create an instance using Instance.new() , Roblox will give it some default properties. However, these tend to be outdated and aren't useful for most people, leading to repetitive boilerplate needed to disable features that nobody wants to use. The New function will apply some of it's own default properties to fix this. For example, by default borders on UI are disabled, automatic colouring is turned off and default content is removed. For a complete list, take a look at Fusion's default properties file.","title":"New Instances"},{"location":"tutorials/instances/new-instances/#usage","text":"To use New in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New The New function is called in two parts. First, call the function with the type of instance, then pass in the property table: local instance = New ( \"Part\" )({ Parent = workspace , Color = Color3 . new ( 1 , 0 , 0 ) }) If you're using curly braces {} for your properties, and quotes '' \"\" for your class type, the extra parentheses () are optional: -- This only works when you're using curly braces {} and quotes '' \"\"! local instance = New \"Part\" { Parent = workspace , Color = Color3 . new ( 1 , 0 , 0 ) } By design, New works just like Hydrate - it will apply properties the same way. See the Hydrate tutorial to learn more.","title":"Usage"},{"location":"tutorials/instances/new-instances/#default-properties","text":"When you create an instance using Instance.new() , Roblox will give it some default properties. However, these tend to be outdated and aren't useful for most people, leading to repetitive boilerplate needed to disable features that nobody wants to use. The New function will apply some of it's own default properties to fix this. For example, by default borders on UI are disabled, automatic colouring is turned off and default content is removed. For a complete list, take a look at Fusion's default properties file.","title":"Default Properties"},{"location":"tutorials/instances/outputs/","text":"Out is a function that returns keys to use when hydrating or creating an instance. Those keys let you output a property's value to a Value object. local name = Value () local thing = New \"Part\" { [ Out \"Name\" ] = name } print ( peek ( name )) --> Part thing . Name = \"Jimmy\" print ( peek ( name )) --> Jimmy Usage \u00b6 To use Out in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Out = Fusion . Out When you call Out with a property name, it will return a special key: local key = Out ( \"Activated\" ) When used in a property table, you can pass in a Value object. It will be set to the value of the property, and when the property changes, it will be set to the new value: local name = Value () local thing = New \"Part\" { [ Out ( \"Name\" )] = name } print ( peek ( name )) --> Part thing . Name = \"Jimmy\" print ( peek ( name )) --> Jimmy If you're using quotes '' \"\" for the event name, the extra parentheses () are optional: local thing = New \"Part\" { [ Out \"Name\" ] = name } Two-Way Binding \u00b6 By default, Out only outputs changes to the property. If you set the value to something else, the property remains the same: local name = Value () local thing = New \"Part\" { [ Out \"Name\" ] = name -- When `thing.Name` changes, set `name` } print ( thing . Name , peek ( name )) --> Part Part name : set ( \"NewName\" ) task . wait () print ( thing . Name , peek ( name )) --> Part NewName If you want the value to both change and be changed by the property, you need to explicitly say so: local name = Value () local thing = New \"Part\" { Name = name -- When `name` changes, set `thing.Name` [ Out \"Name\" ] = name -- When `thing.Name` changes, set `name` } print ( thing . Name , peek ( name )) --> Part Part name : set ( \"NewName\" ) task . wait () print ( thing . Name , peek ( name )) --> NewName NewName This is known as two-way binding. Most of the time you won't need it, but it can come in handy when working with some kinds of UI - for example, a text box that users can write into, but which can also be modified by your scripts.","title":"Outputs"},{"location":"tutorials/instances/outputs/#usage","text":"To use Out in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Out = Fusion . Out When you call Out with a property name, it will return a special key: local key = Out ( \"Activated\" ) When used in a property table, you can pass in a Value object. It will be set to the value of the property, and when the property changes, it will be set to the new value: local name = Value () local thing = New \"Part\" { [ Out ( \"Name\" )] = name } print ( peek ( name )) --> Part thing . Name = \"Jimmy\" print ( peek ( name )) --> Jimmy If you're using quotes '' \"\" for the event name, the extra parentheses () are optional: local thing = New \"Part\" { [ Out \"Name\" ] = name }","title":"Usage"},{"location":"tutorials/instances/outputs/#two-way-binding","text":"By default, Out only outputs changes to the property. If you set the value to something else, the property remains the same: local name = Value () local thing = New \"Part\" { [ Out \"Name\" ] = name -- When `thing.Name` changes, set `name` } print ( thing . Name , peek ( name )) --> Part Part name : set ( \"NewName\" ) task . wait () print ( thing . Name , peek ( name )) --> Part NewName If you want the value to both change and be changed by the property, you need to explicitly say so: local name = Value () local thing = New \"Part\" { Name = name -- When `name` changes, set `thing.Name` [ Out \"Name\" ] = name -- When `thing.Name` changes, set `name` } print ( thing . Name , peek ( name )) --> Part Part name : set ( \"NewName\" ) task . wait () print ( thing . Name , peek ( name )) --> NewName NewName This is known as two-way binding. Most of the time you won't need it, but it can come in handy when working with some kinds of UI - for example, a text box that users can write into, but which can also be modified by your scripts.","title":"Two-Way Binding"},{"location":"tutorials/instances/parenting/","text":"The [Children] key allows you to add children when hydrating or creating an instance. It accepts instances, arrays of children and state objects containing children. local folder = New \"Folder\" { [ Children ] = { New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) }, New \"Part\" { Name = \"Sammy\" , Material = \"Glass\" } } } Usage \u00b6 To use Children in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Children = Fusion . Children When using New or Hydrate , you can use [Children] as a key in the property table. Any instance you pass in will be parented: local folder = New \"Folder\" { -- The part will be moved inside of the folder [ Children ] = workspace . Part } Since New and Hydrate both return their instances, you can nest them: -- Makes a Folder, containing a part called Gregory local folder = New \"Folder\" { [ Children ] = New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) } } If you need to parent multiple children, arrays of children are accepted: -- Makes a Folder, containing parts called Gregory and Sammy local folder = New \"Folder\" { [ Children ] = { New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) }, New \"Part\" { Name = \"Sammy\" , Material = \"Glass\" } } } Arrays can be nested to any depth; all children will still be parented: local folder = New \"Folder\" { [ Children ] = { { { { New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) } } } } } } Similarly, state objects containing children (or nil ) are also allowed: local value = Value () local folder = New \"Folder\" { [ Children ] = value } value : set ( New \"Part\" { Name = \"Clyde\" , Transparency = 0.5 } ) You may use any combination of these to parent whichever children you need: local modelChildren = workspace . Model : GetChildren () local includeModel = Value ( true ) local folder = New \"Folder\" { -- array of children [ Children ] = { -- single instance New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) }, -- state object containing children (or nil) Computed ( function ( use ) return if use ( includeModel ) then modelChildren : GetChildren () -- array of children else nil end , Fusion . doNothing ) } }","title":"Parenting"},{"location":"tutorials/instances/parenting/#usage","text":"To use Children in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Children = Fusion . Children When using New or Hydrate , you can use [Children] as a key in the property table. Any instance you pass in will be parented: local folder = New \"Folder\" { -- The part will be moved inside of the folder [ Children ] = workspace . Part } Since New and Hydrate both return their instances, you can nest them: -- Makes a Folder, containing a part called Gregory local folder = New \"Folder\" { [ Children ] = New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) } } If you need to parent multiple children, arrays of children are accepted: -- Makes a Folder, containing parts called Gregory and Sammy local folder = New \"Folder\" { [ Children ] = { New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) }, New \"Part\" { Name = \"Sammy\" , Material = \"Glass\" } } } Arrays can be nested to any depth; all children will still be parented: local folder = New \"Folder\" { [ Children ] = { { { { New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) } } } } } } Similarly, state objects containing children (or nil ) are also allowed: local value = Value () local folder = New \"Folder\" { [ Children ] = value } value : set ( New \"Part\" { Name = \"Clyde\" , Transparency = 0.5 } ) You may use any combination of these to parent whichever children you need: local modelChildren = workspace . Model : GetChildren () local includeModel = Value ( true ) local folder = New \"Folder\" { -- array of children [ Children ] = { -- single instance New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) }, -- state object containing children (or nil) Computed ( function ( use ) return if use ( includeModel ) then modelChildren : GetChildren () -- array of children else nil end , Fusion . doNothing ) } }","title":"Usage"},{"location":"tutorials/instances/references/","text":"The [Ref] key allows you to save a reference to an instance you're hydrating or creating. local myRef = Value () local thing = New \"Part\" { [ Ref ] = myRef } print ( peek ( myRef )) --> Part print ( peek ( myRef ) == thing ) --> true Usage \u00b6 To use Ref in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Ref = Fusion . Ref When using New or Hydrate , you can use [Ref] as a key in the property table. It expects a value object to be passed in, and it will save a reference to the instance in that object: local myRef = Value () New \"Part\" { [ Ref ] = myRef } print ( peek ( myRef )) --> Part When the instance is cleaned up, the value object is set to nil to avoid memory leaks: local myPart = Value () New \"Part\" { [ Ref ] = myPart } print ( peek ( myRef )) --> Part peek ( myRef ): Destroy () print ( peek ( myRef )) --> nil When To Use This \u00b6 You may have noticed that New and Hydrate already return their instances. You might wonder why there's two ways to get the same instance reference: local fromRef = Value () local returned = New \"Part\" { [ Ref ] = fromRef } print ( returned ) --> Part print ( peek ( fromRef )) --> Part print ( returned == peek ( fromRef )) --> true There are two main use cases. Firstly, when you're using [Children] to nest instances inside each other, it's hard to access the instance reference: local folders = New \"Folder\" { [ Children ] = New \"Folder\" { -- the instance reference gets passed straight into [Children] -- so... how do you save this somewhere else? [ Children ] = New \"Part\" {} } } One solution is to extract the New call out to a separate variable. This is the simplest solution, but because the part is separated from the folders, it's harder to see they're related at a glance: -- build the part elsewhere, so it can be saved to a variable local myPart = New \"Part\" {} local folders = New \"Folder\" { [ Children ] = New \"Folder\" { -- use the saved reference [ Children ] = myPart } } Ref allows you to save the reference without moving the New call: -- use a Value instead of a plain variable, so it can be passed to `Ref` local myPart = Value () local folders = New \"Folder\" { [ Children ] = New \"Folder\" { [ Children ] = New \"Part\" { -- save a reference into the value object [ Ref ] = myPart } } } The second use case arises when one instance needs to refer to another. Since Ref saves to a value object, you can pass the object directly into another New or Hydrate call: local myPart = Value () New \"SelectionBox\" { -- the selection box should adorn to the part Adornee = myPart } New \"Part\" { -- saving a reference to `myPart`, which will change the Adornee prop above [ Ref ] = myPart } These aren't the only use cases for Ref , but they're the most common patterns which are worth covering.","title":"References"},{"location":"tutorials/instances/references/#usage","text":"To use Ref in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Ref = Fusion . Ref When using New or Hydrate , you can use [Ref] as a key in the property table. It expects a value object to be passed in, and it will save a reference to the instance in that object: local myRef = Value () New \"Part\" { [ Ref ] = myRef } print ( peek ( myRef )) --> Part When the instance is cleaned up, the value object is set to nil to avoid memory leaks: local myPart = Value () New \"Part\" { [ Ref ] = myPart } print ( peek ( myRef )) --> Part peek ( myRef ): Destroy () print ( peek ( myRef )) --> nil","title":"Usage"},{"location":"tutorials/instances/references/#when-to-use-this","text":"You may have noticed that New and Hydrate already return their instances. You might wonder why there's two ways to get the same instance reference: local fromRef = Value () local returned = New \"Part\" { [ Ref ] = fromRef } print ( returned ) --> Part print ( peek ( fromRef )) --> Part print ( returned == peek ( fromRef )) --> true There are two main use cases. Firstly, when you're using [Children] to nest instances inside each other, it's hard to access the instance reference: local folders = New \"Folder\" { [ Children ] = New \"Folder\" { -- the instance reference gets passed straight into [Children] -- so... how do you save this somewhere else? [ Children ] = New \"Part\" {} } } One solution is to extract the New call out to a separate variable. This is the simplest solution, but because the part is separated from the folders, it's harder to see they're related at a glance: -- build the part elsewhere, so it can be saved to a variable local myPart = New \"Part\" {} local folders = New \"Folder\" { [ Children ] = New \"Folder\" { -- use the saved reference [ Children ] = myPart } } Ref allows you to save the reference without moving the New call: -- use a Value instead of a plain variable, so it can be passed to `Ref` local myPart = Value () local folders = New \"Folder\" { [ Children ] = New \"Folder\" { [ Children ] = New \"Part\" { -- save a reference into the value object [ Ref ] = myPart } } } The second use case arises when one instance needs to refer to another. Since Ref saves to a value object, you can pass the object directly into another New or Hydrate call: local myPart = Value () New \"SelectionBox\" { -- the selection box should adorn to the part Adornee = myPart } New \"Part\" { -- saving a reference to `myPart`, which will change the Adornee prop above [ Ref ] = myPart } These aren't the only use cases for Ref , but they're the most common patterns which are worth covering.","title":"When To Use This"},{"location":"tutorials/lists-and-tables/forkeys/","text":"ForKeys is a state object that creates a new table by processing keys from another table. The input table can be a state object, and the output keys can use state objects. local data = { Red = \"foo\" , Blue = \"bar\" } local prefix = Value ( \"Key_\" ) local renamed = ForKeys ( data , function ( use , key ) return use ( prefix ) .. key end ) print ( peek ( renamed )) --> {Key_Red = \"foo\", Key_Blue = \"bar\"} prefix : set ( \"colour\" ) print ( peek ( renamed )) --> {colourRed = \"foo\", colourBlue = \"bar\"} Usage \u00b6 To use ForKeys in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local ForKeys = Fusion . ForKeys Basic Usage \u00b6 To create a new ForKeys object, call the constructor with an input table and a processor function: local data = { red = \"foo\" , blue = \"bar\" } local renamed = ForKeys ( data , function ( use , key ) return string.upper ( key ) end ) This will generate a new table, where each key is replaced using the processor function. The first argument is use , similar to a computed, and the second argument is one of the keys from the input table. You can read the processed table using peek() : local data = { red = \"foo\" , blue = \"bar\" } local renamed = ForKeys ( data , function ( use , key ) return string.upper ( key ) end ) print ( peek ( renamed )) --> {RED = \"foo\", BLUE = \"bar\"} State Objects \u00b6 The input table can be provided as a state object instead, and the output table will update as the input table is changed: local playerSet = Value ({}) local userIdSet = ForKeys ( playerSet , function ( use , player ) return player . UserId end ) playerSet : set ({ [ Players . Elttob ] = true }) print ( peek ( userIdSet )) --> {[1670764] = true} playerSet : set ({ [ Players . boatbomber ] = true , [ Players . EgoMoose ] = true }) print ( peek ( userIdSet )) --> {[33655127] = true, [2155311] = true} Additionally, you can use() state objects in your calculations, just like a computed: local playerSet = { [ Players . boatbomber ] = true , [ Players . EgoMoose ] = true } local prefix = Value ( \"User_\" ) local userIdSet = ForKeys ( playerSet , function ( use , player ) return use ( prefix ) .. player . UserId end ) print ( peek ( userIdSet )) --> {User_33655127 = true, User_2155311 = true} prefix : set ( \"player\" ) print ( peek ( userIdSet )) --> {player33655127 = true, player2155311 = true} Cleanup Behaviour \u00b6 Similar to computeds, if you want to run your own code when values are removed, you can pass in a second 'destructor' function: local eventSet = Value ({ [ RunService . RenderStepped ] = true , [ RunService . Heartbeat ] = true }) local connectionSet = ForKeys ( eventSet , -- processor function ( use , event ) local eventName = tostring ( event ) local connection = event : Connect ( function (...) print ( eventName , \"fired with arguments:\" , ...) end ) return connection end , -- destructor function ( connection ) print ( \"Disconnecting the event!\" ) connection : Disconnect () -- don't forget we're overriding the default cleanup end ) -- remove Heartbeat from the event set -- this will run the destructor with the Heartbeat connection eventSet : set ({ [ RunService . RenderStepped ] = true }) --> Disconnecting the event! When using a custom destructor, you can send one extra return value to your destructor without including it in the output table: local eventSet = Value ({ [ RunService . RenderStepped ] = true , [ RunService . Heartbeat ] = true }) local connectionSet = ForKeys ( eventSet , -- processor function ( use , event ) local eventName = tostring ( event ) local connection = event : Connect ( function (...) print ( eventName , \"fired with arguments:\" , ...) end ) return connection , eventName end , -- destructor function ( connection , eventName ) print ( \"Disconnecting \" .. eventName .. \"!\" ) connection : Disconnect () end ) eventSet : set ({ [ RunService . RenderStepped ] = true }) --> Disconnecting Signal Heartbeat! Optimisations \u00b6 Optional You don't have to memorise these optimisations to use ForKeys , but it can be helpful if you have a performance problem. Rather than creating a new output table from scratch every time the input table is changed, ForKeys will try and reuse as much as possible to improve performance. For example, let's say we're converting an array to a dictionary: local array = Value ({ \"Fusion\" , \"Knit\" , \"Matter\" }) local dict = ForKeys ( array , function ( use , index ) return \"Value\" .. index end ) print ( peek ( dict )) --> {Value1 = \"Fusion\", Value2 = \"Knit\", Value3 = \"Matter\"} Because ForKeys only operates on the keys, changing the values in the array doesn't affect the keys. Keys are only added or removed as needed: local array = Value ({ \"Fusion\" , \"Knit\" , \"Matter\" }) local dict = ForKeys ( array , function ( use , index ) return \"Value\" .. index end ) print ( peek ( dict )) --> {Value1 = \"Fusion\", Value2 = \"Knit\", Value3 = \"Matter\"} array : set ({ \"Roact\" , \"Rodux\" }) print ( peek ( dict )) --> {Value1 = \"Roact\", Value2 = \"Rodux\"} ForKeys takes advantage of this - when a value changes, it's copied into the output table without recalculating the key. Keys are only calculated when a value is assigned to a new key.","title":"ForKeys"},{"location":"tutorials/lists-and-tables/forkeys/#usage","text":"To use ForKeys in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local ForKeys = Fusion . ForKeys","title":"Usage"},{"location":"tutorials/lists-and-tables/forkeys/#basic-usage","text":"To create a new ForKeys object, call the constructor with an input table and a processor function: local data = { red = \"foo\" , blue = \"bar\" } local renamed = ForKeys ( data , function ( use , key ) return string.upper ( key ) end ) This will generate a new table, where each key is replaced using the processor function. The first argument is use , similar to a computed, and the second argument is one of the keys from the input table. You can read the processed table using peek() : local data = { red = \"foo\" , blue = \"bar\" } local renamed = ForKeys ( data , function ( use , key ) return string.upper ( key ) end ) print ( peek ( renamed )) --> {RED = \"foo\", BLUE = \"bar\"}","title":"Basic Usage"},{"location":"tutorials/lists-and-tables/forkeys/#state-objects","text":"The input table can be provided as a state object instead, and the output table will update as the input table is changed: local playerSet = Value ({}) local userIdSet = ForKeys ( playerSet , function ( use , player ) return player . UserId end ) playerSet : set ({ [ Players . Elttob ] = true }) print ( peek ( userIdSet )) --> {[1670764] = true} playerSet : set ({ [ Players . boatbomber ] = true , [ Players . EgoMoose ] = true }) print ( peek ( userIdSet )) --> {[33655127] = true, [2155311] = true} Additionally, you can use() state objects in your calculations, just like a computed: local playerSet = { [ Players . boatbomber ] = true , [ Players . EgoMoose ] = true } local prefix = Value ( \"User_\" ) local userIdSet = ForKeys ( playerSet , function ( use , player ) return use ( prefix ) .. player . UserId end ) print ( peek ( userIdSet )) --> {User_33655127 = true, User_2155311 = true} prefix : set ( \"player\" ) print ( peek ( userIdSet )) --> {player33655127 = true, player2155311 = true}","title":"State Objects"},{"location":"tutorials/lists-and-tables/forkeys/#cleanup-behaviour","text":"Similar to computeds, if you want to run your own code when values are removed, you can pass in a second 'destructor' function: local eventSet = Value ({ [ RunService . RenderStepped ] = true , [ RunService . Heartbeat ] = true }) local connectionSet = ForKeys ( eventSet , -- processor function ( use , event ) local eventName = tostring ( event ) local connection = event : Connect ( function (...) print ( eventName , \"fired with arguments:\" , ...) end ) return connection end , -- destructor function ( connection ) print ( \"Disconnecting the event!\" ) connection : Disconnect () -- don't forget we're overriding the default cleanup end ) -- remove Heartbeat from the event set -- this will run the destructor with the Heartbeat connection eventSet : set ({ [ RunService . RenderStepped ] = true }) --> Disconnecting the event! When using a custom destructor, you can send one extra return value to your destructor without including it in the output table: local eventSet = Value ({ [ RunService . RenderStepped ] = true , [ RunService . Heartbeat ] = true }) local connectionSet = ForKeys ( eventSet , -- processor function ( use , event ) local eventName = tostring ( event ) local connection = event : Connect ( function (...) print ( eventName , \"fired with arguments:\" , ...) end ) return connection , eventName end , -- destructor function ( connection , eventName ) print ( \"Disconnecting \" .. eventName .. \"!\" ) connection : Disconnect () end ) eventSet : set ({ [ RunService . RenderStepped ] = true }) --> Disconnecting Signal Heartbeat!","title":"Cleanup Behaviour"},{"location":"tutorials/lists-and-tables/forkeys/#optimisations","text":"Optional You don't have to memorise these optimisations to use ForKeys , but it can be helpful if you have a performance problem. Rather than creating a new output table from scratch every time the input table is changed, ForKeys will try and reuse as much as possible to improve performance. For example, let's say we're converting an array to a dictionary: local array = Value ({ \"Fusion\" , \"Knit\" , \"Matter\" }) local dict = ForKeys ( array , function ( use , index ) return \"Value\" .. index end ) print ( peek ( dict )) --> {Value1 = \"Fusion\", Value2 = \"Knit\", Value3 = \"Matter\"} Because ForKeys only operates on the keys, changing the values in the array doesn't affect the keys. Keys are only added or removed as needed: local array = Value ({ \"Fusion\" , \"Knit\" , \"Matter\" }) local dict = ForKeys ( array , function ( use , index ) return \"Value\" .. index end ) print ( peek ( dict )) --> {Value1 = \"Fusion\", Value2 = \"Knit\", Value3 = \"Matter\"} array : set ({ \"Roact\" , \"Rodux\" }) print ( peek ( dict )) --> {Value1 = \"Roact\", Value2 = \"Rodux\"} ForKeys takes advantage of this - when a value changes, it's copied into the output table without recalculating the key. Keys are only calculated when a value is assigned to a new key.","title":"Optimisations"},{"location":"tutorials/lists-and-tables/forpairs/","text":"ForPairs combines the functions of ForValues and ForKeys into one object. It can process pairs of keys and values at the same time. The input table can be a state object, and the output values can use state objects. local itemColours = { shoes = \"red\" , socks = \"blue\" } local owner = Value ( \"Elttob\" ) local manipulated = ForPairs ( itemColours , function ( use , thing , colour ) local newKey = colour local newValue = use ( owner ) .. \"'s \" .. thing return newKey , newValue end ) print ( peek ( manipulated )) --> {red = \"Elttob's shoes\", blue = \"Elttob's socks\"} owner : set ( \"Quenty\" ) print ( peek ( manipulated )) --> {red = \"Quenty's shoes\", blue = \"Quenty's socks\"} Usage \u00b6 To use ForPairs in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local ForPairs = Fusion . ForPairs Basic Usage \u00b6 To create a new ForPairs object, call the constructor with an input table and a processor function: local itemColours = { shoes = \"red\" , socks = \"blue\" } local swapped = ForPairs ( data , function ( use , key , value ) return value , key end ) This will generate a new table, where each key-value pair is replaced using the processor function. The first argument is use , similar to a computed, and the second/third arguments are a key/value pair from the input table. You can read the processed table using peek() : local itemColours = { shoes = \"red\" , socks = \"blue\" } local swapped = ForPairs ( data , function ( use , key , value ) return value , key end ) print ( peek ( swapped )) --> {red = \"shoes\", blue = \"socks\"} State Objects \u00b6 As with ForKeys and ForValues , the input table can be provided as a state object, and the processor function can use() other state objects in its calculations. See the ForValues page for examples. Cleanup Behaviour \u00b6 Similar to ForValues and ForKeys , you may pass in a 'destructor' function to add cleanup behaviour, and send your own metadata to it: local watchedInstances = Value ({ [ workspace . Part1 ] = \"One\" , [ workspace . Part2 ] = \"Two\" , [ workspace . Part3 ] = \"Three\" }) local connectionSet = ForPairs ( eventSet , -- processor function ( use , instance , displayName ) local metadata = { displayName = displayName , numChanges = 0 } local connection = instance . Changed : Connect ( function () print ( \"Instance\" , displayName , \"was changed!\" ) metadata . numChanges += 1 end ) return instance , connection , metadata end , -- destructor function ( instance , connection , metadata ) print ( \"Removing\" , metadata . displayName , \"after\" , metadata . numChanges , \"changes\" ) connection : Disconnect () -- don't forget we're overriding the default cleanup end ) -- remove Part3 from the input table -- this will run the destructor with Part3, its Changed event, and its metadata watchedInstances : set ({ [ workspace . Part1 ] = \"One\" , [ workspace . Part2 ] = \"Two\" }) Optimisations \u00b6 Optional You don't have to memorise these optimisations to use ForPairs , but it can be helpful if you have a performance problem. Rather than creating a new output table from scratch every time the input table is changed, ForPairs will try and reuse as much as possible to improve performance. Since ForPairs has to depend on both keys and values, changing any value in the input table will cause a recalculation for that key-value pair. Inversely, ForPairs won't recalculate any key-value pairs that stay the same. Instead, these will be preserved in the output table. If you don't need the keys or the values, Fusion can offer better optimisations. For example, if you're working with an array of values where position doesn't matter, ForValues can move values between keys. Alternatively, if you're working with a set of objects stored in keys, and don't need the values in the table, ForKeys will ignore the values for optimal performance.","title":"ForPairs"},{"location":"tutorials/lists-and-tables/forpairs/#usage","text":"To use ForPairs in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local ForPairs = Fusion . ForPairs","title":"Usage"},{"location":"tutorials/lists-and-tables/forpairs/#basic-usage","text":"To create a new ForPairs object, call the constructor with an input table and a processor function: local itemColours = { shoes = \"red\" , socks = \"blue\" } local swapped = ForPairs ( data , function ( use , key , value ) return value , key end ) This will generate a new table, where each key-value pair is replaced using the processor function. The first argument is use , similar to a computed, and the second/third arguments are a key/value pair from the input table. You can read the processed table using peek() : local itemColours = { shoes = \"red\" , socks = \"blue\" } local swapped = ForPairs ( data , function ( use , key , value ) return value , key end ) print ( peek ( swapped )) --> {red = \"shoes\", blue = \"socks\"}","title":"Basic Usage"},{"location":"tutorials/lists-and-tables/forpairs/#state-objects","text":"As with ForKeys and ForValues , the input table can be provided as a state object, and the processor function can use() other state objects in its calculations. See the ForValues page for examples.","title":"State Objects"},{"location":"tutorials/lists-and-tables/forpairs/#cleanup-behaviour","text":"Similar to ForValues and ForKeys , you may pass in a 'destructor' function to add cleanup behaviour, and send your own metadata to it: local watchedInstances = Value ({ [ workspace . Part1 ] = \"One\" , [ workspace . Part2 ] = \"Two\" , [ workspace . Part3 ] = \"Three\" }) local connectionSet = ForPairs ( eventSet , -- processor function ( use , instance , displayName ) local metadata = { displayName = displayName , numChanges = 0 } local connection = instance . Changed : Connect ( function () print ( \"Instance\" , displayName , \"was changed!\" ) metadata . numChanges += 1 end ) return instance , connection , metadata end , -- destructor function ( instance , connection , metadata ) print ( \"Removing\" , metadata . displayName , \"after\" , metadata . numChanges , \"changes\" ) connection : Disconnect () -- don't forget we're overriding the default cleanup end ) -- remove Part3 from the input table -- this will run the destructor with Part3, its Changed event, and its metadata watchedInstances : set ({ [ workspace . Part1 ] = \"One\" , [ workspace . Part2 ] = \"Two\" })","title":"Cleanup Behaviour"},{"location":"tutorials/lists-and-tables/forpairs/#optimisations","text":"Optional You don't have to memorise these optimisations to use ForPairs , but it can be helpful if you have a performance problem. Rather than creating a new output table from scratch every time the input table is changed, ForPairs will try and reuse as much as possible to improve performance. Since ForPairs has to depend on both keys and values, changing any value in the input table will cause a recalculation for that key-value pair. Inversely, ForPairs won't recalculate any key-value pairs that stay the same. Instead, these will be preserved in the output table. If you don't need the keys or the values, Fusion can offer better optimisations. For example, if you're working with an array of values where position doesn't matter, ForValues can move values between keys. Alternatively, if you're working with a set of objects stored in keys, and don't need the values in the table, ForKeys will ignore the values for optimal performance.","title":"Optimisations"},{"location":"tutorials/lists-and-tables/forvalues/","text":"ForValues is a state object that creates a new table by processing values from another table. The input table can be a state object, and the output values can use state objects. local numbers = { 1 , 2 , 3 , 4 , 5 } local multiplier = Value ( 2 ) local multiplied = ForValues ( numbers , function ( use , num ) return num * use ( multiplier ) end ) print ( multiplied : get ()) --> {2, 4, 6, 8, 10} multiplier : set ( 10 ) print ( multiplied : get ()) --> {10, 20, 30, 40, 50} Usage \u00b6 To use ForValues in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local ForValues = Fusion . ForValues Basic Usage \u00b6 To create a new ForValues object, call the constructor with an input table and a processor function: local numbers = { 1 , 2 , 3 , 4 , 5 } local doubled = ForValues ( numbers , function ( use , num ) return num * 2 end ) This will generate a new table of values, where each value is passed through the processor function. The first argument is use , similar to a computed, and the second argument is one of the values from the input table. You can read the processed table using peek() : local numbers = { 1 , 2 , 3 , 4 , 5 } local doubled = ForValues ( numbers , function ( use , num ) return num * 2 end ) print ( peek ( doubled )) --> {2, 4, 6, 8, 10} State Objects \u00b6 The input table can be provided as a state object instead, and the output table will update as the input table is changed: local numbers = Value ({}) local doubled = ForValues ( numbers , function ( use , num ) return num * 2 end ) numbers : set ({ 1 , 2 , 3 , 4 , 5 }) print ( peek ( doubled )) --> {2, 4, 6, 8, 10} numbers : set ({ 5 , 15 , 25 }) print ( peek ( doubled )) --> {10, 30, 50} Additionally, you can use() state objects in your calculations, just like a computed: local numbers = { 1 , 2 , 3 , 4 , 5 } local factor = Value ( 2 ) local multiplied = ForValues ( numbers , function ( use , num ) return num * use ( factor ) end ) print ( peek ( multiplied )) --> {2, 4, 6, 8, 10} factor : set ( 10 ) print ( peek ( multiplied )) --> {10, 20, 30, 40, 50} Cleanup Behaviour \u00b6 Similar to computeds, if you want to run your own code when values are removed, you can pass in a second 'destructor' function: local names = Value ({ \"Jodi\" , \"Amber\" , \"Umair\" }) local textLabels = ForValues ( names , -- processor function ( use , name ) return New \"TextLabel\" { Text = name } end , -- destructor function ( textLabel ) print ( \"Destructor got text label:\" , textLabel . Text ) textLabel : Destroy () -- don't forget we're overriding the default cleanup end ) -- remove Jodi from the names list -- this will run the destructor with Jodi's TextLabel names : set ({ \"Amber\" , \"Umair\" }) --> Destructor got text label: Jodi When using a custom destructor, you can send one extra return value to your destructor without including it in the output table: local names = Value ({ \"Jodi\" , \"Amber\" , \"Umair\" }) local textLabels = ForValues ( names , -- processor function ( use , name ) local textLabel = New \"TextLabel\" { Text = name } local uppercased = name : upper () -- `textLabel` will be included in the output table -- `uppercased` is not included, but still passed to the destructor return textLabel , uppercased end , -- destructor function ( textLabel , uppercased ) print ( \"Destructor got uppercased:\" , uppercased ) textLabel : Destroy () end ) names : set ({ \"Amber\" , \"Umair\" }) --> Destructor got uppercased: JODI Optimisations \u00b6 Optional You don't have to memorise these optimisations to use ForValues , but it can be helpful if you have a performance problem. Rather than creating a new output table from scratch every time the input table is changed, ForValues will try and reuse as much as possible to improve performance. For example, let's say we're measuring the lengths of an array of words: local words = Value ({ \"Orange\" , \"Red\" , \"Magenta\" }) local lengths = ForValues ( words , function ( use , word ) return # word end ) print ( peek ( lengths )) --> {6, 3, 7} The word lengths don't depend on the position of the word in the array. This means that rearranging the words in the input array will just rearrange the lengths in the output array: ForValues takes advantage of this - when input values move around, the output values will move around too, instead of being recalculated. Note that values are only reused once. For example, if you added another occurence of 'Orange', your calculation would have to run again for the second 'Orange':","title":"ForValues"},{"location":"tutorials/lists-and-tables/forvalues/#usage","text":"To use ForValues in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local ForValues = Fusion . ForValues","title":"Usage"},{"location":"tutorials/lists-and-tables/forvalues/#basic-usage","text":"To create a new ForValues object, call the constructor with an input table and a processor function: local numbers = { 1 , 2 , 3 , 4 , 5 } local doubled = ForValues ( numbers , function ( use , num ) return num * 2 end ) This will generate a new table of values, where each value is passed through the processor function. The first argument is use , similar to a computed, and the second argument is one of the values from the input table. You can read the processed table using peek() : local numbers = { 1 , 2 , 3 , 4 , 5 } local doubled = ForValues ( numbers , function ( use , num ) return num * 2 end ) print ( peek ( doubled )) --> {2, 4, 6, 8, 10}","title":"Basic Usage"},{"location":"tutorials/lists-and-tables/forvalues/#state-objects","text":"The input table can be provided as a state object instead, and the output table will update as the input table is changed: local numbers = Value ({}) local doubled = ForValues ( numbers , function ( use , num ) return num * 2 end ) numbers : set ({ 1 , 2 , 3 , 4 , 5 }) print ( peek ( doubled )) --> {2, 4, 6, 8, 10} numbers : set ({ 5 , 15 , 25 }) print ( peek ( doubled )) --> {10, 30, 50} Additionally, you can use() state objects in your calculations, just like a computed: local numbers = { 1 , 2 , 3 , 4 , 5 } local factor = Value ( 2 ) local multiplied = ForValues ( numbers , function ( use , num ) return num * use ( factor ) end ) print ( peek ( multiplied )) --> {2, 4, 6, 8, 10} factor : set ( 10 ) print ( peek ( multiplied )) --> {10, 20, 30, 40, 50}","title":"State Objects"},{"location":"tutorials/lists-and-tables/forvalues/#cleanup-behaviour","text":"Similar to computeds, if you want to run your own code when values are removed, you can pass in a second 'destructor' function: local names = Value ({ \"Jodi\" , \"Amber\" , \"Umair\" }) local textLabels = ForValues ( names , -- processor function ( use , name ) return New \"TextLabel\" { Text = name } end , -- destructor function ( textLabel ) print ( \"Destructor got text label:\" , textLabel . Text ) textLabel : Destroy () -- don't forget we're overriding the default cleanup end ) -- remove Jodi from the names list -- this will run the destructor with Jodi's TextLabel names : set ({ \"Amber\" , \"Umair\" }) --> Destructor got text label: Jodi When using a custom destructor, you can send one extra return value to your destructor without including it in the output table: local names = Value ({ \"Jodi\" , \"Amber\" , \"Umair\" }) local textLabels = ForValues ( names , -- processor function ( use , name ) local textLabel = New \"TextLabel\" { Text = name } local uppercased = name : upper () -- `textLabel` will be included in the output table -- `uppercased` is not included, but still passed to the destructor return textLabel , uppercased end , -- destructor function ( textLabel , uppercased ) print ( \"Destructor got uppercased:\" , uppercased ) textLabel : Destroy () end ) names : set ({ \"Amber\" , \"Umair\" }) --> Destructor got uppercased: JODI","title":"Cleanup Behaviour"},{"location":"tutorials/lists-and-tables/forvalues/#optimisations","text":"Optional You don't have to memorise these optimisations to use ForValues , but it can be helpful if you have a performance problem. Rather than creating a new output table from scratch every time the input table is changed, ForValues will try and reuse as much as possible to improve performance. For example, let's say we're measuring the lengths of an array of words: local words = Value ({ \"Orange\" , \"Red\" , \"Magenta\" }) local lengths = ForValues ( words , function ( use , word ) return # word end ) print ( peek ( lengths )) --> {6, 3, 7} The word lengths don't depend on the position of the word in the array. This means that rearranging the words in the input array will just rearrange the lengths in the output array: ForValues takes advantage of this - when input values move around, the output values will move around too, instead of being recalculated. Note that values are only reused once. For example, if you added another occurence of 'Orange', your calculation would have to run again for the second 'Orange':","title":"Optimisations"},{"location":"tutorials/lists-and-tables/the-for-objects/","text":"Often when building UI, you need to deal with lists, arrays and tables. For example: creating an array of TextLabels for a player list generating a settings page from pairs of keys and values in a configuration filling a grid with inventory slots and items Most of these use cases involve processing one table into another: converting an array of player names into an array of TextLabels converting a table of settings into a table of UI controls converting an array of inventory items into an array of slot UIs So, to assist with these use cases, Fusion has a few state objects which are specially designed for working with arrays and tables. These are known as the For objects. The Problem \u00b6 To start, let's try making a player list using the basic state objects from before. Let's define a changeable list of player names and some basic UI: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 local playerNames = Value ({ \"Elttob\" , \"boatbomber\" , \"thisfall\" , \"AxisAngles\" }) local textLabels = {} -- TODO: implement this local ui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , [ Children ] = New \"Frame\" { Name = \"PlayerList\" , Position = UDim2 . fromScale ( 1 , 1 ), AnchorPoint = Vector2 . new ( 1 , 0 ), Size = UDim2 . fromOffset ( 200 , 0 ), AutomaticSize = \"Y\" , [ Children ] = { New \"UIListLayout\" { SortOrder = \"Name\" }, textLabels } } } Now, let's make a Computed which generates that list of text labels for us: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 local playerNames = Value ({ \"Elttob\" , \"boatbomber\" , \"thisfall\" , \"AxisAngles\" }) local textLabels = Computed ( function ( use ) local out = {} for index , playerName in use ( playerNames ) do out [ index ] = New \"TextLabel\" { Name = playerName , Size = UDim2 . new ( 1 , 0 , 0 , 50 ), Text = playerName } end return out end , Fusion . cleanup ) local ui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , This is alright, but there are a few problems: Firstly, there's a fair amount of boilerplate - in order to generate the list of text labels, you have to create a Computed , initialise a new table, write a for-loop to populate the table, then return it. Boilerplate is generally annoying, and especially so for a task as common as dealing with lists and tables. It's less clear to read and more tedious to write. Secondly, whenever playerNames is changed, you reconstruct the entire list, destroying all of your instances and any data associated with them. This is both inefficient and also causes issues with data loss. Ideally, you should only modify the text labels for players that have joined or left, leaving the rest of the text labels alone. To address this shortcoming, the For objects provide a cleaner way to do the same thing, except with less boilerplate and leaving unchanged values alone: 1 2 3 4 5 6 7 8 9 10 11 12 local playerNames = Value ({ \"Elttob\" , \"boatbomber\" , \"thisfall\" , \"AxisAngles\" }) local textLabels = ForValues ( playerNames , function ( use , playerName ) return New \"TextLabel\" { Name = playerName , Size = UDim2 . new ( 1 , 0 , 0 , 50 ), Text = playerName } end , Fusion . cleanup ) local ui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Over the next few pages, we'll take a look at three state objects: ForValues , which lets you process just the values in a table. ForKeys , which lets you process just the keys in a table. ForPairs , which lets you do both at the same time.","title":"The For Objects"},{"location":"tutorials/lists-and-tables/the-for-objects/#the-problem","text":"To start, let's try making a player list using the basic state objects from before. Let's define a changeable list of player names and some basic UI: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 local playerNames = Value ({ \"Elttob\" , \"boatbomber\" , \"thisfall\" , \"AxisAngles\" }) local textLabels = {} -- TODO: implement this local ui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , [ Children ] = New \"Frame\" { Name = \"PlayerList\" , Position = UDim2 . fromScale ( 1 , 1 ), AnchorPoint = Vector2 . new ( 1 , 0 ), Size = UDim2 . fromOffset ( 200 , 0 ), AutomaticSize = \"Y\" , [ Children ] = { New \"UIListLayout\" { SortOrder = \"Name\" }, textLabels } } } Now, let's make a Computed which generates that list of text labels for us: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 local playerNames = Value ({ \"Elttob\" , \"boatbomber\" , \"thisfall\" , \"AxisAngles\" }) local textLabels = Computed ( function ( use ) local out = {} for index , playerName in use ( playerNames ) do out [ index ] = New \"TextLabel\" { Name = playerName , Size = UDim2 . new ( 1 , 0 , 0 , 50 ), Text = playerName } end return out end , Fusion . cleanup ) local ui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , This is alright, but there are a few problems: Firstly, there's a fair amount of boilerplate - in order to generate the list of text labels, you have to create a Computed , initialise a new table, write a for-loop to populate the table, then return it. Boilerplate is generally annoying, and especially so for a task as common as dealing with lists and tables. It's less clear to read and more tedious to write. Secondly, whenever playerNames is changed, you reconstruct the entire list, destroying all of your instances and any data associated with them. This is both inefficient and also causes issues with data loss. Ideally, you should only modify the text labels for players that have joined or left, leaving the rest of the text labels alone. To address this shortcoming, the For objects provide a cleaner way to do the same thing, except with less boilerplate and leaving unchanged values alone: 1 2 3 4 5 6 7 8 9 10 11 12 local playerNames = Value ({ \"Elttob\" , \"boatbomber\" , \"thisfall\" , \"AxisAngles\" }) local textLabels = ForValues ( playerNames , function ( use , playerName ) return New \"TextLabel\" { Name = playerName , Size = UDim2 . new ( 1 , 0 , 0 , 50 ), Text = playerName } end , Fusion . cleanup ) local ui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Over the next few pages, we'll take a look at three state objects: ForValues , which lets you process just the values in a table. ForKeys , which lets you process just the keys in a table. ForPairs , which lets you do both at the same time.","title":"The Problem"}]}