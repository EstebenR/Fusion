{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Scroll down for a quick look at 3 main features."},{"location":"#rediscover-the-joy-of-coding","title":"Rediscover the joy of coding.","text":"<p> Code is more dynamic, complex and intertwined than ever before. Errors cascade out of control, things update in the wrong order, and it's all connected by difficult, unreadable spaghetti. </p> <p> No longer. Fusion introduces modern 'reactive' concepts for managing code, so you can spend more time getting your logic right, and less time implementing buggy boilerplate code connections. </p> <p> Starting from simple roots, concepts neatly combine and build up with very little learning curve. At every stage, you can robustly guarantee what your code will do, and when you come back in six months, your code is easy to pick back up. </p> Getting started guide Download"},{"location":"#representing-change","title":"Representing change","text":"<p>Fusion introduces \u2018state objects\u2019. They aren\u2019t that complex, but allow you to write dynamic code that\u2019s highly readable, behaves predictably and splits into parts easily.</p> <p>State objects are used to represent changeable or dynamic values in your program. You can peek at their value at any time.</p> <pre><code>-- For example, suppose this function returned a state object.\nlocal currentTimeObj = getCurrentTimeStateObject()\n\n-- State objects are objects...\nprint(typeof(currentTimeObj)) --&gt; table\n\n-- ...and you can peek at their value (or \u2018state\u2019) at any time.\nprint(peek(currentTimeObj)) --&gt; 0.0\ntask.wait(5)\nprint(peek(currentTimeObj)) --&gt; 5.0\n</code></pre> <p>You can write out your logic using Fusion's built-in state objects. Here's the two basic ones, Value and Computed:</p> <pre><code>-- Start tracking some new objects.\nlocal scope = Fusion:scoped()\n\n-- This creates a state object that you can set manually.\n-- You can change its value using myName:set().\nlocal myName = scope:Value(\"Daniel\")\n\n-- This creates a state object from a calculation.\n-- It determines its own value automatically.\nlocal myGreeting = scope:Computed(function(use)\n    return \"Hello! My name is \" .. use(myName)\nend)\n\n-- Discard all the objects.\nscope:doCleanup()\n</code></pre> <p>To watch what a state object does, you can use an Observer. For example, you can run some code when an object changes value.</p> <pre><code>-- This observer watches for when the greeting changes.\nlocal myObserver = scope:Observer(myGreeting)\n\n-- Let\u2019s print out the greeting when there\u2019s a new one.\nlocal disconnect = myObserver:onChange(function()\n    print(peek(myGreeting))\nend)\n\n-- This will run the code above!\nmyName:set(\"Danny\")\n</code></pre> <p> </p>"},{"location":"#building-instances","title":"Building instances","text":"<p>Fusion offers comprehensive APIs to build or enrich instances from code, so you can easily integrate with your game scripts.</p> <p>Fusion provides dedicated functions to create instances. They allow you to easily configure your instance in one place.</p> <pre><code>-- This will create a red part in the workspace.\nlocal myPart = scope:New \"Part\" {\n    Parent = workspace,\n    BrickColor = BrickColor.Red()\n}\n</code></pre> <p>They offer powerful features to keep all your instance code close together. For example, you can listen for events or add children.</p> <pre><code>-- This will create a rounded button.\n-- When you click it, it\u2019ll greet you.\nlocal myButton = scope:New \"TextButton\" {\n    Text = \"Click me\",\n\n    [OnEvent \"Activated\"] = function()\n        print(\"Hello! I\u2019m a button.\")\n    end,\n\n    [Children] = scope:New \"UICorner\" {\n        CornerRadius = UDim.new(1, 0)\n    }\n}\n</code></pre> <p>You can also plug state objects in directly. The instance updates as the state object changes value.</p> <pre><code>-- Creating a state object you can control...\nlocal message = scope:Value(\"Hello!\")\n\n-- Now you can plug that state object into the Text property.\nlocal myLabel = scope:New \"TextLabel\" {\n    Text = message\n}\nprint(myLabel.Text) --&gt; Hello!\n\n-- The Text property now responds to changes:\nmessage:set(\"Goodbye!\")\nprint(myLabel.Text) --&gt; Goodbye!\n</code></pre> <p> </p>"},{"location":"#animating-anything","title":"Animating anything","text":"<p>Fusion gives you best-in-class tools to animate anything you can think of, completely out of the box.</p> <p>Fusion lets you use tweens or physically based springs to animate any value you want - not just instance properties.</p> <pre><code>-- This could be anything you want, as long as it's a state object.\nlocal health = scope:Value(100)\n\n-- Easily make it tween between values...\nlocal style = TweenInfo.new(0.5, Enum.EasingStyle.Quad)\nlocal tweenHealth = scope:Tween(health, style)\n\n-- ...or use spring physics for extra responsiveness.\nlocal springHealth = scope:Spring(health, 30, 0.9)\n</code></pre> <p>Tween and Spring are state objects, just like anything else that changes in your program. That means it's easy to process them afterwards.</p> <pre><code>-- You can round the animated health to whole numbers.\nlocal wholeHealth = scope:Computed(function(use)\n    return math.round(use(health))\nend)\n\n-- You can format it as text and put it in some UI, too.\nlocal myText = scope:New \"TextLabel\" {\n    Text = scope:Computed(function(use)\n        return \"Health: \" .. use(wholeHealth)\n    end)\n}\n</code></pre> <p>You can even configure your animations using state objects, too. This makes it easy to swap out animations or disable them when needed.</p> <pre><code>-- Define some tweening styles...\nlocal TWEEN_FAST = TweenInfo.new(0.5, Enum.EasingStyle.Elastic)\nlocal TWEEN_SLOW = TweenInfo.new(2, Enum.EasingStyle.Sine)\n\n-- Choose more dramatic styles at low health...\nlocal style = scope:Computed(function(use)\n    return if use(health) &lt; 20 then TWEEN_FAST else TWEEN_SLOW\nend)\n\n-- Plug it right into your animation!\nlocal tweenHealth = scope:Tween(health, style)\n</code></pre>"},{"location":"#sparked-your-curiosity","title":"Sparked your curiosity?","text":"<p>Those are the core features of Fusion, and they're the foundation of everything - whether it\u2019s complex 3D UI systems, procedural animation, or just a hello world app. It all fits on one page, and that's the magic. You don't have to keep relearning ever-more-complex tools as you scale up from prototype to product.</p> <p>If you'd like to learn in depth, we have a comprehensive beginner's tutorial track, complete with diagrams, examples and code.</p> <p>We would love to welcome you into our warm, vibrant community. Hopefully, we'll see you there :)</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>Welcome to the API Reference! This is where you can find more technical documentation about what the Fusion library provides.</p> <p>For a beginner-friendly experience, try the tutorials.</p>"},{"location":"api-reference/#most-popular","title":"Most Popular","text":""},{"location":"api-reference/#general","title":"General","text":"<p> Errors Contextual Safe </p>"},{"location":"api-reference/#memory","title":"Memory","text":"<p> Scope innerScope doCleanup scoped </p>"},{"location":"api-reference/#graph","title":"Graph","text":"<p> Observer </p>"},{"location":"api-reference/#state","title":"State","text":"<p> UsedAs Computed peek Value </p>"},{"location":"api-reference/#animation","title":"Animation","text":"<p> Spring Tween </p>"},{"location":"api-reference/#roblox","title":"Roblox","text":"<p> Child Children Hydrate New </p>"},{"location":"api-reference/animation/members/spring/","title":"Spring","text":"Animation Members Spring"},{"location":"api-reference/animation/members/spring/#spring-springt","title":"Spring          -&gt; Spring&lt;T&gt;","text":"<pre><code>function Fusion.Spring&lt;T&gt;(\n    scope: Scope&lt;unknown&gt;,\n    goal: UsedAs&lt;T&gt;,\n    speed: UsedAs&lt;number&gt;?,\n    damping: UsedAs&lt;number&gt;?\n) -&gt; Spring&lt;T&gt;\n</code></pre> <p>Constructs and returns a new spring state object.</p> <p>Use scoped() method syntax</p> <p>This function is intended to be accessed as a method on a scope: <pre><code>local spring = scope:Spring(goal, speed, damping)\n</code></pre></p>"},{"location":"api-reference/animation/members/spring/#parameters","title":"Parameters","text":""},{"location":"api-reference/animation/members/spring/#scope-scopes","title":"scope              : Scope&lt;S&gt;","text":"<p>The scope which should be used to store destruction tasks for this object.</p>"},{"location":"api-reference/animation/members/spring/#goal-usedast","title":"goal              : UsedAs&lt;T&gt;","text":"<p>The goal that this object should follow. For best results, the goal should be animatable.</p>"},{"location":"api-reference/animation/members/spring/#speed-usedast","title":"speed              : UsedAs&lt;T&gt;?","text":"<p>Multiplies how fast the motion should occur; doubling the <code>speed</code> exactly halves the time it takes for the motion to complete.</p>"},{"location":"api-reference/animation/members/spring/#damping-usedast","title":"damping              : UsedAs&lt;T&gt;?","text":"<p>The amount of resistance the motion encounters. 0 represents no resistance, 1 is just enough resistance to prevent overshoot (critical damping), and larger values damp out inertia effects and straighten the motion.</p>"},{"location":"api-reference/animation/members/spring/#returns-springt","title":"Returns              -&gt; Spring&lt;T&gt;","text":"<p>A freshly constructed spring state object.</p>"},{"location":"api-reference/animation/members/spring/#learn-more","title":"Learn More","text":"<ul> <li>Springs tutorial</li> </ul>"},{"location":"api-reference/animation/members/tween/","title":"Tween","text":"Animation Members Tween"},{"location":"api-reference/animation/members/tween/#tween-tweent","title":"Tween          -&gt; Tween&lt;T&gt;","text":"<pre><code>function Fusion.Tween&lt;T&gt;(\n    scope: Scope&lt;unknown&gt;,\n    goal: UsedAs&lt;T&gt;,\n    tweenInfo: UsedAs&lt;TweenInfo&gt;?\n) -&gt; Tween&lt;T&gt;\n</code></pre> <p>Constructs and returns a new tween state object.</p> <p>Use scoped() method syntax</p> <p>This function is intended to be accessed as a method on a scope: <pre><code>local tween = scope:Tween(goal, info)\n</code></pre></p>"},{"location":"api-reference/animation/members/tween/#parameters","title":"Parameters","text":""},{"location":"api-reference/animation/members/tween/#scope-scopes","title":"scope              : Scope&lt;S&gt;","text":"<p>The scope which should be used to store destruction tasks for this object.</p>"},{"location":"api-reference/animation/members/tween/#goal-usedast","title":"goal              : UsedAs&lt;T&gt;","text":"<p>The goal that this object should follow. For best results, the goal should be animatable.</p>"},{"location":"api-reference/animation/members/tween/#info-usedastweeninfo","title":"info              : UsedAs&lt;TweenInfo&gt;?","text":"<p>Determines the easing curve that the motion will follow.</p>"},{"location":"api-reference/animation/members/tween/#returns-tweent","title":"Returns              -&gt; Tween&lt;T&gt;","text":"<p>A freshly constructed tween state object.</p>"},{"location":"api-reference/animation/members/tween/#learn-more","title":"Learn More","text":"<ul> <li>Tweens tutorial</li> </ul>"},{"location":"api-reference/animation/types/animatable/","title":"Animatable","text":"Animation Types Animatable"},{"location":"api-reference/animation/types/animatable/#animatable","title":"Animatable","text":"<pre><code>export type Animatable =\n    number |\n    CFrame |\n    Color3 |\n    ColorSequenceKeypoint |\n    DateTime |\n    NumberRange |\n    NumberSequenceKeypoint |\n    PhysicalProperties |\n    Ray |\n    Rect |\n    Region3 |\n    Region3int16 |\n    UDim |\n    UDim2 |\n    Vector2 |\n    Vector2int16 |\n    Vector3 |\n    Vector3int16\n</code></pre> <p>Any data type that Fusion can decompose into a tuple of animatable parameters.</p> <p>Passing other types to animation objects</p> <p>Other types can be passed to <code>Tween</code> and <code>Spring</code> objects, however those types will not animate. Instead, non-<code>Animatable</code> types will immediately arrive at their goal value.</p>"},{"location":"api-reference/animation/types/animatable/#learn-more","title":"Learn More","text":"<ul> <li>Tweens tutorial</li> <li>Springs tutorial</li> </ul>"},{"location":"api-reference/animation/types/spring/","title":"Spring","text":"Animation Types Spring"},{"location":"api-reference/animation/types/spring/#spring","title":"Spring","text":"<pre><code>export type Spring&lt;T&gt; = StateObject&lt;T&gt; &amp; {\n    kind: \"Spring\",\n    setPosition: (self, newPosition: T) -&gt; (),\n    setVelocity: (self, newVelocity: T) -&gt; (),\n    addVelocity: (self, deltaVelocity: T) -&gt; ()\n}\n</code></pre> <p>A specialised state object for following a goal state smoothly over time, using physics to shape the motion.</p> <p>The methods on this type allow for direct control over the position and velocity of the motion. Other than that, this type is of limited utility outside of Fusion itself.</p>"},{"location":"api-reference/animation/types/spring/#members","title":"Members","text":""},{"location":"api-reference/animation/types/spring/#kind-spring","title":"kind              : \"Spring\"","text":"<p>A more specific type string which can be used for runtime type checking. This can be used to tell types of state object apart.</p>"},{"location":"api-reference/animation/types/spring/#methods","title":"Methods","text":""},{"location":"api-reference/animation/types/spring/#setposition-","title":"setPosition              -&gt; ()","text":"<pre><code>function Spring:setPosition(\n    newPosition: T\n): ()\n</code></pre> <p>Immediately snaps the spring to the given position. The position must have the same <code>typeof()</code> as the goal state.</p>"},{"location":"api-reference/animation/types/spring/#setvelocity-","title":"setVelocity              -&gt; ()","text":"<pre><code>function Spring:setVelocity(\n    newVelocity: T\n): ()\n</code></pre> <p>Overwrites the spring's velocity without changing its position. The velocity must have the same <code>typeof()</code> as the goal state.</p>"},{"location":"api-reference/animation/types/spring/#addvelocity-","title":"addVelocity              -&gt; ()","text":"<pre><code>function Spring:addVelocity(\n    deltaVelocity: T\n): ()\n</code></pre> <p>Appends to the spring's velocity without changing its position. The velocity must have the same <code>typeof()</code> as the goal state.</p>"},{"location":"api-reference/animation/types/spring/#learn-more","title":"Learn More","text":"<ul> <li>Springs tutorial</li> </ul>"},{"location":"api-reference/animation/types/tween/","title":"Tween","text":"Animation Types Tween"},{"location":"api-reference/animation/types/tween/#tween","title":"Tween","text":"<pre><code>export type Tween&lt;T&gt; = StateObject&lt;T&gt;  &amp; {\n    kind: \"Tween\"\n}\n</code></pre> <p>A specialised state object for following a goal state smoothly over time, using a <code>TweenInfo</code> to shape the motion.</p> <p>This type isn't generally useful outside of Fusion itself.</p>"},{"location":"api-reference/animation/types/tween/#members","title":"Members","text":""},{"location":"api-reference/animation/types/tween/#kind-tween","title":"kind              : \"Tween\"","text":"<p>A more specific type string which can be used for runtime type checking. This can be used to tell types of state object apart.</p>"},{"location":"api-reference/animation/types/tween/#learn-more","title":"Learn More","text":"<ul> <li>Tweens tutorial</li> </ul>"},{"location":"api-reference/general/errors/","title":"Errors","text":"General Errors"},{"location":"api-reference/general/errors/#errors","title":"Errors","text":"<p>Whenever Fusion outputs any errors or messages to the console, it will have a short error ID at the end. This is used to uniquely identify what kind of error or message you're seeing.</p> <p>Use the search box below to paste in or type an error ID, and it will scroll to the details for you.</p> <p></p>"},{"location":"api-reference/general/errors/#callbackerror","title":"callbackError","text":"<pre><code>Error in callback: attempt to perform arithmetic (add) on number and string\n</code></pre> <p>Thrown by: <code>Computed</code>, <code>ForKeys</code>, <code>ForValues</code>, <code>ForPairs</code>, <code>Contextual</code></p> <p>Fusion ran a function you specified, but the function threw an error that Fusion couldn't handle.</p> <p>The error includes a more specific message which can be used to diagnose the issue.</p>"},{"location":"api-reference/general/errors/#cannotassignproperty","title":"cannotAssignProperty","text":"<pre><code>The class type 'Foo' has no assignable property 'Bar'.\n</code></pre> <p>Thrown by: <code>New</code>, <code>Hydrate</code></p> <p>You tried to set a property on an instance, but the property can't be assigned  to for some reason. This could be because the property doesn't exist, or because it's locked by Roblox to prevent edits.</p> <p>Check your privileges</p> <p>Different scripts may have different privileges - for example, plugins will be allowed more privileges than in-game scripts. Make sure you have the necessary privileges to assign to your properties!</p>"},{"location":"api-reference/general/errors/#cannotconnectchange","title":"cannotConnectChange","text":"<pre><code>The Frame class doesn't have a property called 'Foo'.\n</code></pre> <p>Thrown by: <code>OnChange</code></p> <p>You tried to connect to a property change event, but the property you specify doesn't exist on the instance.</p>"},{"location":"api-reference/general/errors/#cannotconnectevent","title":"cannotConnectEvent","text":"<pre><code>The Frame class doesn't have an event called 'Foo'.\n</code></pre> <p>Thrown by: <code>OnEvent</code></p> <p>You tried to connect to an event on an instance, but the event you specify doesn't exist on the instance.</p>"},{"location":"api-reference/general/errors/#cannotcreateclass","title":"cannotCreateClass","text":"<pre><code>Can't create a new instance of class 'EditableImage'.\n</code></pre> <p>Thrown by: <code>New</code></p> <p>You attempted to create a type of instance that Fusion can't create.</p> <p>Beta features</p> <p>Some instances are only creatable when you have certain Studio betas enabled. Check your Beta Features tab to ensure that beta features aren't causing the issue.</p>"},{"location":"api-reference/general/errors/#cannotdepend","title":"cannotDepend","text":"<pre><code>Observer can't depend on Observer.\n</code></pre> <p>Thrown by: <code>Observer</code></p> <p>You attempted to form a dependency between two graph objects, but either the dependency set or dependent set were frozen.</p> <p>You might be trying to connect them in the wrong order, or the objects might not be designed to have dependents or dependencies.</p>"},{"location":"api-reference/general/errors/#cleanupwasrenamed","title":"cleanupWasRenamed","text":"<pre><code>`Fusion.cleanup` was renamed to `Fusion.doCleanup`. This will be an error in\nfuture versions of Fusion.\n</code></pre> <p>Thrown by: <code>doCleanup</code></p> <p>You attempted to use <code>cleanup()</code> in Fusion 0.3, which replaces it with the <code>doCleanup()</code> method.</p>"},{"location":"api-reference/general/errors/#destroyedtwice","title":"destroyedTwice","text":"<pre><code>`doCleanup()` was given something that it is already cleaning up. Unclear how to\nproceed.\n</code></pre> <p>Thrown by: <code>doCleanup</code></p> <p>You called <code>doCleanup()</code> on a function or object which carried some code. When that code was run, it attempted to call <code>doCleanup()</code> on the same thing you called with.</p> <p>Usually, this would result in an infinite loop, because the same code would try to clean itself up over and over again. Because cleanup tasks are only meant to run once, this is invalid behaviour and so this error is thrown instead.</p> <p>Ensure your code is the rightful owner of scopes that it is trying to clean up. In particular, avoid cleaning up scopes you receive from elsewhere, unless you and the original provider of the scope agree to transfer the responsibility of cleaning up the scope.</p>"},{"location":"api-reference/general/errors/#destructorredundant","title":"destructorRedundant","text":"<pre><code>Computed destructors no longer do anything. If you wish to run code on destroy,\n`table.insert` a function into the `scope` argument. See discussion #292 on\nGitHub for advice.\n</code></pre> <p>Thrown by: <code>Computed</code>, <code>ForKeys</code>, <code>ForValues</code>, <code>ForPairs</code></p> <p>Related discussions: <code>#292</code></p> <p>You passed an extra parameter to the constructor, which has historically been interpreted as a function that runs when a value is cleaned up.</p> <p>This mechanism has been replaced by scopes.</p>"},{"location":"api-reference/general/errors/#forkeycollision","title":"forKeyCollision","text":"<pre><code>The key '6' was returned multiple times simultaneously, which is not allowed in\n`For` objects.\n</code></pre> <p>Thrown by: <code>ForKeys</code>, <code>ForPairs</code></p> <p>When called with different items from the table, the same key was returned for both of them. This is not allowed, because keys have to be unique in a table.</p>"},{"location":"api-reference/general/errors/#invalidattributechangehandler","title":"invalidAttributeChangeHandler","text":"<pre><code>The change handler for the 'Active' attribute must be a function.\n</code></pre> <p>Thrown by: <code>AttributeChange</code></p> <p><code>AttributeChange</code> expected you to provide a function for it to run when the attribute changes, but you provided something other than a function.</p> <p>For example, you might have accidentally provided <code>nil</code>.</p>"},{"location":"api-reference/general/errors/#invalidattributeouttype","title":"invalidAttributeOutType","text":"<pre><code>[AttributeOut] properties must be given Value objects.\n</code></pre> <p>Thrown by: <code>AttributeOut</code></p> <p><code>AttributeOut</code> expected you to give it a value, but you gave it something else.</p>"},{"location":"api-reference/general/errors/#invalidchangehandler","title":"invalidChangeHandler","text":"<pre><code>The change handler for the 'AbsoluteSize' property must be a function.\n</code></pre> <p>Thrown by: <code>OnChange</code></p> <p><code>OnChange</code> expected you to provide a function for it to run when the property changes, but you provided something other than a function.</p> <p>For example, you might have accidentally provided <code>nil</code>.</p>"},{"location":"api-reference/general/errors/#invalideventhandler","title":"invalidEventHandler","text":"<pre><code>The handler for the 'MouseEnter' event must be a function.\n</code></pre> <p>Thrown by: <code>OnEvent</code></p> <p><code>OnEvent</code> expected you to provide a function for it to run when the event is fired, but you provided something other than a function.</p> <p>For example, you might have accidentally provided <code>nil</code>.</p>"},{"location":"api-reference/general/errors/#invalidoutproperty","title":"invalidOutProperty","text":"<pre><code>The Frame class doesn't have a property called 'MouseButton1Down'.\n</code></pre> <p>Thrown by: <code>Out</code></p> <p>The property that you tried to output doesn't exist on the instance that <code>Out</code> was used with.</p>"},{"location":"api-reference/general/errors/#invalidouttype","title":"invalidOutType","text":"<pre><code>[Out] properties must be given Value objects.\n</code></pre> <p>Thrown by: <code>Out</code></p> <p><code>Out</code> expected you to give it a value, but you gave it something else.</p>"},{"location":"api-reference/general/errors/#invalidpropertytype","title":"invalidPropertyType","text":"<pre><code>'Frame.BackgroundColor3' expected a 'Color3' type, but got a 'Vector3' type.\n</code></pre> <p>Thrown by: <code>New</code>, <code>Hydrate</code></p> <p>You attempted to assign a value to a Roblox instance's property, but the  assignment threw an error because that property doesn't accept values of that type.</p>"},{"location":"api-reference/general/errors/#invalidreftype","title":"invalidRefType","text":"<pre><code>Instance refs must be Value objects.\n</code></pre> <p>Thrown by: <code>Ref</code></p> <p><code>Ref</code> expected you to give it a value, but you gave it something else.</p>"},{"location":"api-reference/general/errors/#invalidspringdamping","title":"invalidSpringDamping","text":"<pre><code>The damping ratio for a spring must be &gt;= 0. (damping was -1.00)\n</code></pre> <p>Thrown by: <code>Spring</code></p> <p>You provided a damping ratio that the spring doesn't support, for example <code>NaN</code>, or a negative damping implying negative friction.</p>"},{"location":"api-reference/general/errors/#invalidspringspeed","title":"invalidSpringSpeed","text":"<pre><code>The speed of a spring must be &gt;= 0. (speed was NaN)\n</code></pre> <p>Thrown by: <code>Spring</code></p> <p>You provided a speed multiplier that the spring doesn't support, for example <code>NaN</code> or a negative speed implying the spring moves backwards through time.</p>"},{"location":"api-reference/general/errors/#mergeconflict","title":"mergeConflict","text":"<pre><code>Multiple definitions for 'Observer' found while merging.\n</code></pre> <p>Thrown by: <code>scoped</code></p> <p>Fusion tried to merge together multiple tables, but a key was found in more than one of the tables, and it's unclear which one you intended to have in the final merged result.</p> <p>This can happen subtly with methods such as  <code>scoped()</code> which automatically merge together all of their arguments.</p>"},{"location":"api-reference/general/errors/#mistypedspringdamping","title":"mistypedSpringDamping","text":"<pre><code>The damping ratio for a spring must be a number. (got a string)\n</code></pre> <p>Thrown by: <code>Spring</code></p> <p>You provided a damping ratio that the spring couldn't understand. Damping ratio has to be a number.</p>"},{"location":"api-reference/general/errors/#mistypedspringspeed","title":"mistypedSpringSpeed","text":"<pre><code>The speed of a spring must be a number. (got a string)\n</code></pre> <p>Thrown by: <code>Spring</code></p> <p>You provided a speed multiplier that the spring couldn't understand. Speed has to be a number.</p>"},{"location":"api-reference/general/errors/#mistypedtweeninfo","title":"mistypedTweenInfo","text":"<pre><code>The tween info of a tween must be a TweenInfo. (got a table)\n</code></pre> <p>Thrown by: <code>Tween</code></p> <p>You provided an easing curve that the tween couldn't understand. The easing curve has to be specified using Roblox's <code>TweenInfo</code> data type.</p>"},{"location":"api-reference/general/errors/#notaskscheduler","title":"noTaskScheduler","text":"<pre><code>Fusion is not connected to an external task scheduler.\n</code></pre> <p>Fusion depends on a task scheduler being present to perform certain time-related tasks such as deferral, delays, or updating animations. You'll need to define a set of standard task scheduler functions that Fusion can use for those purposes.</p> <p>Roblox users should never see this error, as Fusion automatically connects to Roblox's task scheduling APIs.</p>"},{"location":"api-reference/general/errors/#poisonedscope","title":"poisonedScope","text":"<pre><code>Attempted to use a scope after it's been destroyed; `doCleanup()` was previously\ncalled on this scope. Ensure you are not reusing scopes after cleanup.\n</code></pre> <p>Thrown by: scopes after being passed to <code>doCleanup</code></p> <p>If you attempt to read from, or write to, a scope that's been destroyed, this message is shown. After a scope has been cleaned up, your code should forget the reference to it, as it is no longer valid.</p>"},{"location":"api-reference/general/errors/#possiblyoutlives","title":"possiblyOutlives","text":"<pre><code>The Computed (bound to the PaddingLeft property) will be destroyed before the \nUIPadding instance; the latter is in a different scope that gets destroyed too \nquickly. To fix this, review the order they're created in, and what scopes they \nbelong to. See discussion #292 on GitHub for advice. \n</code></pre> <p>Thrown by: <code>Spring</code>, <code>Tween</code>, <code>New</code>, <code>Hydrate</code>, <code>Attribute</code>, <code>AttributeOut</code>, <code>Out</code>, <code>Ref</code>, <code>Computed</code>, <code>Observer</code></p> <p>Related discussions: <code>#292</code></p> <p>If you use an object after it's been destroyed, then your code can break. This mainly happens when one object 'outlives' another object that it's using.</p> <p>Because scopes clean up the newest objects first, this can happen when an old object depends on something much newer that itself. During cleanup, a situation could arise where the newer object is destroyed, then the older object runs code of some kind that needed the newer object to be there.</p> <p>Fusion can check for situations like this by analysing the scopes. This message is shown when Fusion can prove one of these situations will occur.</p> <p>There are two typical solutions:</p> <ul> <li>If the objects should always be created and destroyed at the exact same time, then ensure they're created in the correct order.</li> <li>Otherwise, move the objects into separate scopes, and ensure that both scopes can exist without the other scope.</li> </ul>"},{"location":"api-reference/general/errors/#propertyseterror","title":"propertySetError","text":"<pre><code>Error setting property: UIAspectRatioConstraint.AspectRatio set to a\nnon-positive value. Value must be a positive.\n</code></pre> <p>Thrown by: <code>New</code>, <code>Hydrate</code></p> <p>You attempted to set a property, but Roblox threw an error in response.</p> <p>The error includes a more specific message which can be used to diagnose the issue.</p>"},{"location":"api-reference/general/errors/#scopemissing","title":"scopeMissing","text":"<pre><code>To create Observers, provide a scope. (e.g. `myScope:Observer(watching)`). See\ndiscussion #292 on GitHub for advice.\n</code></pre> <p>Thrown by: <code>New</code>, <code>Hydrate</code>, <code>Value</code>, <code>Computed</code>, <code>Observer</code>, <code>ForKeys</code>, <code>ForValues</code>, <code>ForPairs</code>, <code>Spring</code>, <code>Tween</code></p> <p>Related discussions: <code>#292</code></p> <p>You attempted to create an object without providing a scope as the first parameter.</p> <p>Scopes are mandatory for all Fusion constructors so that Fusion knows when the object should be destroyed.</p>"},{"location":"api-reference/general/errors/#springnangoal","title":"springNanGoal","text":"<pre><code>A spring was given a NaN goal, so some simulation has been skipped. Ensure no\nsprings have NaN goals.\n</code></pre> <p>Thrown by: <code>Spring</code></p> <p>The goal parameter given to the spring during construction contained one or more NaN values. </p> <p>This typically occurs when zero is accidentally divided by zero, or some other invalid mathematical operation has occurred. Check that your code is free of maths errors, and handles all edge cases.</p>"},{"location":"api-reference/general/errors/#springnanmotion","title":"springNanMotion","text":"<pre><code>A spring encountered NaN during motion, so has snapped to the goal position.\nEnsure no springs have NaN positions or velocities.\n</code></pre> <p>Thrown by: <code>Spring</code></p> <p>While calculating updated position and velocity, one or both of those values ended up as NaN.</p> <p>This typically occurs when zero is accidentally divided by zero, or some other invalid mathematical operation has occurred. Check that your code is free of maths errors, and handles all edge cases.</p>"},{"location":"api-reference/general/errors/#springtypemismatch","title":"springTypeMismatch","text":"<pre><code>The type 'Vector3' doesn't match the spring's type 'Color3'.\n</code></pre> <p>Thrown by: <code>Spring</code></p> <p>The spring expected you to provide a type matching the data type that the spring is currently outputting. However, you provided a different data type.</p>"},{"location":"api-reference/general/errors/#stategetwasremoved","title":"stateGetWasRemoved","text":"<pre><code>`StateObject:get()` has been replaced by `use()` and `peek()` - see discussion\n#217 on GitHub.\n</code></pre> <p>Thrown by: <code>Value</code>, <code>Computed</code>, <code>ForKeys</code>, <code>ForValues</code>, <code>ForPairs</code>, <code>Spring</code>, <code>Tween</code></p> <p>Related discussions: <code>#217</code></p> <p>Older versions of Fusion let you call <code>:get()</code> directly on state objects to read their current value and attempt to infer dependencies.</p> <p>This has been replaced by use functions in Fusion 0.3 for more predictable behaviour and better support for constant values.</p>"},{"location":"api-reference/general/errors/#tweennangoal","title":"tweenNanGoal","text":"<pre><code>A tween was given a NaN goal, so some animation has been skipped. Ensure no\ntweens have NaN goals.\n</code></pre> <p>Thrown by: <code>Tween</code></p> <p>The goal parameter given to the tween during construction contained one or more NaN values. </p> <p>This typically occurs when zero is accidentally divided by zero, or some other invalid mathematical operation has occurred. Check that your code is free of maths errors, and handles all edge cases.</p>"},{"location":"api-reference/general/errors/#tweennanmotion","title":"tweenNanMotion","text":"<pre><code>A tween encountered NaN during motion, so has snapped to the goal. Ensure no\ntweens have NaN in their tween infos.\n</code></pre> <p>Thrown by: <code>Tween</code></p> <p>While calculating an updated tween position, the final value contained one or more NaN values.</p> <p>This typically occurs when zero is accidentally divided by zero, or some other invalid mathematical operation has occurred. Check that your code is free of maths errors, and handles all edge cases.</p>"},{"location":"api-reference/general/errors/#unknownmessage","title":"unknownMessage","text":"<pre><code>Unknown error: attempt to call a nil value\n</code></pre> <p>Fusion ran into a problem, but couldn't associate it with a valid type of error. This is a fallback error type which shouldn't be seen by end users, because it indicates that Fusion code isn't reporting errors correctly.</p>"},{"location":"api-reference/general/errors/#unrecognisedchildtype","title":"unrecognisedChildType","text":"<pre><code>'string' type children aren't accepted by `[Children]`.\n</code></pre> <p>Thrown by: <code>Children</code></p> <p>You provided a value inside of <code>[Children]</code> which didn't meet the definition of a child value. Check that you're only passing instances, arrays and state objects.</p>"},{"location":"api-reference/general/errors/#unrecognisedpropertykey","title":"unrecognisedPropertyKey","text":"<pre><code>'number' keys aren't accepted in property tables.\n</code></pre> <p>Thrown by: <code>New</code>, <code>Hydrate</code></p> <p>You provided something other than a property assignment (<code>Property = Value</code>) or special key in your property table.</p> <p>Most commonly, this means you tried to add child instances directly into the property table, rather than passing them into the <code>[Children]</code> special key.</p>"},{"location":"api-reference/general/errors/#unrecognisedpropertystage","title":"unrecognisedPropertyStage","text":"<pre><code>'children' isn't a valid stage for a special key to be applied at.\n</code></pre> <p>Thrown by: <code>New</code>, <code>Hydrate</code></p> <p>You attempted to use a special key which has a misconfigured <code>stage</code>, so Fusion didn't know when to apply it during instance construction.</p>"},{"location":"api-reference/general/errors/#useafterdestroy","title":"useAfterDestroy","text":"<pre><code>The Value object is no longer valid - it was destroyed before the Computed that \nis use()-ing. See discussion #292 on GitHub for advice.\n</code></pre> <p>Thrown by: <code>Spring</code>, <code>Tween</code>, <code>New</code>, <code>Hydrate</code>, <code>Attribute</code>, <code>AttributeOut</code>, <code>Out</code>, <code>Ref</code>, <code>Computed</code>, <code>Observer</code></p> <p>Related discussions: <code>#292</code></p> <p>Your code attempted to access an object after that object was destroyed..</p> <p>Make sure your objects are being added to the correct scopes according to when you expect them to be destroyed. Additionally, make sure your code can detect and deal with situations where other objects are no longer available.</p>"},{"location":"api-reference/general/members/contextual/","title":"Contextual","text":"General Members Contextual"},{"location":"api-reference/general/members/contextual/#contextual-contextualt","title":"Contextual          -&gt; Contextual&lt;T&gt;","text":"<pre><code>function Fusion.Contextual&lt;T&gt;(\n    defaultValue: T\n): Contextual&lt;T&gt;\n</code></pre> <p>Constructs and returns a new contextual.</p>"},{"location":"api-reference/general/members/contextual/#parameters","title":"Parameters","text":""},{"location":"api-reference/general/members/contextual/#defaultvalue-t","title":"defaultValue              : T","text":"<p>The value which <code>Contextual:now()</code> should return if no value has been specified by <code>Contextual:is():during()</code>.</p>"},{"location":"api-reference/general/members/contextual/#returns-contextualt","title":"Returns              -&gt; Contextual&lt;T&gt;","text":"<p>A freshly constructed contextual.</p>"},{"location":"api-reference/general/members/contextual/#learn-more","title":"Learn More","text":"<ul> <li>Sharing Values tutorial</li> </ul>"},{"location":"api-reference/general/members/safe/","title":"Safe","text":"General Members Safe"},{"location":"api-reference/general/members/safe/#safe-success-fail","title":"Safe          -&gt; Success | Fail","text":"<pre><code>function Fusion.Safe&lt;Success, Fail&gt;(\n    callbacks: {\n        try: () -&gt; Success,\n        fallback: (err: unknown) -&gt; Fail\n    }\n): Success | Fail\n</code></pre> <p>Safely runs a function and returns the value it produces. If the function fails, the <code>fallback</code> function can handle the error and produces a fallback value.</p> <p><code>Safe</code> acts like a version of <code>xpcall</code> that is easier to use in calculations and expressions, because it only returns the values from the functions, rather than returning a success boolean.</p> <p>Fatal versus non-fatal errors</p> <p><code>Safe</code> only protects you from errors that would stop your calculation from successfully returning a value.</p> <p>In particular, this applies to computeds you create inside <code>Safe</code> (and other similar objects). Because errors there are safely handled by those objects, and do not cause the <code>Safe</code> calculation to crash fatally, you have to use <code>Safe</code> inside of the computed itself if you want to capture the error.</p>"},{"location":"api-reference/general/members/safe/#properties","title":"Properties","text":""},{"location":"api-reference/general/members/safe/#try-success","title":"try              : () -&gt; Success","text":"<p>The possibly erroneous calculation or expression.</p>"},{"location":"api-reference/general/members/safe/#fallback-err-unknown-fail","title":"fallback              : (err: unknown) -&gt; Fail","text":"<p>A fallback calculation that should provide a backup answer if the possibly erroneous calculation throws an error.</p>"},{"location":"api-reference/general/members/safe/#returns-success-fail","title":"Returns              -&gt; Success | Fail","text":"<p>The value produced by <code>try</code> if it's successful, or the value produced by <code>fallback</code> if an error occurs during <code>try</code>.</p>"},{"location":"api-reference/general/members/version/","title":"version","text":"General Members version"},{"location":"api-reference/general/members/version/#version-version","title":"version          : Version","text":"<pre><code>Fusion.version: Version\n</code></pre> <p>The version of the Fusion source code.</p> <p><code>isRelease</code> is only <code>true</code> when using a version of Fusion downloaded from the Releases page.</p>"},{"location":"api-reference/general/types/contextual/","title":"Contextual","text":"General Types Contextual"},{"location":"api-reference/general/types/contextual/#contextual","title":"Contextual","text":"<pre><code>export type Contextual&lt;T&gt; = {\n    type: \"Contextual\",\n    now: (self) -&gt; T,\n    is: (self, newValue: T) -&gt; {\n        during: &lt;R, A...&gt;(self, callback: (A...) -&gt; R, A...) -&gt; R\n    }\n}\n</code></pre> <p>An object representing a widely-accessible value, which can take on different values at different times in different coroutines.</p> <p>Non-standard type syntax</p> <p>The above type definition uses <code>self</code> to denote methods. At time of writing, Luau does not interpret <code>self</code> specially.</p>"},{"location":"api-reference/general/types/contextual/#fields","title":"Fields","text":""},{"location":"api-reference/general/types/contextual/#type-contextual","title":"type              : \"Contextual\"","text":"<p>A type string which can be used for runtime type checking.</p>"},{"location":"api-reference/general/types/contextual/#methods","title":"Methods","text":""},{"location":"api-reference/general/types/contextual/#now-t","title":"now              -&gt; T","text":"<pre><code>function Contextual:now(): T\n</code></pre> <p>Returns the current value of this contextual. This varies based on when the function is called, and in what coroutine it was called.</p>"},{"location":"api-reference/general/types/contextual/#isduring-r","title":"is/during              -&gt; R","text":"<pre><code>function Contextual:is(\n    newValue: T\n): {\n    during: &lt;R, A...&gt;(\n        self,\n        callback: (A...) -&gt; R,\n        A...\n    ) -&gt; R\n}\n</code></pre> <p>Runs the <code>callback</code> with the arguments <code>A...</code> and returns the value the callback returns (<code>R</code>). The <code>Contextual</code> will appear to be <code>newValue</code> in the callback, unless it's overridden by another <code>:is():during()</code> call.</p>"},{"location":"api-reference/general/types/contextual/#learn-more","title":"Learn More","text":"<ul> <li>Sharing Values tutorial</li> </ul>"},{"location":"api-reference/general/types/version/","title":"Version","text":"General Types Version"},{"location":"api-reference/general/types/version/#version","title":"Version","text":"<pre><code>export type Version = {\n    major: number,\n    minor: number,\n    isRelease: boolean\n}\n</code></pre> <p>Describes a version of Fusion's source code.</p>"},{"location":"api-reference/general/types/version/#members","title":"Members","text":""},{"location":"api-reference/general/types/version/#major-number","title":"major              : number","text":"<p>The major version number. If this is greater than <code>0</code>, then two versions sharing the same major version number are not expected to be incompatible or have breaking changes.</p>"},{"location":"api-reference/general/types/version/#minor-number","title":"minor              : number","text":"<p>The minor version number. Describes version updates that are not enumerated by the major version number, such as versions prior to 1.0, or versions which are non-breaking.</p>"},{"location":"api-reference/general/types/version/#isrelease-boolean","title":"isRelease              : boolean","text":"<p>Describes whether the version was sourced from an official release package.</p>"},{"location":"api-reference/graph/members/observer/","title":"Observer","text":"Graph Members Observer"},{"location":"api-reference/graph/members/observer/#observer-observer","title":"Observer          -&gt; Observer","text":"<pre><code>function Fusion.Observer(\n    scope: Scope&lt;unknown&gt;,\n    watching: unknown\n) -&gt; Observer\n</code></pre> <p>Constructs and returns a new observer.</p> <p>Use scoped() method syntax</p> <p>This function is intended to be accessed as a method on a scope: <pre><code>local observer = scope:Observer(watching)\n</code></pre></p>"},{"location":"api-reference/graph/members/observer/#parameters","title":"Parameters","text":""},{"location":"api-reference/graph/members/observer/#scope-scopeunknown","title":"scope              : Scope&lt;unknown&gt;","text":"<p>The scope which should be used to store destruction tasks for this object.</p>"},{"location":"api-reference/graph/members/observer/#watching-unknown","title":"watching              : unknown","text":"<p>The target that the observer should watch for changes.</p> <p>Works best with graph objects</p> <p>While non-graph object values are accepted for compatibility, they won't be able to trigger updates.</p>"},{"location":"api-reference/graph/members/observer/#returns-observer","title":"Returns              -&gt; Observer","text":"<p>A freshly constructed observer.</p>"},{"location":"api-reference/graph/members/observer/#learn-more","title":"Learn More","text":"<ul> <li>Observers tutorial</li> </ul>"},{"location":"api-reference/graph/types/graphobject/","title":"GraphObject","text":"Graph Types GraphObject"},{"location":"api-reference/graph/types/graphobject/#graphobject","title":"GraphObject","text":"<pre><code>export type GraphObject = ScopedObject &amp; {\n    createdAt: number\n    dependencySet: {[GraphObject]: unknown},\n    dependentSet: {[GraphObject]: unknown},\n    lastChange: number?,\n    timeliness: \"lazy\" | \"eager\",\n    validity: \"valid\" | \"invalid\" | \"busy\",\n    _evaluate: (GraphObject, lastChange: number?) -&gt; boolean\n}\n</code></pre> <p>A reactive graph object which can broadcast and receive updates among other members of the reactive graph.</p> <p>This type includes <code>ScopedObject</code>, which allows the lifetime and destruction order of the reactive graph to be analysed.</p> <p>Non-standard type syntax</p> <p>The above type definition uses <code>self</code> to denote methods. At time of writing, Luau does not interpret <code>self</code> specially.</p>"},{"location":"api-reference/graph/types/graphobject/#members","title":"Members","text":""},{"location":"api-reference/graph/types/graphobject/#createdat-number","title":"createdAt              : number","text":"<p>The <code>os.clock()</code> time of this object's construction, measured as early as possible in the object's constructor.</p>"},{"location":"api-reference/graph/types/graphobject/#dependencyset-graphobject-unknown","title":"dependencySet              : {[GraphObject]: unknown}","text":"<p>Everything this reactive graph object currently declares itself as dependent upon.</p>"},{"location":"api-reference/graph/types/graphobject/#dependentset-graphobject-unknown","title":"dependentSet              : {[GraphObject]: unknown}","text":"<p>The reactive graph objects which declare themselves as dependent upon this object.</p>"},{"location":"api-reference/graph/types/graphobject/#lastchange-number","title":"lastChange              : number?","text":"<p>The <code>os.clock()</code> time of this object's most recent meaningful change, or <code>nil</code> if the object is newly created.</p>"},{"location":"api-reference/graph/types/graphobject/#timeliness-lazy-eager","title":"timeliness              : \"lazy\" | \"eager\"","text":"<p>Describes when this object expects to be revalidated. Most objects should use <code>lazy</code> timeliness to defer computation as late as possible. However, if it's important for this object to respond to changes as soon as possible, for example for the purposes of observation, then <code>eager</code> timeliness ensures that a revalidation is dispatched as soon as possible.</p>"},{"location":"api-reference/graph/types/graphobject/#validity-valid-invalid-busy","title":"validity              : \"valid\" | \"invalid\" | \"busy\"","text":"<p>Whether the most recent validation operation done on this graph object was a revalidation or an invalidation. <code>busy</code> is used while the graph object is in the middle of a revalidation.</p>"},{"location":"api-reference/graph/types/graphobject/#methods","title":"Methods","text":""},{"location":"api-reference/graph/types/graphobject/#_evaluate-boolean","title":"_evaluate              -&gt; boolean","text":"<pre><code>function GraphObject:_evaluate(): boolean\n</code></pre> <p>Called by Fusion while the graph object is in the process of being evaluated. This is where logic to do with computational updates should be placed.</p> <p>The return value is <code>true</code> when a 'meaningful change' occurs because of this revalidation. A 'meaningful change' is one that would affect dependencies' behaviour. This is used to efficiently skip over calculations for dependencies.</p> <p>Restrictions</p> <p>This method should finish without spawning new processes, blocking the  thread, or erroring.</p>"},{"location":"api-reference/graph/types/observer/","title":"Observer","text":"Graph Types Observer"},{"location":"api-reference/graph/types/observer/#observer","title":"Observer","text":"<pre><code>export type Observer = GraphObject &amp; {\n    type: \"Observer\",\n    timeliness: \"eager\",\n    onChange: (self, callback: () -&gt; ()) -&gt; (() -&gt; ()),\n    onBind: (self, callback: () -&gt; ()) -&gt; (() -&gt; ())\n}\n</code></pre> <p>A graph object that runs user code when it's updated by the reactive graph.</p> <p>Non-standard type syntax</p> <p>The above type definition uses <code>self</code> to denote methods. At time of writing, Luau does not interpret <code>self</code> specially.</p>"},{"location":"api-reference/graph/types/observer/#members","title":"Members","text":""},{"location":"api-reference/graph/types/observer/#type-observer","title":"type              : \"Observer\"","text":"<p>A type string which can be used for runtime type checking.</p>"},{"location":"api-reference/graph/types/observer/#methods","title":"Methods","text":""},{"location":"api-reference/graph/types/observer/#onchange-","title":"onChange              -&gt; (() -&gt; ())","text":"<pre><code>function Observer:onChange(\n    callback: () -&gt; ()\n): (() -&gt; ())\n</code></pre> <p>Registers the callback to run when an update is received. </p> <p>The returned function will unregister the callback.</p>"},{"location":"api-reference/graph/types/observer/#onbind-","title":"onBind              -&gt; (() -&gt; ())","text":"<pre><code>function Observer:onBind(\n    callback: () -&gt; ()\n): (() -&gt; ())\n</code></pre> <p>Runs the callback immediately, and registers the callback to run when an update is received.</p> <p>The returned function will unregister the callback.</p>"},{"location":"api-reference/graph/types/observer/#learn-more","title":"Learn More","text":"<ul> <li>Observers tutorial</li> </ul>"},{"location":"api-reference/memory/members/derivescope/","title":"deriveScope","text":"Memory Members deriveScope"},{"location":"api-reference/memory/members/derivescope/#derivescope-scopet","title":"deriveScope          -&gt; Scope&lt;T&gt;","text":"<pre><code>function Fusion.deriveScope&lt;Existing, AddMethods...&gt;(\n    existing: Scope&lt;Existing&gt;,\n    ...: (AddMethods &amp; {})...\n): Scope&lt;merge(Existing, AddMethods...)&gt;\n</code></pre> <p>Returns a blank scope with the same methods as an existing scope, plus some optional additional methods which are merged in to only the new scope.</p> <p>Unlike innerScope, the returned scope has a completely independent lifecycle from the original scope.</p> <p>Pseudo type</p> <p>Luau doesn't have adequate syntax to represent this function.</p> <p>Scopes are not unique</p> <p>Fusion can recycle old unused scopes. This helps make scopes more lightweight, but it also means they don't uniquely belong to any part of your program.</p> <p>As a result, you shouldn't hold on to scopes after they've been cleaned up, and you shouldn't use them as unique identifiers anywhere.</p>"},{"location":"api-reference/memory/members/derivescope/#parameters","title":"Parameters","text":""},{"location":"api-reference/memory/members/derivescope/#existing-scopet","title":"existing              : Scope&lt;T&gt;","text":"<p>An existing scope, whose methods should be re-used for the new scope.</p>"},{"location":"api-reference/memory/members/derivescope/#addmethods","title":"...              : AddMethods...","text":"<p>A series of tables, ideally including functions which take a scope as their first parameter. Those functions will turn into methods on the scope.</p>"},{"location":"api-reference/memory/members/derivescope/#returns-scopet","title":"Returns              -&gt; Scope&lt;T&gt;","text":"<p>A blank (non-inner) scope with the same methods as the existing scope, plus the extra methods provided.</p>"},{"location":"api-reference/memory/members/derivescope/#learn-more","title":"Learn More","text":"<ul> <li>Scopes tutorial</li> </ul>"},{"location":"api-reference/memory/members/docleanup/","title":"doCleanup","text":"Memory Members doCleanup"},{"location":"api-reference/memory/members/docleanup/#docleanup-","title":"doCleanup          -&gt; ()","text":"<pre><code>function Fusion.doCleanup(\n    task: Fusion.Task\n): ()\n</code></pre> <p>Attempts to destroy all arguments based on their runtime type.</p> <p>This is a black hole!</p> <p>Any values you pass into <code>doCleanup</code> should be treated as completely gone. Make sure you remove all references to those values, and ensure your code never uses them again.</p>"},{"location":"api-reference/memory/members/docleanup/#parameters","title":"Parameters","text":""},{"location":"api-reference/memory/members/docleanup/#task-task","title":"task              : Task","text":"<p>A value which should be disposed of; the value's runtime type will be inspected to determine what should happen.</p> <ul> <li>if <code>function</code>, it is called</li> <li>...else if <code>{destroy: (self) -&gt; ()}</code>, <code>:destroy()</code> is called </li> <li>...else if <code>{Destroy: (self) -&gt; ()}</code>, <code>:Destroy()</code> is called</li> <li>...else if <code>{any}</code>, <code>doCleanup</code> is called on all members</li> </ul> <p>When Fusion is running inside of Roblox:</p> <ul> <li>if <code>Instance</code>, <code>:Destroy()</code> is called</li> <li>...else if <code>RBXScriptConnection</code>, <code>:Disconnect()</code> is called</li> </ul> <p>If none of these conditions match, the value is ignored.</p>"},{"location":"api-reference/memory/members/docleanup/#learn-more","title":"Learn More","text":"<ul> <li>Scopes tutorial</li> </ul>"},{"location":"api-reference/memory/members/innerscope/","title":"innerScope","text":"Memory Members innerScope"},{"location":"api-reference/memory/members/innerscope/#innerscope-scopet","title":"innerScope          -&gt; Scope&lt;T&gt;","text":"<pre><code>function Fusion.innerScope&lt;Existing, AddMethods...&gt;(\n    existing: Scope&lt;Existing&gt;,\n    ...: (AddMethods &amp; {})...\n): Scope&lt;merge(Existing, AddMethods...)&gt;\n</code></pre> <p>Returns a blank scope with the same methods as an existing scope, plus some optional additional methods which are merged in to only the new scope.</p> <p>Unlike deriveScope, the returned scope is an inner scope of  the original scope. It exists until either the user calls <code>doCleanup</code> on it, or the original scope is cleaned up.</p> <p>Pseudo type</p> <p>Luau doesn't have adequate syntax to represent this function.</p> <p>Scopes are not unique</p> <p>Fusion can recycle old unused scopes. This helps make scopes more lightweight, but it also means they don't uniquely belong to any part of your program.</p> <p>As a result, you shouldn't hold on to scopes after they've been cleaned up, and you shouldn't use them as unique identifiers anywhere.</p>"},{"location":"api-reference/memory/members/innerscope/#parameters","title":"Parameters","text":""},{"location":"api-reference/memory/members/innerscope/#existing-scopet","title":"existing              : Scope&lt;T&gt;","text":"<p>An existing scope, whose methods should be re-used for the new scope.</p>"},{"location":"api-reference/memory/members/innerscope/#addmethods","title":"...              : AddMethods...","text":"<p>A series of tables, ideally including functions which take a scope as their first parameter. Those functions will turn into methods on the scope.</p>"},{"location":"api-reference/memory/members/innerscope/#returns-scopet","title":"Returns              -&gt; Scope&lt;T&gt;","text":"<p>A blank inner scope with the same methods as the existing scope, plus the extra methods provided.</p>"},{"location":"api-reference/memory/members/innerscope/#learn-more","title":"Learn More","text":"<ul> <li>Scopes tutorial</li> </ul>"},{"location":"api-reference/memory/members/insert/","title":"insert","text":"Memory Members insert"},{"location":"api-reference/memory/members/insert/#insert-tasks","title":"insert          -&gt; Tasks...","text":"<pre><code>function Fusion.insert&lt;Tasks...&gt;(\n    scope: Scope&lt;unknown&gt;,\n    ...: Tasks...\n): Tasks...\n</code></pre> <p>Inserts destruction tasks passed in to the scope. Returns the clean up tasks to be used for variable declarations.</p> <p>Use scoped() method syntax</p> <p>This function is intended to be accessed as a method on a scope: <pre><code>local conn, ins = scope:insert(\n    RunService.Heartbeat:Connnect(doUpdate),\n    Instance.new(\"Part\", workspace)\n)\n</code></pre></p>"},{"location":"api-reference/memory/members/insert/#parameters","title":"Parameters","text":""},{"location":"api-reference/memory/members/insert/#scope-scopeunknown","title":"scope              : Scope&lt;unknown&gt;","text":"<p>The scope which should be used to store destruction tasks.</p>"},{"location":"api-reference/memory/members/insert/#tasks","title":"...              : Tasks...","text":"<p>The destruction tasks which should be inserted into the scope.</p>"},{"location":"api-reference/memory/members/insert/#returns-tasks","title":"Returns              -&gt; Tasks...","text":"<p>The destruction tasks that has been inserted into the scope.</p>"},{"location":"api-reference/memory/members/insert/#learn-more","title":"Learn More","text":"<ul> <li>Scopes tutorial</li> </ul>"},{"location":"api-reference/memory/members/scoped/","title":"scoped","text":"Memory Members scoped"},{"location":"api-reference/memory/members/scoped/#scoped-scopet","title":"scoped          -&gt; Scope&lt;T&gt;","text":"<pre><code>function Fusion.scoped&lt;Methods...&gt;(\n    ...: (Methods &amp; {})...\n): Scope&lt;merge(Methods)&gt;\n</code></pre> <p>Returns a blank scope. Any method tables passed in as arguments are merged together, and used as the <code>__index</code> of the new scope, such that they can be called with method notation on the created scope.</p> <p>Pseudo type</p> <p>Luau doesn't have adequate syntax to represent this function.</p> <p>Scopes are not unique</p> <p>Fusion can recycle old unused scopes. This helps make scopes more lightweight, but it also means they don't uniquely belong to any part of your program.</p> <p>As a result, you shouldn't hold on to scopes after they've been cleaned up, and you shouldn't use them as unique identifiers anywhere.</p>"},{"location":"api-reference/memory/members/scoped/#parameters","title":"Parameters","text":""},{"location":"api-reference/memory/members/scoped/#methods","title":"...              : Methods &amp; {}","text":"<p>A series of tables, ideally including functions which take a scope as their first parameter. Those functions will turn into methods on the scope.</p>"},{"location":"api-reference/memory/members/scoped/#returns-scopet","title":"Returns              -&gt; Scope&lt;T&gt;","text":"<p>A blank scope with the specified methods.</p>"},{"location":"api-reference/memory/members/scoped/#learn-more","title":"Learn More","text":"<ul> <li>Scopes tutorial</li> </ul>"},{"location":"api-reference/memory/types/scope/","title":"Scope","text":"Memory Types Scope"},{"location":"api-reference/memory/types/scope/#scope","title":"Scope","text":"<pre><code>export type Scope&lt;Constructors = typeof(Fusion)&gt; = {unknown} &amp; Constructors\n</code></pre> <p>A table collecting all objects created as part of an independent unit of code, with optional <code>Constructors</code> as methods which can be called.</p> <p>Scopes are not unique</p> <p>Fusion can recycle old unused scopes. This helps make scopes more lightweight, but it also means they don't uniquely belong to any part of your program.</p> <p>As a result, you shouldn't hold on to scopes after they've been cleaned up, and you shouldn't use them as unique identifiers anywhere.</p>"},{"location":"api-reference/memory/types/scope/#learn-more","title":"Learn More","text":"<ul> <li>Scopes tutorial</li> </ul>"},{"location":"api-reference/memory/types/scopedobject/","title":"ScopedObject","text":"Memory Types ScopedObject"},{"location":"api-reference/memory/types/scopedobject/#scopedobject","title":"ScopedObject","text":"<pre><code>export type ScopedObject = {\n    scope: Scope&lt;unknown&gt;?,\n    destroy: () -&gt; ()\n}\n</code></pre> <p>An object designed for use with scopes.</p> <p>Objects satisfying this interface can be probed for information about their lifetime and how long they live relative to other objects satisfying this interface. </p> <p>These objects are also recognised by <code>doCleanup</code>.</p>"},{"location":"api-reference/memory/types/scopedobject/#members","title":"Members","text":""},{"location":"api-reference/memory/types/scopedobject/#scope-scopeunknown","title":"scope              : Scope&lt;unknown&gt;?","text":"<p>The scope which this object was constructed with, or <code>nil</code> if the object has been destroyed.</p> <p>Unchanged until destruction</p> <p>The <code>scope</code> is expected to be set once upon construction. It should not be assigned to again, except when the scope is destroyed - at which point it should be set to <code>nil</code> to indicate that it no longer exists inside of a scope. This is typically done inside of <code>oldestTask</code>.</p>"},{"location":"api-reference/memory/types/scopedobject/#oldesttask-unknown","title":"oldestTask              : unknown","text":"<p>The value inside of <code>scope</code> representing the point at which the scoped object will be destroyed.</p> <p>Unchanged until destruction</p> <p>The <code>oldestTask</code> is expected to be set once upon construction. It should not be assigned to again.</p> <p><code>oldestTask</code> is typically a callback that cleans up the object, but it's typed ambiguously here as it is only used as a reference for lifetime analysis, representing the point beyond which the object can be considered completely destroyed. It shouldn't be used for much else.</p>"},{"location":"api-reference/memory/types/scopedobject/#learn-more","title":"Learn More","text":"<ul> <li>Scopes tutorial</li> </ul>"},{"location":"api-reference/memory/types/task/","title":"Task","text":"Memory Types Task"},{"location":"api-reference/memory/types/task/#task","title":"Task","text":"<p><pre><code>export type Task = \n    Instance \n    | RBXScriptConnection\n    | () -&gt; () \n    | {destroy: (self) -&gt; ()} \n    | {Destroy: (self) -&gt; ()} \n    | {Task}\n</code></pre> Types which <code>doCleanup</code> has defined behaviour for.</p> <p>Not enforced</p> <p>Fusion does not use static types to enforce that <code>doCleanup</code> is given a type which it can process.</p> <p>This type is only exposed for your own use.</p>"},{"location":"api-reference/memory/types/task/#learn-more","title":"Learn More","text":"<ul> <li>Scopes tutorial</li> </ul>"},{"location":"api-reference/roblox/members/attribute/","title":"Attribute","text":"Roblox Members Attribute"},{"location":"api-reference/roblox/members/attribute/#attribute-specialkey","title":"Attribute          -&gt; SpecialKey","text":"<pre><code>function Fusion.Attribute(\n    attributeName: string\n): SpecialKey\n</code></pre> <p>Given an attribute name, returns a special key which  can modify attributes of that name.</p> <p>When paired with a value in a property table, the special key sets the attribute to that value.</p>"},{"location":"api-reference/roblox/members/attribute/#parameters","title":"Parameters","text":""},{"location":"api-reference/roblox/members/attribute/#attributename-string","title":"attributeName              : string","text":"<p>The name of the attribute that the special key should target.</p>"},{"location":"api-reference/roblox/members/attribute/#returns-specialkey","title":"Returns              -&gt; SpecialKey","text":"<p>A special key for modifying attributes of that name.</p>"},{"location":"api-reference/roblox/members/attributechange/","title":"AttributeChange","text":"Roblox Members AttributeChange"},{"location":"api-reference/roblox/members/attributechange/#attributechange-specialkey","title":"AttributeChange          -&gt; SpecialKey","text":"<pre><code>function Fusion.AttributeChange(\n    attributeName: string\n): SpecialKey\n</code></pre> <p>Given an attribute name, returns a special key which  can listen to changes for attributes of that name.</p> <p>When paired with a callback in a property table, the special key connects the callback to the attribute's change event.</p>"},{"location":"api-reference/roblox/members/attributechange/#parameters","title":"Parameters","text":""},{"location":"api-reference/roblox/members/attributechange/#attributename-string","title":"attributeName              : string","text":"<p>The name of the attribute that the special key should target.</p>"},{"location":"api-reference/roblox/members/attributechange/#returns-specialkey","title":"Returns              -&gt; SpecialKey","text":"<p>A special key for listening to changes for attributes of that name.</p>"},{"location":"api-reference/roblox/members/attributeout/","title":"AttributeOut","text":"Roblox Members AttributeOut"},{"location":"api-reference/roblox/members/attributeout/#attributeout-specialkey","title":"AttributeOut          -&gt; SpecialKey","text":"<pre><code>function Fusion.AttributeOut(\n    attributeName: string\n): SpecialKey\n</code></pre> <p>Given an attribute name, returns a special key which  can output values from attributes of that name.</p> <p>When paired with a value object in a property table, the special key sets the value when the attribute changes.</p>"},{"location":"api-reference/roblox/members/attributeout/#parameters","title":"Parameters","text":""},{"location":"api-reference/roblox/members/attributeout/#attributename-string","title":"attributeName              : string","text":"<p>The name of the attribute that the special key should target.</p>"},{"location":"api-reference/roblox/members/attributeout/#returns-specialkey","title":"Returns              -&gt; SpecialKey","text":"<p>A special key for outputting values from attributes of that name.</p>"},{"location":"api-reference/roblox/members/child/","title":"Child","text":"Roblox Members Child"},{"location":"api-reference/roblox/members/child/#child-child","title":"Child          -&gt; Child","text":"<pre><code>function Fusion.Child(\n    child: Child\n): Child\n</code></pre> <p>Returns the child passed into it.</p> <p>This function does no processing. It only serves as a hint to the Luau type system, constraining the type of the argument.</p>"},{"location":"api-reference/roblox/members/child/#parameters","title":"Parameters","text":""},{"location":"api-reference/roblox/members/child/#child-child_1","title":"child              : Child","text":"<p>The argument whose type should be constrained.</p>"},{"location":"api-reference/roblox/members/child/#returns-child","title":"Returns              -&gt; Child","text":"<p>The argument with the newly cast static type.</p>"},{"location":"api-reference/roblox/members/child/#learn-more","title":"Learn More","text":"<ul> <li>Parenting tutorial</li> </ul>"},{"location":"api-reference/roblox/members/children/","title":"Children","text":"Roblox Members Children"},{"location":"api-reference/roblox/members/children/#children-specialkey","title":"Children          : SpecialKey","text":"<pre><code>Fusion.Children: SpecialKey\n</code></pre> <p>A special key which parents other instances into this instance.</p> <p>When paired with a <code>Child</code> in a  property table, the special key explores the <code>Child</code> to find every <code>Instance</code> nested inside. It then parents those instances under the instance which the special key was applied to.</p> <p>In particular, this special key will recursively explore arrays and bind to any state objects.</p>"},{"location":"api-reference/roblox/members/children/#learn-more","title":"Learn More","text":"<ul> <li>Parenting tutorial</li> </ul>"},{"location":"api-reference/roblox/members/hydrate/","title":"Hydrate","text":"Roblox Members Hydrate"},{"location":"api-reference/roblox/members/hydrate/#hydrate-propertytable-instance","title":"Hydrate          -&gt; (PropertyTable) -&gt; Instance","text":"<pre><code>function Fusion.Hydrate(\n    target: Instance\n): (\n    props: PropertyTable\n) -&gt; Instance\n</code></pre> <p>Given an instance, returns a component for binding extra functionality to that instance.</p> <p>In the property table, string keys are assigned as properties on the instance. If the value is a state object, it is re-assigned every time the value of the state object changes.</p> <p>Any special keys present in the property table are applied to the instance after string keys are processed, in the order specified by their <code>stage</code>.</p> <p>A special exception is made for assigning <code>Parent</code>, which is only assigned after the <code>descendants</code> stage.</p> <p>Do not overwrite properties</p> <p>If the instance was previously created with <code>New</code> or previously hydrated, do not assign to any properties that were previously specified in those prior calls. Duplicated assignments can interfere with each other in unpredictable ways.</p>"},{"location":"api-reference/roblox/members/hydrate/#parameters","title":"Parameters","text":""},{"location":"api-reference/roblox/members/hydrate/#target-instance","title":"target              : Instance","text":"<p>The instance which should be modified.</p>"},{"location":"api-reference/roblox/members/hydrate/#returns-propertytable-instance","title":"Returns              -&gt; (PropertyTable) -&gt; Instance","text":"<p>A component that hydrates that instance, accepting various properties to build up bindings and operations applied to the instance.</p>"},{"location":"api-reference/roblox/members/hydrate/#learn-more","title":"Learn More","text":"<ul> <li>Hydration tutorial</li> </ul>"},{"location":"api-reference/roblox/members/new/","title":"New","text":"Roblox Members New"},{"location":"api-reference/roblox/members/new/#new-propertytable-instance","title":"New          -&gt; (PropertyTable) -&gt; Instance","text":"<pre><code>function Fusion.New(\n    className: string\n): (\n    props: PropertyTable\n) -&gt; Instance\n</code></pre> <p>Given a class name, returns a component for constructing instances of that class.</p> <p>In the property table, string keys are assigned as properties on the instance. If the value is a state object, it is re-assigned every time the value of the state object changes.</p> <p>Any special keys present in the property table are applied to the instance after string keys are processed, in the order specified by their <code>stage</code>.</p> <p>A special exception is made for assigning <code>Parent</code>, which is only assigned after the <code>descendants</code> stage.</p>"},{"location":"api-reference/roblox/members/new/#parameters","title":"Parameters","text":""},{"location":"api-reference/roblox/members/new/#classname-string","title":"className              : string","text":"<p>The kind of instance that should be constructed.</p>"},{"location":"api-reference/roblox/members/new/#returns-propertytable-instance","title":"Returns              -&gt; (PropertyTable) -&gt; Instance","text":"<p>A component that constructs instances of that type, accepting various properties to customise each instance uniquely.</p>"},{"location":"api-reference/roblox/members/new/#learn-more","title":"Learn More","text":"<ul> <li>New Instances tutorial</li> </ul>"},{"location":"api-reference/roblox/members/onchange/","title":"OnChange","text":"Roblox Members OnChange"},{"location":"api-reference/roblox/members/onchange/#onchange-specialkey","title":"OnChange          -&gt; SpecialKey","text":"<pre><code>function Fusion.OnChange(\n    propertyName: string\n): SpecialKey\n</code></pre> <p>Given an property name, returns a special key which  can listen to changes for properties of that name.</p> <p>When paired with a callback in a property table, the special key connects the callback to the property's change event.</p>"},{"location":"api-reference/roblox/members/onchange/#parameters","title":"Parameters","text":""},{"location":"api-reference/roblox/members/onchange/#propertyname-string","title":"propertyName              : string","text":"<p>The name of the property that the special key should target.</p>"},{"location":"api-reference/roblox/members/onchange/#returns-specialkey","title":"Returns              -&gt; SpecialKey","text":"<p>A special key for listening to changes for properties of that name.</p>"},{"location":"api-reference/roblox/members/onchange/#learn-more","title":"Learn More","text":"<ul> <li>Change Events tutorial</li> </ul>"},{"location":"api-reference/roblox/members/onevent/","title":"OnEvent","text":"Roblox Members OnEvent"},{"location":"api-reference/roblox/members/onevent/#onevent-specialkey","title":"OnEvent          -&gt; SpecialKey","text":"<pre><code>function Fusion.OnEvent(\n    eventName: string\n): SpecialKey\n</code></pre> <p>Given an event name, returns a special key which  can listen for events of that name.</p> <p>When paired with a callback in a property table, the special key connects the callback to the event.</p>"},{"location":"api-reference/roblox/members/onevent/#parameters","title":"Parameters","text":""},{"location":"api-reference/roblox/members/onevent/#eventname-string","title":"eventName              : string","text":"<p>The name of the event that the special key should target.</p>"},{"location":"api-reference/roblox/members/onevent/#returns-specialkey","title":"Returns              -&gt; SpecialKey","text":"<p>A special key for listening to events of that name.</p>"},{"location":"api-reference/roblox/members/onevent/#learn-more","title":"Learn More","text":"<ul> <li>Events tutorial</li> </ul>"},{"location":"api-reference/roblox/members/out/","title":"Out","text":"Roblox Members Out"},{"location":"api-reference/roblox/members/out/#out-specialkey","title":"Out          -&gt; SpecialKey","text":"<pre><code>function Fusion.Out(\n    propertyName: string\n): SpecialKey\n</code></pre> <p>Given an property name, returns a special key which  can output values from properties of that name.</p> <p>When paired with a value object in a property table, the special key sets the value when the property changes.</p>"},{"location":"api-reference/roblox/members/out/#parameters","title":"Parameters","text":""},{"location":"api-reference/roblox/members/out/#propertyname-string","title":"propertyName              : string","text":"<p>The name of the property that the special key should target.</p>"},{"location":"api-reference/roblox/members/out/#returns-specialkey","title":"Returns              -&gt; SpecialKey","text":"<p>A special key for outputting values from properties of that name.</p>"},{"location":"api-reference/roblox/members/out/#learn-more","title":"Learn More","text":"<ul> <li>Outputs tutorial</li> </ul>"},{"location":"api-reference/roblox/types/child/","title":"Child","text":"Roblox Types Child"},{"location":"api-reference/roblox/types/child/#child","title":"Child","text":"<pre><code>export type Child = Instance | StateObject&lt;Child&gt; | {[unknown]: Child}\n</code></pre> <p>All of the types understood by the <code>[Children]</code> special key.</p>"},{"location":"api-reference/roblox/types/child/#learn-more","title":"Learn More","text":"<ul> <li>Parenting tutorial</li> <li>Instance Handling tutorial</li> </ul>"},{"location":"api-reference/roblox/types/propertytable/","title":"PropertyTable","text":"Roblox Types PropertyTable"},{"location":"api-reference/roblox/types/propertytable/#propertytable","title":"PropertyTable","text":"<pre><code>export type PropertyTable = {[string | SpecialKey]: unknown}\n</code></pre> <p>A table of named instance properties and special keys, which can be passed to <code>New</code> to create an instance.</p> <p>This type can be overly generic</p> <p>In most cases, you should know what properties your code is looking for. In those cases, you should prefer to list out the properties explicitly, to document what your code needs.</p> <p>You should only use this type if you don't know what properties your code will accept.</p>"},{"location":"api-reference/roblox/types/specialkey/","title":"SpecialKey","text":"General Types SpecialKey"},{"location":"api-reference/roblox/types/specialkey/#specialkey","title":"SpecialKey","text":"<pre><code>export type SpecialKey = {\n    type: \"SpecialKey\",\n    kind: string,\n    stage: \"self\" | \"descendants\" | \"ancestor\" | \"observer\",\n    apply: (\n        self,\n        scope: Scope&lt;unknown&gt;,\n        value: unknown,\n        applyTo: Instance\n    ) -&gt; ()\n}\n</code></pre> <p>When used as the key in a property table, defines a custom operation to apply to the created Roblox instance.</p> <p>Non-standard type syntax</p> <p>The above type definition uses <code>self</code> to denote methods. At time of writing, Luau does not interpret <code>self</code> specially.</p>"},{"location":"api-reference/roblox/types/specialkey/#members","title":"Members","text":""},{"location":"api-reference/roblox/types/specialkey/#type-specialkey","title":"type              : \"SpecialKey\"","text":"<p>A type string which can be used for runtime type checking.</p>"},{"location":"api-reference/roblox/types/specialkey/#kind-string","title":"kind              : string","text":"<p>A more specific type string which can be used for runtime type checking. This can be used to tell types of special key apart.</p>"},{"location":"api-reference/roblox/types/specialkey/#stage-self-descendants-ancestor-observer","title":"stage              : \"self\" | \"descendants\" | \"ancestor\" | \"observer\"","text":"<p>Describes the type of operation, which subsequently determines when it's applied relative to other operations.</p> <ul> <li><code>self</code> runs before parenting any instances</li> <li><code>descendants</code> runs once descendants are parented, but before this instance is parented to its ancestor</li> <li><code>ancestor</code> runs after all parenting operations are complete</li> <li><code>observer</code> runs after all other operations, so the final state of the instance can be observed</li> </ul>"},{"location":"api-reference/roblox/types/specialkey/#methods","title":"Methods","text":""},{"location":"api-reference/roblox/types/specialkey/#apply-","title":"apply              -&gt; ()","text":"<pre><code>function SpecialKey:apply(\n    self,\n    scope: Scope&lt;unknown&gt;,\n    value: unknown,\n    applyTo: Instance\n): ()\n</code></pre> <p>Called to apply this operation to an instance. <code>value</code> is the value from the property table, and <code>applyTo</code> is the instance to apply the operation to.</p> <p>The given <code>scope</code> is cleaned up when the operation is being unapplied, including when the instance is destroyed. Operations should use the scope to clean up any connections or undo any changes they cause.</p>"},{"location":"api-reference/state/members/computed/","title":"Computed","text":"State Members Computed"},{"location":"api-reference/state/members/computed/#computed-computedt","title":"Computed          -&gt; Computed&lt;T&gt;","text":"<pre><code>function Fusion.Computed&lt;T, S&gt;(\n    scope: Scope&lt;S&gt;,\n    processor: (Use, Scope&lt;S&gt;) -&gt; T\n) -&gt; Computed&lt;T&gt;\n</code></pre> <p>Constructs and returns a new computed state object.</p> <p>Use scoped() method syntax</p> <p>This function is intended to be accessed as a method on a scope: <pre><code>local computed = scope:Computed(processor)\n</code></pre></p>"},{"location":"api-reference/state/members/computed/#parameters","title":"Parameters","text":""},{"location":"api-reference/state/members/computed/#scope-scopes","title":"scope              : Scope&lt;S&gt;","text":"<p>The scope which should be used to store destruction tasks for this object.</p>"},{"location":"api-reference/state/members/computed/#processor-use-scopes-t","title":"processor              : (Use,          Scope&lt;S&gt;) -&gt; T","text":"<p>Computes the value that will be used by the computed. The processor is given a use function for including other objects in the computation, and a scope for queueing destruction tasks to run on re-computation. The given scope has the same methods as the scope used to create the computed.</p>"},{"location":"api-reference/state/members/computed/#returns-computedt","title":"Returns              -&gt; Computed&lt;T&gt;","text":"<p>A freshly constructed computed state object.</p>"},{"location":"api-reference/state/members/computed/#learn-more","title":"Learn More","text":"<ul> <li>Computeds tutorial</li> </ul>"},{"location":"api-reference/state/members/forkeys/","title":"ForKeys","text":"State Members ForKeys"},{"location":"api-reference/state/members/forkeys/#forkeys-forko-v","title":"ForKeys          -&gt; For&lt;KO, V&gt;","text":"<pre><code>function Fusion.ForKeys&lt;KI, KO, V, S&gt;(\n    scope: Scope&lt;S&gt;,\n    inputTable: UsedAs&lt;{[KI]: V}&gt;,\n    processor: (Use, Scope&lt;S&gt;, key: KI) -&gt; KO\n) -&gt; For&lt;KO, V&gt;\n</code></pre> <p>Constructs and returns a new For state object which processes keys and preserves values.</p> <p>Use scoped() method syntax</p> <p>This function is intended to be accessed as a method on a scope: <pre><code>local forObj = scope:ForKeys(inputTable, processor)\n</code></pre></p>"},{"location":"api-reference/state/members/forkeys/#parameters","title":"Parameters","text":""},{"location":"api-reference/state/members/forkeys/#scope-scopes","title":"scope              : Scope&lt;S&gt;","text":"<p>The scope which should be used to store destruction tasks for this object.</p>"},{"location":"api-reference/state/members/forkeys/#inputtable-usedaski-v","title":"inputTable              : UsedAs&lt;{[KI]: V}&gt;","text":"<p>The table which will provide the input keys and input values for this object.</p> <p>If it is a state object, this object will respond to changes in that state.</p>"},{"location":"api-reference/state/members/forkeys/#processor-use-scopes-key-ki-ko","title":"processor              : (Use,          Scope&lt;S&gt;,         key: KI) -&gt; KO","text":"<p>Accepts a <code>KI</code> key from the input table, and returns the <code>KO</code> key that should appear in the output table.</p> <p>The processor is given a use function for including other objects in the computation, and a scope for queueing destruction tasks to run on re-computation. The given scope has the same methods as the scope used to create the whole object.</p>"},{"location":"api-reference/state/members/forkeys/#returns-forko-v","title":"Returns              -&gt; For&lt;KO, V&gt;","text":"<p>A freshly constructed For state object.</p>"},{"location":"api-reference/state/members/forkeys/#learn-more","title":"Learn More","text":"<ul> <li>ForKeys tutorial</li> </ul>"},{"location":"api-reference/state/members/forpairs/","title":"ForPairs","text":"State Members ForPairs"},{"location":"api-reference/state/members/forpairs/#forpairs-forko-vo","title":"ForPairs          -&gt; For&lt;KO, VO&gt;","text":"<pre><code>function Fusion.ForPairs&lt;KI, KO, VI, VO, S&gt;(\n    scope: Scope&lt;S&gt;,\n    inputTable: UsedAs&lt;{[KI]: VI}&gt;,\n    processor: (Use, Scope&lt;S&gt;, key: KI, value: VI) -&gt; (KO, VO)\n) -&gt; For&lt;KO, VO&gt;\n</code></pre> <p>Constructs and returns a new For state object which processes keys and values in pairs.</p> <p>Use scoped() method syntax</p> <p>This function is intended to be accessed as a method on a scope: <pre><code>local forObj = scope:ForPairs(inputTable, processor)\n</code></pre></p>"},{"location":"api-reference/state/members/forpairs/#parameters","title":"Parameters","text":""},{"location":"api-reference/state/members/forpairs/#scope-scopes","title":"scope              : Scope&lt;S&gt;","text":"<p>The scope which should be used to store destruction tasks for this object.</p>"},{"location":"api-reference/state/members/forpairs/#inputtable-usedaski-vi","title":"inputTable              : UsedAs&lt;{[KI]: VI}&gt;","text":"<p>The table which will provide the input keys and input values for this object.</p> <p>If it is a state object, this object will respond to changes in that state.</p>"},{"location":"api-reference/state/members/forpairs/#processor-use-scopes-key-ki-value-vi-ko-vo","title":"processor              : (Use,          Scope&lt;S&gt;,         key: KI, value: VI) -&gt; (KO, VO)","text":"<p>Accepts a <code>KI</code> key and <code>VI</code> value pair from the input table, and returns the  <code>KO</code> key and <code>VO</code> value pair that should appear in the output table.</p> <p>The processor is given a use function for including other objects in the computation, and a scope for queueing destruction tasks to run on re-computation. The given scope has the same methods as the scope used to create the whole object.</p>"},{"location":"api-reference/state/members/forpairs/#returns-forko-vo","title":"Returns              -&gt; For&lt;KO, VO&gt;","text":"<p>A freshly constructed For state object.</p>"},{"location":"api-reference/state/members/forpairs/#learn-more","title":"Learn More","text":"<ul> <li>ForPairs tutorial</li> </ul>"},{"location":"api-reference/state/members/forvalues/","title":"ForValues","text":"State Members ForValues"},{"location":"api-reference/state/members/forvalues/#forvalues-fork-vo","title":"ForValues          -&gt; For&lt;K, VO&gt;","text":"<pre><code>function Fusion.ForValues&lt;K, VI, VO, S&gt;(\n    scope: Scope&lt;S&gt;,\n    inputTable: UsedAs&lt;{[K]: VI}&gt;,\n    processor: (Use, Scope&lt;S&gt;, value: VI) -&gt; VO\n) -&gt; For&lt;K, VO&gt;\n</code></pre> <p>Constructs and returns a new For state object which processes values and preserves keys.</p> <p>Use scoped() method syntax</p> <p>This function is intended to be accessed as a method on a scope: <pre><code>local forObj = scope:ForValues(inputTable, processor)\n</code></pre></p>"},{"location":"api-reference/state/members/forvalues/#parameters","title":"Parameters","text":""},{"location":"api-reference/state/members/forvalues/#scope-scopes","title":"scope              : Scope&lt;S&gt;","text":"<p>The scope which should be used to store destruction tasks for this object.</p>"},{"location":"api-reference/state/members/forvalues/#inputtable-usedask-vi","title":"inputTable              : UsedAs&lt;{[K]: VI}&gt;","text":"<p>The table which will provide the input keys and input values for this object.</p> <p>If it is a state object, this object will respond to changes in that state.</p>"},{"location":"api-reference/state/members/forvalues/#processor-use-scopes-value-vi-vo","title":"processor              : (Use,          Scope&lt;S&gt;,         value: VI) -&gt; VO","text":"<p>Accepts a <code>VI</code> value from the input table, and returns the <code>VO</code> value that should appear in the output table.</p> <p>The processor is given a use function for including other objects in the computation, and a scope for queueing destruction tasks to run on re-computation. The given scope has the same methods as the scope used to create the whole object.</p>"},{"location":"api-reference/state/members/forvalues/#returns-fork-vo","title":"Returns              -&gt; For&lt;K, VO&gt;","text":"<p>A freshly constructed For state object.</p>"},{"location":"api-reference/state/members/forvalues/#learn-more","title":"Learn More","text":"<ul> <li>ForValues tutorial</li> </ul>"},{"location":"api-reference/state/members/peek/","title":"peek","text":"State Members peek"},{"location":"api-reference/state/members/peek/#peek-use","title":"peek          : Use","text":"<pre><code>function Fusion.peek&lt;T&gt;(\n    target: UsedAs&lt;T&gt;\n): T\n</code></pre> <p>Extracts a value of type <code>T</code> from its input.</p> <p>This is a general-purpose implementation of <code>Use</code>. It does not do any extra processing or book-keeping beyond what is required to determine the returned value.</p> <p>Specific implementations</p> <p>If you're given a specific implementation of <code>Use</code> by an API, it's highly likely that you are expected to use that implementation instead of <code>peek()</code>.</p> <p>This applies to reusable code too. It's often best to ask for a <code>Use</code> callback if your code needs to extract values, so an appropriate implementation can be passed in. </p> <p>Alternatively for reusable code, you can avoid extracting values entirely, and expect the user to do it prior to calling your code. This can work well if you unconditionally use all inputs, but beware that you may end up extracting more values than you need - this can have performance implications.</p>"},{"location":"api-reference/state/members/peek/#parameters","title":"Parameters","text":""},{"location":"api-reference/state/members/peek/#target-usedast","title":"target              : UsedAs&lt;T&gt;","text":"<p>The abstract representation of <code>T</code> to extract a value from.</p>"},{"location":"api-reference/state/members/peek/#returns-t","title":"Returns              -&gt; T","text":"<p>The current value of <code>T</code>, derived from <code>target</code>.</p>"},{"location":"api-reference/state/members/peek/#learn-more","title":"Learn More","text":"<ul> <li>Values tutorial</li> </ul>"},{"location":"api-reference/state/members/value/","title":"Value","text":"State Members Value"},{"location":"api-reference/state/members/value/#value-valuet","title":"Value          -&gt; Value&lt;T&gt;","text":"<pre><code>function Fusion.Value&lt;T&gt;(\n    scope: Scope&lt;unknown&gt;,\n    initialValue: T\n) -&gt; Value&lt;T&gt;\n</code></pre> <p>Constructs and returns a new value state object.</p> <p>Use scoped() method syntax</p> <p>This function is intended to be accessed as a method on a scope: <pre><code>local computed = scope:Computed(processor)\n</code></pre></p>"},{"location":"api-reference/state/members/value/#parameters","title":"Parameters","text":""},{"location":"api-reference/state/members/value/#scope-scopes","title":"scope              : Scope&lt;S&gt;","text":"<p>The scope which should be used to store destruction tasks for this object.</p>"},{"location":"api-reference/state/members/value/#initialvalue-t","title":"initialValue              : T","text":"<p>The initial value that will be stored until the next value is <code>:set()</code>.</p>"},{"location":"api-reference/state/members/value/#returns-valuet","title":"Returns              -&gt; Value&lt;T&gt;","text":"<p>A freshly constructed value state object.</p>"},{"location":"api-reference/state/members/value/#learn-more","title":"Learn More","text":"<ul> <li>Values tutorial</li> </ul>"},{"location":"api-reference/state/types/computed/","title":"Computed","text":"State Types Computed"},{"location":"api-reference/state/types/computed/#computed","title":"Computed","text":"<pre><code>export type Computed&lt;T&gt; = StateObject&lt;T&gt; &amp; {\n    kind: \"Computed\",\n    timeliness: \"lazy\"\n}\n</code></pre> <p>A specialised state object for tracking single values computed from a user-defined computation.</p> <p>This type isn't generally useful outside of Fusion itself.</p>"},{"location":"api-reference/state/types/computed/#members","title":"Members","text":""},{"location":"api-reference/state/types/computed/#kind-computed","title":"kind              : \"Computed\"","text":"<p>A more specific type string which can be used for runtime type checking. This can be used to tell types of state object apart.</p>"},{"location":"api-reference/state/types/computed/#learn-more","title":"Learn More","text":"<ul> <li>Computeds tutorial</li> </ul>"},{"location":"api-reference/state/types/for/","title":"For","text":"State Types For"},{"location":"api-reference/state/types/for/#for","title":"For","text":"<pre><code>export type For&lt;KO, VO&gt; = StateObject&lt;{[KO]: VO}&gt; &amp; {\n    kind: \"For\"\n}\n</code></pre> <p>A specialised state object for tracking multiple values computed from user-defined computations, which are merged into an output table.</p> <p>This type isn't generally useful outside of Fusion itself.</p>"},{"location":"api-reference/state/types/for/#members","title":"Members","text":""},{"location":"api-reference/state/types/for/#kind-for","title":"kind              : \"For\"","text":"<p>A more specific type string which can be used for runtime type checking. This can be used to tell types of state object apart.</p>"},{"location":"api-reference/state/types/for/#learn-more","title":"Learn More","text":"<ul> <li>ForValues tutorial</li> <li>ForKeys tutorial</li> <li>ForPairs tutorial</li> </ul>"},{"location":"api-reference/state/types/stateobject/","title":"StateObject","text":"State Types StateObject"},{"location":"api-reference/state/types/stateobject/#stateobject","title":"StateObject","text":"<pre><code>export type StateObject&lt;T&gt; = GraphObject &amp; {\n    type: \"State\",\n    kind: string,\n    _EXTREMELY_DANGEROUS_usedAsValue: T\n}\n</code></pre> <p>Stores a value of <code>T</code> which can change over time. As a  graph object, it can broadcast updates when its value changes.</p> <p>This type isn't generally useful outside of Fusion itself; you should prefer to work with <code>UsedAs&lt;T&gt;</code> in your own code.</p>"},{"location":"api-reference/state/types/stateobject/#members","title":"Members","text":""},{"location":"api-reference/state/types/stateobject/#type-state","title":"type              : \"State\"","text":"<p>A type string which can be used for runtime type checking.</p>"},{"location":"api-reference/state/types/stateobject/#kind-string","title":"kind              : string","text":"<p>A more specific type string which can be used for runtime type checking. This can be used to tell types of state object apart.</p>"},{"location":"api-reference/state/types/stateobject/#_extremely_dangerous_usedasvalue-t","title":"_EXTREMELY_DANGEROUS_usedAsValue              : T","text":"<p>This is for low-level library authors only!</p> <p>DO NOT USE THIS UNDER ANY CIRCUMSTANCES. IT IS UNNECESSARILY DANGEROUS TO DO SO.</p> <p>You should never, ever access this in end user code. It doesn't matter if you think it'll save you from importing a function or typing a few characters. YOUR CODE WILL NOT WORK.</p> <p>If you choose to use it anyway, you give full permission for your employer to fire you immediately and personally defenestrate your laptop.</p> <p>The value that should be read out by any use functions. Implementors of the state object interface must ensure this property contains a valid value whenever the validity of the object is <code>valid</code>.</p> <p>This property must never invoke side effects in the reactive graph when read from or written to.</p>"},{"location":"api-reference/state/types/use/","title":"Use","text":"State Types Use"},{"location":"api-reference/state/types/use/#use","title":"Use","text":"<pre><code>export type Use = &lt;T&gt;(target: UsedAs&lt;T&gt;) -&gt; T\n</code></pre> <p>A function which extracts a value of <code>T</code> from something that can be used as <code>T</code>.</p> <p>The most generic implementation of this is the <code>peek()</code> function, which performs this extraction with no additional steps. </p> <p>However, certain APIs may provide their own implementation, so they can perform additional processing for certain representations. Most notably, computeds provide their own <code>use()</code> function which adds inputs to a watchlist, which allows them to re-calculate as inputs change.</p>"},{"location":"api-reference/state/types/use/#parameters","title":"Parameters","text":""},{"location":"api-reference/state/types/use/#target-usedast","title":"target              : UsedAs&lt;T&gt;","text":"<p>The representation of <code>T</code> to extract a value from.</p>"},{"location":"api-reference/state/types/use/#returns-t","title":"Returns              -&gt; T","text":"<p>The current value of <code>T</code>, derived from <code>target</code>.</p>"},{"location":"api-reference/state/types/use/#learn-more","title":"Learn More","text":"<ul> <li>Values tutorial</li> <li>Computeds tutorial</li> </ul>"},{"location":"api-reference/state/types/usedas/","title":"UsedAs","text":"State Types UsedAs"},{"location":"api-reference/state/types/usedas/#usedas","title":"UsedAs","text":"<pre><code>export type UsedAs&lt;T&gt; = T | StateObject&lt;T&gt;\n</code></pre> <p>Something which describes a value of type <code>T</code>. When it is used in a calculation, it becomes that value.</p> <p>Recommended</p> <p>Instead of using one of the more specific variants, your code should aim to use this type as often as possible. It allows your logic to deal with many representations of values at once, </p>"},{"location":"api-reference/state/types/usedas/#variants","title":"Variants","text":"<ul> <li><code>T</code> - represents unchanging constant values</li> <li><code>StateObject&lt;T&gt;</code> - represents dynamically updating values</li> </ul>"},{"location":"api-reference/state/types/usedas/#learn-more","title":"Learn More","text":"<ul> <li>Components tutorial</li> </ul>"},{"location":"api-reference/state/types/value/","title":"Value","text":"State Types Value"},{"location":"api-reference/state/types/value/#value","title":"Value","text":"<pre><code>export type Value&lt;T&gt; = StateObject&lt;T&gt; &amp; {\n    kind: \"State\",\n    set: (self, newValue: T) -&gt; (),\n    timeliness: \"lazy\"\n}\n</code></pre> <p>A specialised state object which allows regular Luau code to control its value.</p> <p>Non-standard type syntax</p> <p>The above type definition uses <code>self</code> to denote methods. At time of writing, Luau does not interpret <code>self</code> specially.</p>"},{"location":"api-reference/state/types/value/#members","title":"Members","text":""},{"location":"api-reference/state/types/value/#kind-value","title":"kind              : \"Value\"","text":"<p>A more specific type string which can be used for runtime type checking. This can be used to tell types of state object apart.</p>"},{"location":"api-reference/state/types/value/#methods","title":"Methods","text":""},{"location":"api-reference/state/types/value/#set-t","title":"set              -&gt; T","text":"<pre><code>function Value:set(\n    newValue: T\n): T\n</code></pre> <p>Updates the value of this state object. Other objects using the value are notified of the change.</p> <p>The <code>newValue</code> is always returned, so that <code>:set()</code> can be used to capture values inside of expressions.</p>"},{"location":"api-reference/state/types/value/#learn-more","title":"Learn More","text":"<ul> <li>Values tutorial</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Welcome to the Examples section! Here, you can find various open-source examples and projects, so you can see how Fusion works in a real setting.</p>"},{"location":"examples/#the-cookbook","title":"The Cookbook","text":"<p>Oftentimes, you might be stuck on a small problem. You want to create something specific, but don't know how to do it with Fusion's tools.</p> <p>The cookbook can help with that! It's a collection of snippets which show you how to do various small tasks with Fusion, like processing arrays, applying animations and responding to different events.</p> <p>Visit the cookbook to see what's available.</p>"},{"location":"examples/#open-source-projects","title":"Open-Source Projects","text":""},{"location":"examples/#fusion-wordle-for-fusion-02","title":"Fusion Wordle (for Fusion 0.2)","text":"<p>See how Fusion can be used to build a mobile-first UI-centric game, with server validation, spring animations and sounds.</p> <p>Play and edit the game on Roblox.</p>"},{"location":"examples/#fusion-obby-for-fusion-01","title":"Fusion Obby (for Fusion 0.1)","text":"<p>See how Fusion can be used to build a minimal interface for an obby, with an animated checkpoint counter and simulated confetti.</p> <p>Play and edit the game on Roblox.</p>"},{"location":"examples/cookbook/","title":"Cookbook","text":"<p>Oftentimes, you might be stuck on a small problem. You want to create something specific, but don't know how to do it with Fusion's tools.</p> <p>The cookbook can help with that! It's a collection of snippets which show you how to do various small tasks with Fusion, like processing arrays, applying animations and responding to different events.</p>"},{"location":"examples/cookbook/#navigation","title":"Navigation","text":"<p>Using the sidebar to the left, you can browse all of the cookbook examples by name.</p>"},{"location":"examples/cookbook/animated-computed/","title":"Animated Computed","text":"<p>This example shows you how to animate a single value with an animation curve of your preference.</p> <p>For demonstration, the example uses Roblox API members.</p>"},{"location":"examples/cookbook/animated-computed/#overview","title":"Overview","text":"<pre><code>local Players = game:GetService(\"Players\")\n\nlocal Fusion = -- initialise Fusion here however you please!\nlocal scoped = Fusion.scoped\nlocal peek = Fusion.peek\nlocal Children = Fusion.Children\n\nlocal TWEEN_INFO = TweenInfo.new(\n    0.5,\n    Enum.EasingStyle.Sine,\n    Enum.EasingDirection.InOut\n)\n\n-- Don't forget to pass this to `doCleanup` if you disable the script.\nlocal scope = scoped(Fusion)\n\n-- You can set this at any time to indicate where The Thing should be.\nlocal showTheThing = scope:Value(false)\n\nlocal exampleUI = scope:New \"ScreenGui\" {\n    Parent = Players.LocalPlayer:FindFirstChildOfClass(\"PlayerGui\"),\n    Name = \"Example UI\",\n\n    [Children] = scope:New \"Frame\" {\n        Name = \"The Thing\",\n        Position = scope:Tween(\n            scope:Computed(function(use)\n                local CENTRE = UDim2.fromScale(0.5, 0.5)\n                local OFFSCREEN = UDim2.fromScale(-0.5, 0.5)\n                return if use(showTheThing) then CENTRE else OFFSCREEN\n            end),\n            TWEEN_INFO\n        ),\n        Size = UDim2.fromOffset(200, 200)\n    }\n}\n\n-- Without toggling the value, you won't see it animate.\ntask.defer(function()\n    while true do\n        task.wait(1)\n        showTheThing:set(not peek(showTheThing))\n    end\nend)\n</code></pre>"},{"location":"examples/cookbook/animated-computed/#explanation","title":"Explanation","text":"<p>There's three key components to the above code snippet.</p> <p>Firstly, there's <code>showTheThing</code>. When this is <code>true</code>, The Thing should be in the centre of the screen. Otherwise, The Thing should be off-screen.</p> <pre><code>-- You can set this at any time to indicate where The Thing should be.\nlocal showTheThing = scope:Value(false)\n</code></pre> <p>Next, there's the computed object on line 26. This takes that boolean value, and turns it into a UDim2 position for The Thing to use. You can imagine this as the 'non-animated' version of what you want The Thing to do, if it were to instantly teleport around.</p> <pre><code>            scope:Computed(function(use)\n                local CENTRE = UDim2.fromScale(0.5, 0.5)\n                local OFFSCREEN = UDim2.fromScale(-0.5, 0.5)\n                return if use(showTheThing) then CENTRE else OFFSCREEN\n            end),\n</code></pre> <p>Finally, there's the tween object that the computed is being passed into. The tween object will smoothly move towards the computed over time. If needed, you could separate the computed into a dedicated variable to access it independently.</p> <pre><code>        Position = scope:Tween(\n            scope:Computed(function(use)\n                local CENTRE = UDim2.fromScale(0.5, 0.5)\n                local OFFSCREEN = UDim2.fromScale(-0.5, 0.5)\n                return if use(showTheThing) then CENTRE else OFFSCREEN\n            end),\n            TWEEN_INFO\n        ),\n</code></pre> <p>The 'shape' of the animation is saved in a <code>TWEEN_INFO</code> constant defined earlier in the code. The Tween tutorial explains how each parameter shapes the motion.</p> <pre><code>local TWEEN_INFO = TweenInfo.new(\n    0.5,\n    Enum.EasingStyle.Sine,\n    Enum.EasingDirection.InOut\n)\n</code></pre> <p>Fluid animations with springs</p> <p>For extra smooth animation shapes that preserve velocity, consider trying spring objects. They're very similar in usage and can help improve the responsiveness of the motion.</p>"},{"location":"examples/cookbook/button-component/","title":"Button Component","text":"<p>This example is a relatively complete button component implemented using Fusion's Roblox API. It handles many common interactions such as hovering and clicking.</p> <p>This should be a generally useful template for assembling components of your own. For further ideas and best practices for building components, see the Components tutorial.</p>"},{"location":"examples/cookbook/button-component/#overview","title":"Overview","text":"<pre><code>local Fusion = -- initialise Fusion here however you please!\nlocal peek = Fusion.peek\nlocal Children, OnEvent = Fusion.Children, Fusion.OnEvent\ntype UsedAs&lt;T&gt; = Fusion.UsedAs&lt;T&gt;\n\nlocal COLOUR_BLACK = Color3.new(0, 0, 0)\nlocal COLOUR_WHITE = Color3.new(1, 1, 1)\n\nlocal COLOUR_TEXT = COLOUR_WHITE\nlocal COLOUR_BG_REST = Color3.fromHex(\"0085FF\")\nlocal COLOUR_BG_HOVER = COLOUR_BG_REST:Lerp(COLOUR_WHITE, 0.25)\nlocal COLOUR_BG_HELD = COLOUR_BG_REST:Lerp(COLOUR_BLACK, 0.25)\nlocal COLOUR_BG_DISABLED = Color3.fromHex(\"CCCCCC\")\n\nlocal BG_FADE_SPEED = 20 -- spring speed units\n\nlocal ROUNDED_CORNERS = UDim.new(0, 4)\nlocal PADDING = UDim2.fromOffset(6, 4)\n\nlocal function Button(\n    scope: Fusion.Scope,\n    props: {\n        Name: UsedAs&lt;string&gt;?,\n        Layout: {\n            LayoutOrder: UsedAs&lt;number&gt;?,\n            Position: UsedAs&lt;UDim2&gt;?,\n            AnchorPoint: UsedAs&lt;Vector2&gt;?,\n            ZIndex: UsedAs&lt;number&gt;?,\n            Size: UsedAs&lt;UDim2&gt;?,\n            AutomaticSize: UsedAs&lt;Enum.AutomaticSize&gt;?\n        },\n        Text: UsedAs&lt;string&gt;?,\n        Disabled: UsedAs&lt;boolean&gt;?,\n        OnClick: (() -&gt; ())?\n    }\n): Fusion.Child\n    local isHovering = scope:Value(false)\n    local isHeldDown = scope:Value(false)\n\n    return scope:New \"TextButton\" {\n        Name = props.Name,\n\n        LayoutOrder = props.Layout.LayoutOrder,\n        Position = props.Layout.Position,\n        AnchorPoint = props.Layout.AnchorPoint,\n        ZIndex = props.Layout.ZIndex,\n        Size = props.Layout.Size,\n        AutomaticSize = props.Layout.AutomaticSize,\n\n        Text = props.Text,\n        TextColor3 = COLOUR_TEXT,\n\n        BackgroundColor3 = scope:Spring(\n            scope:Computed(function(use)\n                -- The order of conditions matter here; it defines which states\n                -- visually override other states, with earlier states being\n                -- more important.\n                return\n                    if use(props.Disabled) then COLOUR_BG_DISABLED\n                    elseif use(isHeldDown) then COLOUR_BG_HELD\n                    elseif use(isHovering) then COLOUR_BG_HOVER\n                    else COLOUR_BG_REST\n                end), \n            BG_FADE_SPEED\n        ),\n\n        [OnEvent \"Activated\"] = function()\n            if props.OnClick ~= nil and not peek(props.Disabled) then\n                -- Explicitly called with no arguments to match the typedef. \n                -- If passed straight to `OnEvent`, the function might receive\n                -- arguments from the event. If the function secretly *does*\n                -- take arguments (despite the type) this would cause problems.\n                props.OnClick()\n            end\n        end,\n\n        [OnEvent \"MouseButton1Down\"] = function()\n            isHeldDown:set(true)\n        end,\n        [OnEvent \"MouseButton1Up\"] = function()\n            isHeldDown:set(false)\n        end,\n\n        [OnEvent \"MouseEnter\"] = function()\n            -- Roblox calls this event even if the button is being covered by\n            -- other UI. For simplicity, this does not account for that.\n            isHovering:set(true)\n        end,\n        [OnEvent \"MouseLeave\"] = function()\n            -- If the button is being held down, but the cursor moves off the\n            -- button, then we won't receive the mouse up event. To make sure\n            -- the button doesn't get stuck held down, we'll release it if the\n            -- cursor leaves the button.\n            isHeldDown:set(false)\n            isHovering:set(false)\n        end,\n\n        [Children] = {\n            scope:New \"UICorner\" {\n                CornerRadius = ROUNDED_CORNERS\n            },\n\n            scope:New \"UIPadding\" {\n                PaddingTop = PADDING.Y,\n                PaddingBottom = PADDING.Y,\n                PaddingLeft = PADDING.X,\n                PaddingRight = PADDING.X\n            }\n        }\n    }\nend\n\nreturn Button\n</code></pre>"},{"location":"examples/cookbook/button-component/#explanation","title":"Explanation","text":"<p>The main part of note is the function signature. It's highly recommended that you statically type the function signature for components, because it not only improves autocomplete and error checking, but also acts as up-to-date, machine readable documentation.</p> <pre><code>local function Button(\n    scope: Fusion.Scope,\n    props: {\n        Name: UsedAs&lt;string&gt;?,\n        Layout: {\n            LayoutOrder: UsedAs&lt;number&gt;?,\n            Position: UsedAs&lt;UDim2&gt;?,\n            AnchorPoint: UsedAs&lt;Vector2&gt;?,\n            ZIndex: UsedAs&lt;number&gt;?,\n            Size: UsedAs&lt;UDim2&gt;?,\n            AutomaticSize: UsedAs&lt;Enum.AutomaticSize&gt;?\n        },\n        Text: UsedAs&lt;string&gt;?,\n        Disabled: UsedAs&lt;boolean&gt;?,\n        OnClick: (() -&gt; ())?\n    }\n): Fusion.Child\n</code></pre> <p>The <code>scope</code> parameter specifies that the component depends on Fusion's methods. If you're not sure how to write type definitions for scopes, the 'Scopes' section of the Components tutorial goes into further detail.</p> <p>The property table is laid out with each property on a new line, so it's easy to scan the list and see what properties are available. Most are typed with <code>UsedAs</code>, which allows the user to  use state objects if they desire. They're also <code>?</code> (optional), which can reduce boilerplate when using the component. Not all properties have to be that way, but usually it's better to have the flexibility.</p> <p>Property grouping</p> <p>You can group properties together in nested tables, like the <code>Layout</code> table above, to avoid long mixed lists of properties. In addition to being more readable, this can sometimes help with passing around lots of properties at once, because you can pass the whole nested table as one value if you'd like to.</p> <p>The return type of the function is <code>Fusion.Child</code>, which tells the user that the component is compatible with Fusion's <code>[Children]</code> API, without exposing what children it's returning specifically. This helps ensure the user doesn't accidentally depend on the internal structure of the component.</p>"},{"location":"examples/cookbook/drag-and-drop/","title":"Drag & Drop","text":"<p>This example shows a full drag-and-drop implementation for mouse input only, using Fusion's Roblox API.</p> <p>To ensure best accessibility, any interactions you implement shouldn't force you to hold the mouse button down. Either allow drag-and-drop with single clicks, or provide a non-dragging alternative. This ensures people with reduced motor ability aren't locked out of UI functions.</p> <pre><code>local Players = game:GetService(\"Players\")\nlocal UserInputService = game:GetService(\"UserInputService\")\n\nlocal Fusion = -- initialise Fusion here however you please!\nlocal scoped = Fusion.scoped\nlocal peek = Fusion.peek\nlocal Children, OnEvent, Out = Fusion.Children, Fusion.OnEvent, Fusion.Out\ntype UsedAs&lt;T&gt; = Fusion.UsedAs&lt;T&gt;\n\ntype DragInfo = {\n    id: string,\n    mouseOffset: Vector2 -- relative to the dragged item\n}\n\nlocal function Draggable(\n    scope: Fusion.Scope,\n    props: {\n        ID: string,\n        Name: UsedAs&lt;string&gt;?,\n        Parent: UsedAs&lt;Instance?&gt;,\n        Layout: {\n            LayoutOrder: UsedAs&lt;number&gt;?,\n            Position: UsedAs&lt;UDim2&gt;?,\n            AnchorPoint: UsedAs&lt;Vector2&gt;?,\n            ZIndex: UsedAs&lt;number&gt;?,\n            Size: UsedAs&lt;UDim2&gt;?,\n            AutomaticSize: UsedAs&lt;Enum.AutomaticSize&gt;?,\n            OutAbsolutePosition: Fusion.Value&lt;Vector2&gt;?,\n        },\n        Dragging: {\n            MousePosition: UsedAs&lt;Vector2&gt;,\n            SelfDragInfo: UsedAs&lt;DragInfo?&gt;,\n            OverlayFrame: UsedAs&lt;Instance?&gt;\n        },\n        [typeof(Children)]: Fusion.Child\n    }\n): Fusion.Child\n    -- When `nil`, the parent can't be measured for some reason.\n    local parentSize = scope:Value(nil)\n    do\n        local parent = peek(props.Parent)\n        local function measureParentNow()\n            parentSize:set(\n                if parent ~= nil and parent:IsA(\"GuiObject\")\n                then parent.AbsoluteSize\n                else nil\n            )\n        end\n        local resizeConn = nil\n        local function stopMeasuring()\n            if resizeConn ~= nil then\n                resizeConn:Disconnect()\n                resizeConn = nil\n            end\n        end\n        scope:Observer(props.Parent):onBind(function()\n            stopMeasuring()\n            measureParentNow()\n            if peek(parentSize) ~= nil then\n                resizeConn = parent:GetPropertyChangedSignal(\"AbsoluteSize\")\n                    :Connect(measureParentNow)\n            end\n        end)\n        table.insert(scope, stopMeasuring)\n    end\n\n    return scope:New \"Frame\" {\n        Name = props.Name or \"Draggable\",\n        Parent = scope:Computed(function(use)\n            return\n                if use(props.Dragging.SelfDragInfo) ~= nil\n                then use(props.Dragging.OverlayFrame)\n                else use(props.Parent)\n        end),\n\n        LayoutOrder = props.Layout.LayoutOrder,\n        AnchorPoint = props.Layout.AnchorPoint,\n        ZIndex = props.Layout.ZIndex,\n        AutomaticSize = props.Layout.AutomaticSize,\n\n        BackgroundTransparency = 1,\n\n        Position = scope:Computed(function(use)\n            local dragInfo = use(props.Dragging.SelfDragInfo)\n            if dragInfo == nil then\n                return use(props.Layout.Position) or UDim2.fromOffset(0, 0)\n            else\n                local mousePos = use(props.Dragging.MousePosition)\n                local topLeftCorner = mousePos - dragInfo.mouseOffset\n                return UDim2.fromOffset(topLeftCorner.X, topLeftCorner.Y)\n            end\n        end),\n        -- Calculated manually so the Scale can be set relative to\n        -- `props.Parent` at all times, rather than the `Parent` of this Frame.\n        Size = scope:Computed(function(use)\n            local udim2 = use(props.Layout.Size) or UDim2.fromOffset(0, 0)\n            local parentSize = use(parentSize) or Vector2.zero\n            return UDim2.fromOffset(\n                udim2.X.Scale * parentSize.X + udim2.X.Offset,\n                udim2.Y.Scale * parentSize.Y + udim2.Y.Offset\n            )\n        end),\n\n        [Out \"AbsolutePosition\"] = props.Layout.OutAbsolutePosition,\n        [Children] = props[Children]\n    }\nend\n\nlocal COLOUR_COMPLETED = Color3.new(0, 1, 0)\nlocal COLOUR_NOT_COMPLETED = Color3.new(1, 1, 1)\n\nlocal TODO_ITEM_SIZE = UDim2.new(1, 0, 0, 50)\n\nlocal function newUniqueID()\n    -- You can replace this with a better method for generating unique IDs.\n    return game:GetService(\"HttpService\"):GenerateGUID()\nend\n\ntype TodoItem = {\n    id: string,\n    text: string,\n    completed: Fusion.Value&lt;boolean&gt;\n}\n\nlocal function TodoEntry(\n    scope: Fusion.Scope,\n    props: {\n        Item: TodoItem,\n        Parent: UsedAs&lt;Instance?&gt;,\n        Layout: {\n            LayoutOrder: UsedAs&lt;number&gt;?,\n            Position: UsedAs&lt;UDim2&gt;?,\n            AnchorPoint: UsedAs&lt;Vector2&gt;?,\n            ZIndex: UsedAs&lt;number&gt;?,\n            Size: UsedAs&lt;UDim2&gt;?,\n            OutAbsolutePosition: Fusion.Value&lt;Vector2&gt;?,\n        },\n        Dragging: {\n            MousePosition: UsedAs&lt;Vector2&gt;,\n            SelfDragInfo: UsedAs&lt;DragInfo?&gt;,\n            OverlayFrame: UsedAs&lt;Instance&gt;?\n        },\n        OnMouseDown: () -&gt; ()?\n    }\n): Fusion.Child\n    local scope = scope:innerScope {\n        Draggable = Draggable\n    }\n\n    return scope:Draggable {\n        ID = props.Item.id,\n        Name = props.Item.text,\n        Parent = props.Parent,\n        Layout = props.Layout,\n        Dragging = props.Dragging,\n\n        [Children] = scope:New \"TextButton\" {\n            Name = \"TodoEntry\",\n\n            Size = UDim2.fromScale(1, 1),\n            BackgroundColor3 = scope:Computed(function(use)\n                return\n                    if use(props.Item.completed)\n                    then COLOUR_COMPLETED\n                    else COLOUR_NOT_COMPLETED\n            end),\n            Text = props.Item.text,\n            TextSize = 28,\n\n            [OnEvent \"MouseButton1Down\"] = props.OnMouseDown\n\n            --[[ Don't detect mouse up here, because in some rare cases, \n            the event could be missed due to lag between the item's \n            position and the cursor position.]]\n        }\n    }\nend\n\n-- Don't forget to pass this to `doCleanup` if you disable the script.\nlocal scope = scoped(Fusion,{\n    TodoEntry = TodoEntry\n})\n\nlocal todoItems: {TodoItem} = {\n    {\n        id = newUniqueID(),\n        text = \"Wake up today\",\n        completed = scope:Value(true)\n    },\n    {\n        id = newUniqueID(),\n        text = \"Read the Fusion docs\",\n        completed = scope:Value(true)\n    },\n    {\n        id = newUniqueID(),\n        text = \"Take over the universe\",\n        completed = scope:Value(false)\n    }\n}\nlocal function getTodoItemForID(\n    id: string\n): TodoItem?\n    for _, item in todoItems do\n        if item.id == id then\n            return item\n        end\n    end\n    return nil\nend\n\nlocal mousePos = scope:Value(UserInputService:GetMouseLocation())\ntable.insert(scope, \n    UserInputService.InputChanged:Connect(function(inputObject)\n        if inputObject.UserInputType == Enum.UserInputType.MouseMovement then\n            -- If this code did not read coordinates from the same method, it\n            -- might inconsistently handle UI insets. So, keep it simple!\n            mousePos:set(UserInputService:GetMouseLocation())\n        end\n    end)\n)\n\nlocal dropAction = scope:Value(nil)\n\nlocal taskLists = scope:ForPairs(\n    {\n        incomplete = \"mark-as-incomplete\",\n        completed = \"mark-as-completed\" \n    },\n    function(use, scope, listName, listDropAction)\n        return \n            listName, \n            scope:New \"ScrollingFrame\" {\n                Name = `TaskList ({listName})`,\n                Position = if listName == \"incomplete\" then\n                    UDim2.fromScale(0.1, 0.1)\n                else\n                    UDim2.fromScale(.5, .1),\n                Size = UDim2.fromScale(0.35, 0.9),\n\n                BackgroundTransparency = 0.75,\n                BackgroundColor3 = if listName == \"incomplete\" then\n                    Color3.new(1, 0, 0)\n                else\n                    Color3.new(0, 1, 0),\n\n                [OnEvent \"MouseEnter\"] = function()\n                    dropAction:set(listDropAction)\n                end,\n\n                [OnEvent \"MouseLeave\"] = function()\n                    -- A different item might have overwritten this already.\n                    if peek(dropAction) == listDropAction then\n                        dropAction:set(nil)\n                    end\n                end,\n\n                [Children] = {\n                    scope:New \"UIListLayout\" {\n                        SortOrder = \"Name\",\n                        Padding = UDim.new(0, 5)\n                    }\n                }\n            }\n    end\n)\n\nlocal overlayFrame = scope:New \"Frame\" {\n    Size = UDim2.fromScale(1, 1),\n    ZIndex = 10,\n    BackgroundTransparency = 1\n}\n\nlocal currentlyDragging: Fusion.Value&lt;DragInfo?&gt; = scope:Value(nil)\n\nfor _, item in todoItems do\n    local itemPosition = scope:Value(nil)\n    scope:TodoEntry {\n        Item = item,\n        Parent = scope:Computed(function(use)\n            return\n                if use(item.completed)\n                then use(taskLists).completed\n                else use(taskLists).incomplete\n        end),\n        Layout = {\n            Size = TODO_ITEM_SIZE,\n            OutAbsolutePosition = itemPosition\n        },\n        Dragging = {\n            MousePosition = mousePos,\n            SelfDragInfo = scope:Computed(function(use)\n                local dragInfo = use(currentlyDragging)\n                return \n                    if dragInfo == nil or dragInfo.id ~= item.id\n                    then nil\n                    else dragInfo\n            end),\n            OverlayFrame = overlayFrame\n        },\n        OnMouseDown = function()\n            if peek(currentlyDragging) == nil then\n                local itemPos = peek(itemPosition) or Vector2.zero\n                local mouseOffset = peek(mousePos) - itemPos\n                currentlyDragging:set({\n                    id = item.id,\n                    mouseOffset = mouseOffset\n                })\n            end\n        end\n    }\nend\n\ntable.insert(scope,\n    UserInputService.InputEnded:Connect(function(inputObject)\n        if inputObject.UserInputType ~= Enum.UserInputType.MouseButton1 then\n            return\n        end\n        local dragInfo = peek(currentlyDragging)\n        if dragInfo == nil then\n            return\n        end\n        local item = getTodoItemForID(dragInfo.id)\n        local action = peek(dropAction)\n        if item ~= nil then\n            if action == \"mark-as-incomplete\" then\n                item.completed:set(false)\n            elseif action == \"mark-as-completed\" then\n                item.completed:set(true)\n            end\n        end\n        currentlyDragging:set(nil)\n    end)\n)\n\nlocal ui = scope:New \"ScreenGui\" {\n    Name = \"DragAndDropGui\",\n    Parent = Players.LocalPlayer:FindFirstChildOfClass(\"PlayerGui\"),\n\n    [Children] = {\n        overlayFrame,\n        taskLists,\n        -- Don't pass `allEntries` in here - they manage their own parent!\n    }\n}\n</code></pre>"},{"location":"examples/cookbook/drag-and-drop/#explanation","title":"Explanation","text":"<p>The basic idea is to create a container which stores the UI you want to drag. This container then reparents itself as it gets dragged around between different containers.</p> <p>The <code>Draggable</code> component implements everything necessary to make a seamlessly re-parentable container.</p> <pre><code>type DragInfo = {\n    id: string,\n    mouseOffset: Vector2 -- relative to the dragged item\n}\n\nlocal function Draggable(\n    scope: Fusion.Scope,\n    props: {\n        ID: string,\n        Name: UsedAs&lt;string&gt;?,\n        Parent: UsedAs&lt;Instance?&gt;,\n        Layout: {\n            LayoutOrder: UsedAs&lt;number&gt;?,\n            Position: UsedAs&lt;UDim2&gt;?,\n            AnchorPoint: UsedAs&lt;Vector2&gt;?,\n            ZIndex: UsedAs&lt;number&gt;?,\n            Size: UsedAs&lt;UDim2&gt;?,\n            AutomaticSize: UsedAs&lt;Enum.AutomaticSize&gt;?,\n            OutAbsolutePosition: Fusion.Value&lt;Vector2&gt;?,\n        },\n        Dragging: {\n            MousePosition: UsedAs&lt;Vector2&gt;,\n            SelfDragInfo: UsedAs&lt;DragInfo?&gt;,\n            OverlayFrame: UsedAs&lt;Instance?&gt;\n        },\n        [typeof(Children)]: Fusion.Child\n    }\n): Fusion.Child\n</code></pre> <p>By default, <code>Draggable</code> behaves like a regular Frame, parenting itself to the <code>Parent</code> property and applying its <code>Layout</code> properties.</p> <p>It only behaves specially when <code>Dragging.SelfDragInfo</code> is provided. Firstly, it reparents itself to <code>Dragging.OverlayFrame</code>, so it can be seen in front of other UI.</p> <pre><code>        Parent = scope:Computed(function(use)\n            return\n                if use(props.Dragging.SelfDragInfo) ~= nil\n                then use(props.Dragging.OverlayFrame)\n                else use(props.Parent)\n        end),\n</code></pre> <p>Because of this reparenting, <code>Draggable</code> has to do some extra work to keep the size consistent; it manually calculates the size based on the size of <code>Parent</code>, so it doesn't change size when moved to <code>Dragging.OverlayFrame</code>.</p> <pre><code>        -- Calculated manually so the Scale can be set relative to\n        -- `props.Parent` at all times, rather than the `Parent` of this Frame.\n        Size = scope:Computed(function(use)\n            local udim2 = use(props.Layout.Size) or UDim2.fromOffset(0, 0)\n            local parentSize = use(parentSize) or Vector2.zero\n            return UDim2.fromOffset(\n                udim2.X.Scale * parentSize.X + udim2.X.Offset,\n                udim2.Y.Scale * parentSize.Y + udim2.Y.Offset\n            )\n        end),\n</code></pre> <p>The <code>Draggable</code> also needs to snap to the mouse cursor, so it can be moved by the user. Ideally, the mouse would stay fixed in position relative to the <code>Draggable</code>, so there are no abrupt changes in the position of any elements.</p> <p>As part of <code>Dragging.SelfDragInfo</code>, a <code>mouseOffset</code> is provided, which describes how far the mouse should stay from the top-left corner. So, when setting the position of the <code>Draggable</code>, that offset can be applied to keep the UI fixed in position relative to the mouse.</p> <pre><code>        Position = scope:Computed(function(use)\n            local dragInfo = use(props.Dragging.SelfDragInfo)\n            if dragInfo == nil then\n                return use(props.Layout.Position) or UDim2.fromOffset(0, 0)\n            else\n                local mousePos = use(props.Dragging.MousePosition)\n                local topLeftCorner = mousePos - dragInfo.mouseOffset\n                return UDim2.fromOffset(topLeftCorner.X, topLeftCorner.Y)\n            end\n        end),\n</code></pre> <p>This is all that's needed to make a generic container that can seamlessly move between distinct parts of the UI. The rest of the example demonstrates how this can be integrated into real world UI.</p> <p>The <code>TodoEntry</code> component is meant to represent one individual <code>TodoItem</code>.</p> <pre><code>type TodoItem = {\n    id: string,\n    text: string,\n    completed: Fusion.Value&lt;boolean&gt;\n}\n\nlocal function TodoEntry(\n    scope: Fusion.Scope,\n    props: {\n        Item: TodoItem,\n        Parent: UsedAs&lt;Instance?&gt;,\n        Layout: {\n            LayoutOrder: UsedAs&lt;number&gt;?,\n            Position: UsedAs&lt;UDim2&gt;?,\n            AnchorPoint: UsedAs&lt;Vector2&gt;?,\n            ZIndex: UsedAs&lt;number&gt;?,\n            Size: UsedAs&lt;UDim2&gt;?,\n            OutAbsolutePosition: Fusion.Value&lt;Vector2&gt;?,\n        },\n        Dragging: {\n            MousePosition: UsedAs&lt;Vector2&gt;,\n            SelfDragInfo: UsedAs&lt;DragInfo?&gt;,\n            OverlayFrame: UsedAs&lt;Instance&gt;?\n        },\n        OnMouseDown: () -&gt; ()?\n    }\n): Fusion.Child\n</code></pre> <p>Notice that it shares many of the same property groups as <code>Draggable</code> - these can be passed directly through. </p> <pre><code>    return scope:Draggable {\n        ID = props.Item.id,\n        Name = props.Item.text,\n        Parent = props.Parent,\n        Layout = props.Layout,\n        Dragging = props.Dragging,\n</code></pre> <p>It also provides an <code>OnMouseDown</code> callback, which can be used to pick up the entry if the mouse is pressed down above the entry. Note the comment about why it is not desirable to detect mouse-up here; the UI should unconditionally respond to mouse-up, even if the mouse happens to briefly leave this element.</p> <pre><code>            [OnEvent \"MouseButton1Down\"] = props.OnMouseDown\n\n            --[[ Don't detect mouse up here, because in some rare cases, \n            the event could be missed due to lag between the item's \n            position and the cursor position.]]\n</code></pre> <p>The example creates a list of <code>TodoItem</code> objects, each with a unique ID, text message, and completion status. Because we don't expect the ID or text to change, they're just constant values. However, the completion status is expected to change, so that's specified to be a <code>Value</code> object.</p> <pre><code>local todoItems: {TodoItem} = {\n    {\n        id = newUniqueID(),\n        text = \"Wake up today\",\n        completed = scope:Value(true)\n    },\n    {\n        id = newUniqueID(),\n        text = \"Read the Fusion docs\",\n        completed = scope:Value(true)\n    },\n    {\n        id = newUniqueID(),\n        text = \"Take over the universe\",\n        completed = scope:Value(false)\n    }\n}\n</code></pre> <p>Now, the destinations for these entries can be created. To help decide where to drop items later, the <code>dropAction</code> tracks which destination the mouse is hovered over.</p> <p>The destinations' position and background color are dependant on their source <code>listName</code>.</p> <pre><code>local dropAction = scope:Value(nil)\n\nlocal taskLists = scope:ForPairs(\n    {\n        incomplete = \"mark-as-incomplete\",\n        completed = \"mark-as-completed\" \n    },\n    function(use, scope, listName, listDropAction)\n        return \n            listName, \n            scope:New \"ScrollingFrame\" {\n                Name = `TaskList ({listName})`,\n                Position = if listName == \"incomplete\" then\n                    UDim2.fromScale(0.1, 0.1)\n                else\n                    UDim2.fromScale(.5, .1),\n                Size = UDim2.fromScale(0.35, 0.9),\n\n                BackgroundTransparency = 0.75,\n                BackgroundColor3 = if listName == \"incomplete\" then\n                    Color3.new(1, 0, 0)\n                else\n                    Color3.new(0, 1, 0),\n\n                [OnEvent \"MouseEnter\"] = function()\n                    dropAction:set(listDropAction)\n                end,\n\n                [OnEvent \"MouseLeave\"] = function()\n                    -- A different item might have overwritten this already.\n                    if peek(dropAction) == listDropAction then\n                        dropAction:set(nil)\n                    end\n                end,\n\n                [Children] = {\n                    New \"UIListLayout\" {\n                        SortOrder = \"Name\",\n                        Padding = UDim.new(0, 5)\n                    }\n                }\n            }\n    end\n)\n</code></pre> <p>This is also where the 'overlay frame' is created, which gives currently-dragged UI a dedicated layer above all other UI to freely move around.</p> <pre><code>local overlayFrame = scope:New \"Frame\" {\n    Size = UDim2.fromScale(1, 1),\n    ZIndex = 10,\n    BackgroundTransparency = 1\n}\n</code></pre> <p>Finally, each <code>TodoItem</code> is created as a <code>TodoEntry</code>. Some state is also created to track which entry is being dragged at the moment.</p> <pre><code>local currentlyDragging: Fusion.Value&lt;DragInfo?&gt; = scope:Value(nil)\n\nfor _, item in todoItems do\n    local itemPosition = scope:Value(nil)\n    scope:TodoEntry {\n        Item = item,\n</code></pre> <p>Each entry dynamically picks one of the two destinations based on its completion status.</p> <pre><code>            Parent = scope:Computed(function(use)\n                return\n                    if use(item.completed)\n                    then use(taskLists).completed\n                    else use(taskLists).incomplete\n            end),\n</code></pre> <p>It also provides the information needed by the <code>Draggable</code>.</p> <p>Note that the current drag information is filtered from the <code>currentlyDragging</code> state so the <code>Draggable</code> won't see information about other entries being dragged.</p> <pre><code>            Dragging = {\n                MousePosition = mousePos,\n                SelfDragInfo = scope:Computed(function(use)\n                    local dragInfo = use(currentlyDragging)\n                    return \n                        if dragInfo == nil or dragInfo.id ~= item.id\n                        then nil\n                        else dragInfo\n                end)\n                OverlayFrame = overlayFrame\n            },\n</code></pre> <p>Now it's time to handle starting and stopping the drag.</p> <p>To begin the drag, this code makes use of the <code>OnMouseDown</code> callback. If nothing else is being dragged right now, the position of the mouse relative to the item is captured. Then, that <code>mouseOffset</code> and the <code>id</code> of the item are passed into the <code>currentlyDragging</code> state to indicate this entry is being dragged.</p> <pre><code>            OnMouseDown = function()\n                if peek(currentlyDragging) == nil then\n                    local itemPos = peek(itemPosition) or Vector2.zero\n                    local mouseOffset = peek(mousePos) - itemPos\n                    currentlyDragging:set({\n                        id = item.id,\n                        mouseOffset = mouseOffset\n                    })\n                end\n            end\n</code></pre> <p>To end the drag, a global <code>InputEnded</code> listener is created, which should reliably fire no matter where or when the event occurs. </p> <p>If there's a <code>dropAction</code> to take, for example <code>mark-as-completed</code>, then that action is executed here. </p> <p>In all cases, <code>currentlyDragging</code> is cleared, so the entry is no longer dragged.</p> <pre><code>table.insert(scope,\n    UserInputService.InputEnded:Connect(function(inputObject)\n        if inputObject.UserInputType ~= Enum.UserInputType.MouseButton1 then\n            return\n        end\n        local dragInfo = peek(currentlyDragging)\n        if dragInfo == nil then\n            return\n        end\n        local item = getTodoItemForID(dragInfo.id)\n        local action = peek(dropAction)\n        if item ~= nil then\n            if action == \"mark-as-incomplete\" then\n                item.completed:set(false)\n            elseif action == \"mark-as-completed\" then\n                item.completed:set(true)\n            end\n        end\n        currentlyDragging:set(nil)\n    end)\n)\n</code></pre> <p>All that remains is to parent the task lists and overlay frames to a UI, so they can be seen. Because the <code>TodoEntry</code> component manages their own parent, this code shouldn't pass them as a child here.</p> <pre><code>local ui = scope:New \"ScreenGui\" {\n    Parent = Players.LocalPlayer:FindFirstChildOfClass(\"PlayerGui\"),\n\n    [Children] = {\n        overlayFrame,\n        taskLists,\n        -- Don't pass the generated `TodoEntry`s in here - they manage their own parent!\n    }\n}\n</code></pre>"},{"location":"examples/cookbook/fetch-data-from-server/","title":"Fetch Data From Server","text":"<p>This code shows how to deal with yielding/blocking code, such as fetching data from a server.</p> <p>Because these tasks don't complete immediately, they can't be directly run inside of a <code>Computed</code>, so this example provides a robust framework for handling this in a way that doesn't corrupt your code.</p> <p>This example assumes the presence of a Roblox-like <code>task</code> scheduler.</p>"},{"location":"examples/cookbook/fetch-data-from-server/#overview","title":"Overview","text":"<pre><code>local Fusion = -- initialise Fusion here however you please!\nlocal scoped = Fusion.scoped\nlocal peek = Fusion.peek\n\nlocal function fetchUserBio(\n    userID: number\n): string\n    -- pretend this calls out to a server somewhere, causing this code to yield\n    task.wait(1)\n    return \"This is the bio for user \" .. userID .. \"!\"\nend\n\n-- Don't forget to pass this to `doCleanup` if you disable the script.\nlocal scope = scoped(Fusion)\n\n-- This doesn't have to be a `Value` - any kind of state object works too.\nlocal currentUserID = scope:Value(1670764)\n\n-- While the bio is loading, this is `nil` instead of a string.\nlocal currentUserBio: Fusion.Value&lt;string?&gt; = scope:Value(nil)\n\ndo\n    local fetchInProgress = nil\n    local function performFetch()\n        local userID = peek(currentUserID)\n        currentUserBio:set(nil)\n        if fetchInProgress ~= nil then\n            task.cancel(fetchInProgress)\n        end\n        fetchInProgress = task.spawn(function()\n            currentUserBio:set(fetchUserBio(userID))\n            fetchInProgress = nil\n        end)\n    end\n    scope:Observer(currentUserID):onBind(performFetch)\nend\n\nscope:Observer(currentUserBio):onBind(function()\n    local bio = peek(currentUserBio)\n    if bio == nil then\n        print(\"User bio is loading...\")\n    else\n        print(\"Loaded user bio:\", bio)\n    end\nend)\n</code></pre>"},{"location":"examples/cookbook/fetch-data-from-server/#explanation","title":"Explanation","text":"<p>If you yield or wait inside of a <code>Computed</code>, you can easily corrupt your entire program.</p> <p>However, this example has a function, <code>fetchUserBio</code>, that yields. </p> <pre><code>local function fetchUserBio(\n    userID: number\n): string\n    -- pretend this calls out to a server somewhere, causing this code to yield\n    task.wait(1)\n    return \"This is the bio for user \" .. userID .. \"!\"\nend\n</code></pre> <p>It also has some arbitrary state object, <code>currentUserID</code>, that it needs to convert into a bio somehow.</p> <pre><code>-- This doesn't have to be a `Value` - any kind of state object works too.\nlocal currentUserID = scope:Value(1670764)\n</code></pre> <p>Because <code>Computed</code> can't yield, this code has to manually manage a <code>currentUserBio</code> object, which will store the output of the code in a way that can be used by other Fusion objects later.</p> <p>Notice that the 'loading' state is explicitly documented. It's a good idea to be clear and honest when you have no data to show, because it allows other code to respond to that case flexibly.</p> <pre><code>-- While the bio is loading, this is `nil` instead of a string.\nlocal currentUserBio: Fusion.Value&lt;string?&gt; = scope:Value(nil)\n</code></pre> <p>To perform the actual fetch, a simple function can be written which calls <code>fetchUserBio</code> in a separate task. Once it returns a bio, the <code>currentUserBio</code> can be updated.</p> <p>To avoid two fetches overwriting each other, any existing fetch task is canceled before the new task is created.</p> <pre><code>    local fetchInProgress = nil\n    local function performFetch()\n        local userID = peek(currentUserID)\n        currentUserBio:set(nil)\n        if fetchInProgress ~= nil then\n            task.cancel(fetchInProgress)\n        end\n        fetchInProgress = task.spawn(function()\n            currentUserBio:set(fetchUserBio())\n            fetchInProgress = nil\n        end)\n    end\n</code></pre> <p>Finally, to run this function when the <code>currentUserID</code> changes, <code>performFetch</code> can be added to an <code>Observer</code>.</p> <p>The <code>onBind</code> method also runs <code>performFetch</code> once at the start of the program, so the request is sent out automatically.</p> <pre><code>scope:Observer(currentUserID):onBind(performFetch)\n</code></pre> <p>That's all you need - now, any other Fusion code can read and depend upon <code>currentUserBio</code> as if it were any other kind of state object. Just remember to handle the 'loading' state as well as the successful state.</p> <pre><code>scope:Observer(currentUserBio):onBind(function()\n    local bio = peek(currentUserBio)\n    if bio == nil then\n        print(\"User bio is loading...\")\n    else\n        print(\"Loaded user bio:\", bio)\n    end\nend)\n</code></pre> <p>You may wish to expand this code with error handling if <code>fetchUserBio()</code> can throw errors.</p>"},{"location":"examples/cookbook/light-and-dark-theme/","title":"Light & Dark Theme","text":"<p>This example demonstrates how to create dynamic theme colours using Fusion's state objects.</p>"},{"location":"examples/cookbook/light-and-dark-theme/#overview","title":"Overview","text":"<pre><code>local Fusion = --initialise Fusion here however you please!\nlocal scoped = Fusion.scoped\nlocal peek = Fusion.peek\n\nlocal Theme = {}\n\nTheme.colours = {\n    background = {\n        light = Color3.fromHex(\"FFFFFF\"),\n        dark = Color3.fromHex(\"222222\")\n    },\n    text = {\n        light = Color3.fromHex(\"222222\"),\n        dark = Color3.fromHex(\"FFFFFF\")\n    }\n}\n\n-- Don't forget to pass this to `doCleanup` if you disable the script.\nlocal scope = scoped(Fusion)\n\nTheme.current = scope:Value(\"light\")\nTheme.dynamic = {}\nfor colour, variants in Theme.colours do\n    Theme.dynamic[colour] = scope:Computed(function(use)\n        return variants[use(Theme.current)]\n    end)\nend\n\nTheme.current:set(\"light\")\nprint(peek(Theme.dynamic.background)) --&gt; 255, 255, 255\n\nTheme.current:set(\"dark\")\nprint(peek(Theme.dynamic.background)) --&gt; 34, 34, 34\n</code></pre>"},{"location":"examples/cookbook/light-and-dark-theme/#explanation","title":"Explanation","text":"<p>To begin, this example defines a set of colours with light and dark variants.</p> <pre><code>Theme.colours = {\n    background = {\n        light = Color3.fromHex(\"FFFFFF\"),\n        dark = Color3.fromHex(\"222222\")\n    },\n    text = {\n        light = Color3.fromHex(\"222222\"),\n        dark = Color3.fromHex(\"FFFFFF\")\n    }\n}\n</code></pre> <p>A <code>Value</code> object stores which variant is in use right now.</p> <pre><code>Theme.current = scope:Value(\"light\")\n</code></pre> <p>Finally, each colour is turned into a <code>Computed</code>, which dynamically pulls the desired variant from the list.</p> <pre><code>Theme.dynamic = {}\nfor colour, variants in Theme.colours do\n    Theme.dynamic[colour] = scope:Computed(function(use)\n        return variants[use(Theme.current)]\n    end)\nend\n</code></pre> <p>This allows other code to easily access theme colours from <code>Theme.dynamic</code>.</p> <pre><code>Theme.current:set(\"light\")\nprint(peek(Theme.dynamic.background)) --&gt; 255, 255, 255\n\nTheme.current:set(\"dark\")\nprint(peek(Theme.dynamic.background)) --&gt; 34, 34, 34\n</code></pre>"},{"location":"examples/cookbook/loading-spinner/","title":"Loading Spinner","text":"<p>This example implements a procedural spinning animation using Fusion's Roblox APIs.</p>"},{"location":"examples/cookbook/loading-spinner/#overview","title":"Overview","text":"<pre><code>local RunService = game:GetService(\"RunService\")\nlocal Players = game:GetService(\"Players\")\n\nlocal Fusion = -- initialise Fusion here however you please!\nlocal scoped = Fusion.scoped\nlocal Children = Fusion.Children\ntype UsedAs&lt;T&gt; = Fusion.UsedAs&lt;T&gt;\n\nlocal SPIN_DEGREES_PER_SECOND = 180\nlocal SPIN_SIZE = 50\n\nlocal function Spinner(\n    scope: Fusion.Scope,\n    props: {\n        Layout: {\n            LayoutOrder: UsedAs&lt;number&gt;?,\n            Position: UsedAs&lt;UDim2&gt;?,\n            AnchorPoint: UsedAs&lt;Vector2&gt;?,\n            ZIndex: UsedAs&lt;number&gt;?\n        },\n        CurrentTime: UsedAs&lt;number&gt;,\n    }\n): Fusion.Child\n    return scope:New \"ImageLabel\" {\n        Name = \"Spinner\",\n\n        LayoutOrder = props.Layout.LayoutOrder,\n        Position = props.Layout.Position,\n        AnchorPoint = props.Layout.AnchorPoint,\n        ZIndex = props.Layout.ZIndex,\n\n        Size = UDim2.fromOffset(SPIN_SIZE, SPIN_SIZE),\n\n        BackgroundTransparency = 1,\n        Image = \"rbxassetid://your-loading-spinner-image\", -- replace this!\n\n        Rotation = scope:Computed(function(use)\n            return (use(props.CurrentTime) * SPIN_DEGREES_PER_SECOND) % 360\n        end)\n    }\nend\n\n-- Don't forget to pass this to `doCleanup` if you disable the script.\nlocal scope = scoped(Fusion, {\n    Spinner = Spinner\n})\n\nlocal currentTime = scope:Value(os.clock())\ntable.insert(scope,\n    RunService.RenderStepped:Connect(function()\n        currentTime:set(os.clock())\n    end)\n)\n\nlocal gui = scope:New \"ScreenGui\" {\n    Name = \"SpinnerGui\",\n    Parent = Players.LocalPlayer:WaitForChild(\"PlayerGui\"),\n\n    [Children] = scope:Spinner {\n        Layout = {\n            Position = UDim2.fromScale(0.5, 0.5),\n            AnchorPoint = Vector2.new(0.5, 0.5),\n            Size = UDim2.fromOffset(50, 50)\n        },\n        CurrentTime = currentTime\n    }\n}\n</code></pre>"},{"location":"examples/cookbook/loading-spinner/#explanation","title":"Explanation","text":"<p>The <code>Spinner</code> components implements the animation for the loading spinner. It's largely a standard Fusion component definition.</p> <p>The main thing to note is that it asks for a <code>CurrentTime</code> property.</p> <pre><code>local function Spinner(\n    scope: Fusion.Scope,\n    props: {\n        Layout: {\n            LayoutOrder: UsedAs&lt;number&gt;?,\n            Position: UsedAs&lt;UDim2&gt;?,\n            AnchorPoint: UsedAs&lt;Vector2&gt;?,\n            ZIndex: UsedAs&lt;number&gt;?\n        },\n        CurrentTime: UsedAs&lt;number&gt;,\n    }\n): Fusion.Child\n</code></pre> <p>The <code>CurrentTime</code> is used to drive the rotation of the loading spinner.</p> <pre><code>        Rotation = scope:Computed(function(use)\n            return (use(props.CurrentTime) * SPIN_DEGREES_PER_SECOND) % 360\n        end)\n</code></pre> <p>That's all that's required for the <code>Spinner</code> component.</p> <p>Later on, the example creates a <code>Value</code> object that will store the current time, and starts a process to keep it up to date.</p> <pre><code>local currentTime = scope:Value(os.clock())\ntable.insert(scope,\n    RunService.RenderStepped:Connect(function()\n        currentTime:set(os.clock())\n    end)\n)\n</code></pre> <p>This can then be passed in as <code>CurrentTime</code> when the <code>Spinner</code> is created.</p> <pre><code>scope:Spinner {\n    Layout = {\n        Position = UDim2.fromScale(0.5, 0.5),\n        AnchorPoint = Vector2.new(0.5, 0.5),\n        Size = UDim2.fromOffset(50, 50)\n    },\n    CurrentTime = currentTime\n}\n</code></pre>"},{"location":"examples/cookbook/player-list/","title":"Player List","text":"<p>This shows how to use Fusion's Roblox API to create a simple, dynamically updating player list.</p>"},{"location":"examples/cookbook/player-list/#overview","title":"Overview","text":"<pre><code>local Players = game:GetService(\"Players\")\n\nlocal Fusion = -- initialise Fusion here however you please!\nlocal scoped = Fusion.scoped\nlocal Children = Fusion.Children\ntype UsedAs&lt;T&gt; = Fusion.UsedAs&lt;T&gt;\n\nlocal function PlayerList(\n    scope: Fusion.Scope,\n    props: {\n        Players: UsedAs&lt;{Player}&gt;\n    }\n): Fusion.Child\n    return scope:New \"Frame\" {\n        Name = \"PlayerList\",\n\n        Position = UDim2.fromScale(1, 0),\n        AnchorPoint = Vector2.new(1, 0),\n        Size = UDim2.fromOffset(300, 0),\n        AutomaticSize = \"Y\",\n\n        BackgroundTransparency = 0.5,\n        BackgroundColor3 = Color3.new(0, 0, 0),\n\n        [Children] = {\n            scope:New \"UICorner\" {\n                CornerRadius = UDim.new(0, 8)\n            },\n            scope:New \"UIListLayout\" {\n                SortOrder = \"Name\",\n                FillDirection = \"Vertical\"\n            },\n\n            scope:ForValues(props.Players, function(use, scope, player)\n                return scope:New \"TextLabel\" {\n                    Name = \"PlayerListRow: \" .. player.DisplayName,\n\n                    Size = UDim2.new(1, 0, 0, 25),\n                    BackgroundTransparency = 1,\n\n                    Text = player.DisplayName,\n                    TextColor3 = Color3.new(1, 1, 1),\n                    Font = Enum.Font.GothamMedium,\n                    TextSize = 16,\n                    TextXAlignment = \"Right\",\n                    TextTruncate = \"AtEnd\",\n\n                    [Children] = scope:New \"UIPadding\" {\n                        PaddingLeft = UDim.new(0, 10),\n                        PaddingRight = UDim.new(0, 10)\n                    }\n                }\n            end)\n        }\n    }\nend\n\n-- Don't forget to pass this to `doCleanup` if you disable the script.\nlocal scope = scoped(Fusion, {\n    PlayerList = PlayerList\n})\n\nlocal players = scope:Value(Players:GetPlayers())\nlocal function updatePlayers()\n    players:set(Players:GetPlayers())\nend\ntable.insert(scope, {\n    Players.PlayerAdded:Connect(updatePlayers),\n    Players.PlayerRemoving:Connect(updatePlayers)\n})\n\nlocal gui = scope:New \"ScreenGui\" {\n    Name = \"PlayerListGui\",\n    Parent = Players.LocalPlayer:FindFirstChildOfClass(\"PlayerGui\"),\n\n    [Children] = scope:PlayerList {\n        Players = players\n    }\n}\n</code></pre>"},{"location":"examples/cookbook/player-list/#explanation","title":"Explanation","text":"<p>The <code>PlayerList</code> component is designed to be simple and self-contained. The only thing it needs is a <code>Players</code> list - it handles everything else, including its position, size, appearance and behaviour.</p> <pre><code>local function PlayerList(\n    scope: Fusion.Scope,\n    props: {\n        Players: UsedAs&lt;{Player}&gt;\n    }\n): Fusion.Child\n</code></pre> <p>After creating a vertically expanding Frame with some style and layout added, it turns the <code>Players</code> into a series of text labels using <code>ForValues</code>, which will automatically create and remove them as the <code>Players</code> list changes.</p> <pre><code>            scope:ForValues(props.Players, function(use, scope, player)\n                return scope:New \"TextLabel\" {\n                    Name = \"PlayerListRow: \" .. player.DisplayName,\n\n                    Size = UDim2.new(1, 0, 0, 25),\n                    BackgroundTransparency = 1,\n\n                    Text = player.DisplayName,\n                    TextColor3 = Color3.new(1, 1, 1),\n                    Font = Enum.Font.GothamMedium,\n                    TextSize = 16,\n                    TextXAlignment = \"Right\",\n                    TextTruncate = \"AtEnd\",\n\n                    [Children] = scope:New \"UIPadding\" {\n                        PaddingLeft = UDim.new(0, 10),\n                        PaddingRight = UDim.new(0, 10)\n                    }\n                }\n            end)\n</code></pre> <p>That's all that the <code>PlayerList</code> component has to do.</p> <p>Later on, the code creates a <code>Value</code> object to store a list of players, and update it every time a player joins or leaves the game.</p> <pre><code>local players = scope:Value(Players:GetPlayers())\nlocal function updatePlayers()\n    players:set(Players:GetPlayers())\nend\ntable.insert(scope, {\n    Players.PlayerAdded:Connect(updatePlayers),\n    Players.PlayerRemoving:Connect(updatePlayers)\n})\n</code></pre> <p>That object can then be passed in as <code>Players</code> when creating the <code>PlayerList</code>.</p> <pre><code>local gui = scope:New \"ScreenGui\" {\n    Name = \"PlayerListGui\",\n    Parent = Players.LocalPlayer:FindFirstChildOfClass(\"PlayerGui\"),\n\n    [Children] = scope:PlayerList {\n        Players = players\n    }\n}\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Welcome to the Fusion tutorial section! Here, you'll learn how to build great things with Fusion, even if you're a complete newcomer to the library.</p> <p>You'll not only learn how Fusion's features work, but you'll also be presented with wisdom from those who've worked with some of the largest Fusion codebases today.</p> <p>But first, some advice from the maintainers...</p> <p> Fusion is pre-1.0 software. </p> <p>We (the maintainers and contributors) work hard to keep releases bug-free and relatively complete, so it should be safe to use in production. Many people already do, and report fantastic results!</p> <p>However, we mark Fusion as pre-1.0 because we are working on the design of the library itself. We strive for the best library design we can deliver, which means breaking changes are common and sweeping.</p> <p>With Fusion, you should expect:</p> <ul> <li>upgrades to be frictionful, requiring code to be rethought</li> <li>features to be superseded or removed across versions</li> <li>advice or best practices to change over time</li> </ul> <p>You should also expect:</p> <ul> <li>careful consideration around breakage, even though we reserve the right to   do it</li> <li>clear communication ahead of any major changes</li> <li>helpful advice to answer your questions and ease your porting process</li> </ul> <p>We hope you enjoy using Fusion!</p>"},{"location":"tutorials/#what-you-need-to-know","title":"What You Need To Know","text":"<p>These tutorials assume:</p> <ul> <li>That you're comfortable with the Luau scripting language.<ul> <li>These tutorials aren't an introduction to Luau! If you'd like to learn, check out the Roblox documentation.</li> </ul> </li> <li>That - if you're using Roblox features - you're familiar with how Roblox works.<ul> <li>You don't have to be an expert! Knowing about basic instances, events and data types will be good enough.</li> </ul> </li> </ul> <p>Based on your existing knowledge, you may find some tutorials easier or harder. Don't be discouraged - Fusion's built to be easy to learn, but it may still take a bit of time to absorb some concepts. Learn at a pace which is right for you.</p>"},{"location":"tutorials/animation/springs/","title":"Springs","text":"<p>Springs follow the value of other state objects using a physical spring simulation. This can be used for 'springy' effects, or for smoothing out movement naturally without abrupt changes in direction.</p>"},{"location":"tutorials/animation/springs/#usage","title":"Usage","text":"<p>To create a new spring object, call <code>scope:Spring()</code> and pass it a state object to move towards:</p> <pre><code>local goal = scope:Value(0)\nlocal animated = scope:Spring(goal)\n</code></pre> <p>The spring will smoothly follow the 'goal' state object over time.</p> <p>As with other state objects, you can <code>peek()</code> at its value at any time:</p> <pre><code>print(peek(animated)) --&gt; 0.26425...\n</code></pre> <p>To configure how the spring moves, you can provide a speed and damping ratio to use. Both are optional, and both can be state objects if desired:</p> <pre><code>local goal = scope:Value(0)\nlocal speed = 25\nlocal damping = scope:Value(0.5)\nlocal animated = scope:Spring(goal, speed, damping)\n</code></pre> <p>You can also set the position and velocity of the spring at any time.</p> <pre><code>animated:setPosition(5) -- teleport the spring to 5\nanimated:setVelocity(2) -- from here, move 2 units/second\n</code></pre> <p>You can use many different kinds of values with springs, not just numbers. Vectors, CFrames, Color3s, UDim2s and other number-based types are supported; each number inside the type is animated individually.</p> <pre><code>local goalPosition = scope:Value(UDim2.new(0.5, 0, 0, 0))\nlocal animated = scope:Spring(goalPosition, 25, 0.5)\n</code></pre>"},{"location":"tutorials/animation/springs/#damping-ratio","title":"Damping Ratio","text":"<p>The damping ratio (a.k.a damping) of the spring changes the friction in the physics simulation. Lower values allow the spring to move freely and oscillate up and down, while higher values restrict movement.</p>"},{"location":"tutorials/animation/springs/#zero-damping","title":"Zero damping","text":"<p>Zero damping means no friction is applied, so the spring will oscillate forever without losing energy. This is generally not useful.</p>"},{"location":"tutorials/animation/springs/#underdamping","title":"Underdamping","text":"<p>A damping between 0 and 1 means some friction is applied. The spring will still oscillate, but it will lose energy and eventually settle at the goal.</p>"},{"location":"tutorials/animation/springs/#critical-damping","title":"Critical damping","text":"<p>A damping of exactly 1 means just enough friction is applied to stop the spring from oscillating. It reaches its goal as quickly as possible without going past.</p> <p>This is also commonly known as critical damping.</p>"},{"location":"tutorials/animation/springs/#overdamping","title":"Overdamping","text":"<p>A damping above 1 applies excessive friction to the spring. The spring behaves like it's moving through honey, glue or some other viscous fluid.</p> <p>Overdamping reduces the effect of velocity changes, and makes movement more rigid.</p>"},{"location":"tutorials/animation/springs/#speed","title":"Speed","text":"<p>The speed of the spring scales how much time it takes for the spring to move. Doubling the speed makes it move twice as fast; halving the speed makes it move twice as slow.</p> <p> </p>"},{"location":"tutorials/animation/springs/#interruption","title":"Interruption","text":"<p>Springs do not share the same interruption problems as tweens. When the goal changes, springs are guaranteed to preserve both position and velocity, reducing jank:</p> <p> </p> <p>This also means springs are suitable for following rapidly changing values:</p> <p> </p>"},{"location":"tutorials/animation/tweens/","title":"Tweens","text":"<p>Tweens follow the value of other state objects using a pre-made animation curve. This can be used for basic, predictable animations.</p>"},{"location":"tutorials/animation/tweens/#usage","title":"Usage","text":"<p>To create a new tween object, call <code>scope:Tween()</code> and pass it a state object to move towards:</p> <pre><code>local goal = scope:Value(0)\nlocal animated = scope:Tween(goal)\n</code></pre> <p>The tween will smoothly follow the 'goal' state object over time.</p> <p>As with other state objects, you can <code>peek()</code> at its value at any time:</p> <pre><code>print(peek(animated)) --&gt; 0.26425...\n</code></pre> <p>To configure how the tween moves, you can provide a TweenInfo to change the shape of the animation curve. It's optional, and it can be a state object if desired:</p> <pre><code>local goal = scope:Value(0)\nlocal style = TweenInfo.new(0.5, Enum.EasingStyle.Quad)\nlocal animated = scope:Tween(goal, style)\n</code></pre> <p>You can use many different kinds of values with tweens, not just numbers. Vectors, CFrames, Color3s, UDim2s and other number-based types are supported; each number inside the type is animated individually.</p> <pre><code>local goalPosition = scope:Value(UDim2.new(0.5, 0, 0, 0))\nlocal animated = scope:Tween(goalPosition, TweenInfo.new(0.5, Enum.EasingStyle.Quad))\n</code></pre>"},{"location":"tutorials/animation/tweens/#time","title":"Time","text":"<p>The first parameter of <code>TweenInfo</code> is time. This specifies how long it should take for the value to animate to the goal, in seconds.</p> <p> </p>"},{"location":"tutorials/animation/tweens/#easing-style","title":"Easing Style","text":"<p>The second parameter of <code>TweenInfo</code> is easing style. By setting this to various <code>Enum.EasingStyle</code> values, you can select different pre-made animation curves.</p> <p> </p>"},{"location":"tutorials/animation/tweens/#easing-direction","title":"Easing Direction","text":"<p>The third parameter of <code>TweenInfo</code> is easing direction. This can be set to one of three values to control how the tween starts and stops:</p> <ul> <li><code>Enum.EasingDirection.Out</code> makes the tween animate out smoothly.</li> <li><code>Enum.EasingDirection.In</code> makes the tween animate in smoothly.</li> <li><code>Enum.EasingDirection.InOut</code> makes the tween animate in and out smoothly.</li> </ul> <p> </p>"},{"location":"tutorials/animation/tweens/#repeats","title":"Repeats","text":"<p>The fourth parameter of <code>TweenInfo</code> is repeat count. This can be used to loop the animation a number of times.</p> <p>Setting the repeat count to a negative number causes it to loop infinitely. This is not generally useful for transition animations.</p> <p> </p>"},{"location":"tutorials/animation/tweens/#reversing","title":"Reversing","text":"<p>The fifth parameter of <code>TweenInfo</code> is a reversing option. When enabled, the animation will include a reverse motion, before snapping to the goal at the end.</p> <p>This is not typically useful.</p> <p> </p>"},{"location":"tutorials/animation/tweens/#delay","title":"Delay","text":"<p>The sixth and final parameter of <code>TweenInfo</code> is delay. Increasing this delay adds empty space before the beginning of the animation curve.</p> <p>It's important to note this is not the same as a true delay. This option does not delay the input signal - it only makes the tween animation longer.</p> <p> </p>"},{"location":"tutorials/animation/tweens/#interruption","title":"Interruption","text":"<p>Because tweens are built from pre-made, fixed animation curves, you should avoid interrupting those animation curves before they're finished.</p> <p>Interrupting a tween halfway through leads to abrupt changes in velocity, which can cause your animation to feel janky:</p> <p> </p> <p>Tweens also can't track constantly changing targets very well. That's because the tween is always getting interrupted as it gets started, so it never has time to play out much of its animation.</p> <p> </p> <p>These issues arise because tweens don't 'remember' their previous velocity when they start animating towards a new goal. If you need velocity to be remembered, it's a much better idea to use springs, which can preserve their momentum.</p>"},{"location":"tutorials/best-practices/callbacks/","title":"Callbacks","text":"<p>Normally, components are controlled by the code creating them. This is called top-down control, and is the primary flow of control in Fusion.</p> <p> </p> <p>However, sometimes components need to talk back to their controlling code, for example to report when button clicks occur.</p>"},{"location":"tutorials/best-practices/callbacks/#in-luau","title":"In Luau","text":"<p>Callbacks are functions which you pass into other functions. They're useful because they allow the function to 'call back' into your code, so your code can do something in response:</p> <pre><code>local function printMessage()\n    print(\"Hello, world!\")\nend\n\n-- Here, we're passing `printMessage` as a callback\n-- `task.delay` will call it after 5 seconds\ntask.delay(5, printMessage)\n</code></pre> <p>If your function accepts a callback, then you can call it like any other function. Luau will execute the function, then return to your code.</p> <p>In this example, the <code>fiveTimes</code> function calls a callback five times:</p> Luau codeOutput <pre><code>local function fiveTimes(\n    callback: (number) -&gt; ()\n)\n    for x=1, 5 do\n        callback(x)\n    end\nend\n\nfiveTimes(function(num)\n    print(\"The number is\", num)\nend)\n</code></pre> <pre><code>The number is 1\nThe number is 2\nThe number is 3\nThe number is 4\nThe number is 5\n</code></pre>"},{"location":"tutorials/best-practices/callbacks/#in-fusion","title":"In Fusion","text":"<p>Components can use callbacks the same way. Consider this button component; when the button is clicked, the button needs to run some external code:</p> <pre><code>local function Button(\n    scope: Fusion.Scope,\n    props: {\n        Position: UsedAs&lt;UDim2&gt;?,\n        Size: UsedAs&lt;UDim2&gt;?,\n        Text: UsedAs&lt;string&gt;?\n    }\n)\n    return scope:New \"TextButton\" {\n        BackgroundColor3 = Color3.new(0.25, 0.5, 1),\n        Position = props.Position,\n        Size = props.Size,\n\n        Text = props.Text,\n        TextColor3 = Color3.new(1, 1, 1),\n\n        [OnEvent \"Activated\"] = -- ???\n    }\nend\n</code></pre> <p>It can ask the controlling code to provide an <code>OnClick</code> callback in <code>props</code>.</p> <pre><code>local button = scope:Button {\n    Text = \"Hello, world!\",\n    OnClick = function()\n        print(\"The button was clicked\")\n    end\n}\n</code></pre> <p>Assuming that callback is passed in, the callback can be passed directly into <code>[OnEvent]</code>, because <code>[OnEvent]</code> accepts functions. It can even be optional - Luau won't add the key to the table if the value is <code>nil</code>.</p> <pre><code>local function Button(\n    scope: Fusion.Scope,\n    props: {\n        Position: UsedAs&lt;UDim2&gt;?,\n        Size: UsedAs&lt;UDim2&gt;?,\n        Text: UsedAs&lt;string&gt;?,\n        OnClick: (() -&gt; ())?\n    }\n)\n    return scope:New \"TextButton\" {\n        BackgroundColor3 = Color3.new(0.25, 0.5, 1),\n        Position = props.Position,\n        Size = props.Size,\n\n        Text = props.Text,\n        TextColor3 = Color3.new(1, 1, 1),\n\n        [OnEvent \"Activated\"] = props.OnClick\n    }\nend\n</code></pre> <p>Alternatively, we can call <code>props.OnClick</code> manually, which is useful if you want to do your own processing first:</p> <pre><code>local function Button(\n    scope: Fusion.Scope,\n    props: {\n        Position: UsedAs&lt;UDim2&gt;?,\n        Size: UsedAs&lt;UDim2&gt;?,\n        Text: UsedAs&lt;string&gt;?,\n        Disabled: UsedAs&lt;boolean&gt;?,\n        OnClick: (() -&gt; ())?\n    }\n)\n    return scope:New \"TextButton\" {\n        BackgroundColor3 = Color3.new(0.25, 0.5, 1),\n        Position = props.Position,\n        Size = props.Size,\n\n        Text = props.Text,\n        TextColor3 = Color3.new(1, 1, 1),\n\n        [OnEvent \"Activated\"] = function()\n            if props.OnClick ~= nil and not peek(props.Disabled) then\n                props.OnClick()\n            end\n        end\n    }\nend\n</code></pre> <p>This is the primary way components talk to their controlling code in Fusion.</p>"},{"location":"tutorials/best-practices/callbacks/#children-callbacks","title":"Children Callbacks","text":"<p>There's a special kind of callback that's often used when you need more control over the children you're putting inside of a component.</p> <p>When your component asks for <code>[Children]</code>, the controlling code will construct some children for you ahead of time, and pass it into that <code>[Children]</code> key. You don't have any control over what that process looks like.</p> <pre><code>-- This snippet...\nlocal dialog = scope:Dialog {\n    [Children] = {\n        scope:Button {\n            Text = \"Hello, world!\" \n        },\n        scope:Text {\n            Text = \"I am pre-fabricated!\" \n        }\n    }\n}\n\n-- ...is equivalent to this code.\nlocal children = {\n    scope:Button {\n        Text = \"Hello, world!\" \n    },\n    scope:Text {\n        Text = \"I am pre-fabricated!\" \n    }\n}\n\nlocal dialog = scope:Dialog {\n    [Children] = children\n}\n</code></pre> <p>However, if your component asks for a callback instead, you can create those children on demand, as many times as you'd like, with whatever parameters you want to pass in.</p> <p>This callback should be given a descriptive name like <code>Build</code>, <code>Render</code>, or whatever terminology fits your code base. Try and be consistent across all of your components.</p> <pre><code>local dialog = scope:Dialog {\n    -- Use a `scope` parameter here so that the component can change when these\n    -- children are destroyed if it needs to. This is especially important for\n    -- components that create multiple sets of children over time.\n    Build = function(scope)\n        return {\n            scope:Button {\n                Text = \"Hello, world!\" \n            },\n            scope:Text {\n                Text = \"I am created on the fly!\" \n            }\n        }\n    end\n}\n</code></pre> <p>Warning</p> <p>Don't use <code>[Children]</code> to store a function. In general, avoid using special keys unless you're actually passing the values through, because changing how a special key appears to behave can make code confusing to follow.</p> <p>In this case, using a dedicated naming convention like <code>Build</code> ensures that users understand that their children are not being created ahead of time.</p> <p>Children callbacks are especially useful if the controlling code needs more information to build the rest of the UI. For example, you might want to share some layout information so children can fit into the component more neatly.</p> <pre><code>local dialog = scope:Dialog {\n    Build = function(scope, textSize)\n        return {\n            scope:Button {\n                Text = \"Hello, world!\",\n                TextSize = textSize\n            },\n            scope:Text {\n                Text = \"I am created on the fly!\",\n                TextSize = textSize\n            }\n        }\n    end\n}\n</code></pre> <p>This is also useful for sharing values to all children, which will be covered on a later page.</p>"},{"location":"tutorials/best-practices/components/","title":"Components","text":"<p>You can use functions to create self-contained, reusable blocks of code. In the world of UI, you may think of them as components - though they can be used for much more than just UI.</p> <p>For example, consider this function, which generates a button based on some <code>props</code> the user passes in:</p> <pre><code>type UsedAs&lt;T&gt; = Fusion.UsedAs&lt;T&gt;\n\nlocal function Button(\n    scope: Fusion.Scope,\n    props: {\n        Position: UsedAs&lt;UDim2&gt;?,\n        AnchorPoint: UsedAs&lt;Vector2&gt;?,\n        Size: UsedAs&lt;UDim2&gt;?,\n        LayoutOrder: UsedAs&lt;number&gt;?,\n        ButtonText: UsedAs&lt;string&gt;\n    }\n)\n    return scope:New \"TextButton\" {\n        BackgroundColor3 = Color3.new(0, 0.25, 1),\n        Position = props.Position,\n        AnchorPoint = props.AnchorPoint,\n        Size = props.Size,\n        LayoutOrder = props.LayoutOrder,\n\n        Text = props.ButtonText,\n        TextSize = 28,\n        TextColor3 = Color3.new(1, 1, 1),\n\n        [Children] = UICorner { CornerRadius = UDim2.new(0, 8) }\n    }\nend\n</code></pre> <p>You can call this function later to generate as many buttons as you need.</p> <pre><code>local helloBtn = Button(scope, {\n    ButtonText = \"Hello\",\n    Size = UDim2.fromOffset(200, 50)\n})\n\nhelloBtn.Parent = Players.LocalPlayer.PlayerGui.ScreenGui\n</code></pre> <p>Since the <code>scope</code> is the first parameter, it can even be used with <code>scoped()</code> syntax.</p> <pre><code>local scope = scoped(Fusion, {\n    Button = Button\n})\n\nlocal helloBtn = scope:Button {\n    ButtonText = \"Hello\",\n    Size = UDim2.fromOffset(200, 50)\n}\n\nhelloBtn.Parent = Players.LocalPlayer.PlayerGui.ScreenGui\n</code></pre> <p>This is the primary way of writing components in Fusion. You create functions that accept <code>scope</code> and <code>props</code>, then return some content from them.</p>"},{"location":"tutorials/best-practices/components/#properties","title":"Properties","text":"<p>If you don't say what <code>props</code> should contain, it might be hard to figure out how to use it.</p> <p>You can specify your list of properties by adding a type to <code>props</code>, which gives you useful autocomplete and type checking.</p> <pre><code>local function Cake(\n    -- ... some stuff here ...\n    props: {\n        Size: Vector3,\n        Colour: Color3,\n        IsTasty: boolean\n    }\n)\n    -- ... some other stuff here ...\nend\n</code></pre> <p>Note that the above code only accepts constant values, not state objects. If you want to accept either a constant or a state object, you can use the  <code>UsedAs</code> type.</p> <pre><code>type UsedAs&lt;T&gt; = Fusion.UsedAs&lt;T&gt;\n\nlocal function Cake(\n    -- ... some stuff here ...\n    props: {\n        Size: UsedAs&lt;Vector3&gt;,\n        Colour: UsedAs&lt;Color3&gt;,\n        IsTasty: UsedAs&lt;boolean&gt;\n    }\n)\n    -- ... some other stuff here ...\nend\n</code></pre> <p>This is usually what you want, because it means the user can easily switch a property to dynamically change over time, while still writing properties normally when they don't change over time. You can mostly treat <code>UsedAs</code> properties like they're state objects, because functions like <code>peek()</code> and <code>use()</code> automatically choose the right behaviour for you.</p> <p>You can use the rest of Luau's type checking features to do more complex things, like making certain properties optional, or restricting that values are valid for a given property. Go wild!</p> <p>Be mindful of the angle brackets</p> <p>Remember that, when working with <code>UsedAs</code>, you should be mindful of whether you're putting things inside the angled brackets, or outside of them. Putting some things inside of the angle brackets can change their meaning, compared to putting them outside of the angle brackets.</p> <p>Consider these two type definitions carefully:</p> <pre><code>-- A Vector3, or a state object storing Vector3, or nil.\nUsedAs&lt;Vector3&gt;?\n\n-- A Vector3?, or a state object storing Vector3?\nUsedAs&lt;Vector3?&gt;\n</code></pre> <p>The first type is best for optional properties, where you provide a default value if it isn't specified by the user. If the user does specify it, they're forced to always give a valid value for it.</p> <p>The second type is best if the property understands <code>nil</code> as a valid value. This means the user can set it to <code>nil</code> at any time.</p>"},{"location":"tutorials/best-practices/components/#scopes","title":"Scopes","text":"<p>In addition to <code>props</code>, you should also ask for a <code>scope</code>. The <code>scope</code> parameter should come first, so that your users can use <code>scoped()</code> syntax to create it.</p> <pre><code>-- barebones syntax\nlocal thing = Component(scope, { \n    -- ... some properties here ...\n})\n\n-- scoped() syntax\nlocal thing = scope:Component { \n    -- ... some properties here ...\n}\n</code></pre> <p>It's a good idea to provide a type for <code>scope</code>. This lets you specify what methods you need the scope to have.</p> <pre><code>scope: Fusion.Scope&lt;YourMethodsHere&gt;\n</code></pre> <p>If you don't know what methods to ask for, consider these two strategies.</p> <ol> <li> <p>If you use common methods (like Fusion's constructors) then it's a safe  assumption that the user will also have those methods. You can ask for a scope with those methods pre-defined.</p> <pre><code>local function Component(\n    scope: Fusion.Scope,\n    props: {}\n)\n    return scope:New \"Thing\" {\n        -- ... rest of code here ...\n    }\nend\n</code></pre> </li> <li> <p>If you need more specific or niche things that the user likely won't have (for example, components you use internally), then you should not ask for those. Instead, create a new inner scope with the methods you need.</p> <pre><code>local function Component(\n    scope: Fusion.Scope,\n    props: {}\n)\n    local scope = scope:innerScope {\n        SpecialThing1 = require(script.SpecialThing1),\n        SpecialThing2 = require(script.SpecialThing2),\n    }\n\n    return scope:SpecialThing1 {\n        -- ... rest of code here ...\n    }\nend\n</code></pre> </li> </ol> <p>If you're not sure which strategy to pick, the second is always a safe fallback, because it assumes less about your users and helps hide implementation details.</p>"},{"location":"tutorials/best-practices/components/#modules","title":"Modules","text":"<p>It's common to save different components inside of different files. There's a number of advantages to this:</p> <ul> <li>it's easier to find the source code for a specific component</li> <li>it keep each file shorter and simpler</li> <li>it makes sure components are properly independent, and can't interfere</li> <li>it encourages reusing components everywhere, not just in one file</li> </ul> <p>Here's an example of how you could split up some components into modules:</p> Main filePopUpMessageButton <pre><code>local Fusion = require(game:GetService(\"ReplicatedStorage\").Fusion)\nlocal scoped, doCleanup = Fusion.scoped, Fusion.doCleanup\n\nlocal scope = scoped(Fusion, {\n    PopUp = require(script.Parent.PopUp)\n})\n\nlocal ui = scope:New \"ScreenGui\" {\n    -- ...some properties...\n\n    [Children] = scope:PopUp {\n        Message = \"Hello, world!\",\n        DismissText = \"Close\"\n    }\n}\n</code></pre> <pre><code>local Fusion = require(game:GetService(\"ReplicatedStorage\").Fusion)\ntype UsedAs&lt;T&gt; = Fusion.UsedAs&lt;T&gt;\n\nlocal function PopUp(\n    scope: Fusion.Scope, \n    props: {\n        Message: UsedAs&lt;string&gt;,\n        DismissText: UsedAs&lt;string&gt;\n    }\n)\n    local scope = scope:innerScope {\n        Message = require(script.Parent.Message),\n        Button = require(script.Parent.Button)\n    }\n\n    return scope:New \"Frame\" {\n        -- ...some properties...\n\n        [Children] = {\n            scope:Message {\n                Text = props.Message\n            }\n            scope:Button {\n                Text = props.DismissText\n            }\n        }\n    }\nend\n\nreturn PopUp\n</code></pre> <pre><code>local Fusion = require(game:GetService(\"ReplicatedStorage\").Fusion)\ntype UsedAs&lt;T&gt; = Fusion.UsedAs&lt;T&gt;\n\nlocal function Message(\n    scope: Fusion.Scope,\n    props: {\n        Text: UsedAs&lt;string&gt;\n    }\n)\n    return scope:New \"TextLabel\" {\n        AutomaticSize = \"XY\",\n        BackgroundTransparency = 1,\n\n         -- ...some properties...\n\n        Text = props.Text\n    }\nend\n\nreturn Message\n</code></pre> <pre><code>local Fusion = require(game:GetService(\"ReplicatedStorage\").Fusion)\ntype UsedAs&lt;T&gt; = Fusion.UsedAs&lt;T&gt;\n\nlocal function Button(\n    scope: Fusion.Scope,\n    props: {\n        Text: UsedAs&lt;string&gt;\n    }\n)\n    return scope:New \"TextButton\" {\n        BackgroundColor3 = Color3.new(0.25, 0.5, 1),\n        AutoButtonColor = true,\n\n         -- ...some properties...\n\n        Text = props.Text\n    }\nend\n\nreturn Button\n</code></pre>"},{"location":"tutorials/best-practices/error-safety/","title":"Error Safety","text":"<p>Code can fail unexpectedly for many reasons. While Fusion tries to prevent many errors by design, Fusion can't stop you from trying to access data that doesn't exist, or taking actions that don't make sense to the computer.</p> <p>So, you need to be able to deal with errors that happen while your program is running.</p>"},{"location":"tutorials/best-practices/error-safety/#fatality","title":"Fatality","text":"<p>An error can be either fatal or non-fatal:</p> <ul> <li>fatal errors aren't handled by anything, so they crash your program</li> <li>non-fatal errors are handled by Fusion and let your program continue</li> </ul> <p>You're likely familiar with fatal errors. You can create them with <code>error()</code>:</p> Luau codeOutput <pre><code>print(\"before\")\nprint(\"before\")\nprint(\"before\")\n\nerror(\"Kaboom!\")\n\nprint(\"after\")\nprint(\"after\")\nprint(\"after\")\n</code></pre> <pre><code>before\nbefore\nbefore\nMain:7: Kaboom!\nStack Begin\nMain:7\nFusion.State.Computed:74 function update\nFusion.State.Computed:166 function Computed\nMain:6\nStack End\n</code></pre> <p>You can make it non-fatal by protecting the call, with <code>pcall()</code>:</p> Luau codeOutput <pre><code>print(\"before\")\nprint(\"before\")\nprint(\"before\")\n\npcall(function()\n    error(\"Kaboom!\")\nend)\n\nprint(\"after\")\nprint(\"after\")\nprint(\"after\")\n</code></pre> <pre><code>before\nbefore\nbefore\nafter\nafter\nafter\n</code></pre>"},{"location":"tutorials/best-practices/error-safety/#example","title":"Example","text":"<p>To demonstrate the difference, consider how Fusion handles errors in state objects.</p> <p>State objects always run your code in a safe environment, to ensure that an error doesn't leave your state objects in a broken configuration.</p> <p>This means you can broadly do whatever you like inside of them, and they won't cause a fatal error that stops your program from running.</p> Luau codeOutput <pre><code>print(\"before\")\nprint(\"before\")\nprint(\"before\")\n\nscope:Computed(function()\n    error(\"Kaboom!\")\nend)\n\nprint(\"after\")\nprint(\"after\")\nprint(\"after\")\n</code></pre> <pre><code>before\nbefore\nbefore\n[Fusion] Error in callback: Kaboom!\n  (ID: callbackError)\n  ---- Stack trace ----\n  Main:7\n  Fusion.State.Computed:74 function update\n  Fusion.State.Computed:166 function Computed\n  Main:6\n\nStack Begin\nStack End\nafter\nafter\nafter\n</code></pre> <p>These are non-fatal errors. You don't have to handle them, because Fusion will take all the necessary steps to ensure your program keeps running. In this case, the <code>Computed</code> object tries to roll back to the last value it had, if any.</p> <pre><code>local number = scope:Value(1)\nlocal double = scope:Computed(function(use)\n    local number = use(number)\n    assert(number ~= 3, \"I don't like the number 3\")\n    return number * 2\nend)\n\nprint(\"number:\", peek(number), \"double:\", peek(double))\n    --&gt; number: 1 double: 2\n\nnumber:set(2)\nprint(\"number:\", peek(number), \"double:\", peek(double))\n    --&gt; number: 2 double: 4\n\nnumber:set(3)\nprint(\"number:\", peek(number), \"double:\", peek(double))\n    --&gt; number: 3 double: 4\n\nnumber:set(4)\nprint(\"number:\", peek(number), \"double:\", peek(double))\n    --&gt; number: 4 double: 8\n</code></pre>"},{"location":"tutorials/best-practices/error-safety/#be-careful","title":"Be Careful","text":"<p>Just because your program continues running, doesn't mean that it will behave the way you expect it to. In the above example, the roll back gave us a nonsense answer:</p> <pre><code>--&gt; number: 3 double: 4\n</code></pre> <p>This is why it's still important to practice good error safety. If you expect an error to occur, you should always handle the error explicitly, and define what should be done about it.</p> <pre><code>local number = scope:Value(1)\nlocal double = scope:Computed(function(use)\n    local number = use(number)\n    local ok, result = pcall(function()\n        assert(number ~= 3, \"I don't like the number 3\")\n        return number * 2\n    end)\n    if ok then\n        return result\n    else\n        return \"failed: \" .. err\n    end\nend)\n</code></pre> <p>Now when the computation fails, it fails more helpfully:</p> <pre><code>--&gt; number: 3 double: failed: I don't like the number 3\n</code></pre> <p>As a general rule, your program should never error in a way that prints red text to the output.</p>"},{"location":"tutorials/best-practices/error-safety/#safe-expressions","title":"Safe Expressions","text":"<p>Functions like <code>pcall</code> and <code>xpcall</code> can be useful for catching errors. However, they can often make a lot of code clunkier, like the code above.</p> <p>To help with this, Fusion introduces safe expressions. They let you try and run a calculation, and fall back to another calculation if it fails.</p> <p><pre><code>Safe {\n    try = function()\n        return -- a value that might error during calculation\n    end,\n    fallback = function(theError)\n        return -- a fallback value if an error does occur\n    end\n}\n</code></pre> To see how <code>Safe</code> improves the readability and conciseness of your code, consider this next snippet. You can write it using <code>Safe</code>, <code>xpcall</code> and <code>pcall</code> - here's how each one looks:</p> pcallxpcallSafe <pre><code>local double = scope:Computed(function(use)\n    local ok, result = pcall(function()\n        local number = use(number)\n        assert(number ~= 3, \"I don't like the number 3\")\n        return number * 2\n    end)\n    if ok then\n        return result\n    else\n        return \"failed: \" .. err\n    end\nend)\n</code></pre> <pre><code>local double = scope:Computed(function(use)\n    local _, result = xpcall(\n        function()\n            local number = use(number)\n            assert(number ~= 3, \"I don't like the number 3\")\n            return number * 2\n        end,\n        function(err)\n            return \"failed: \" .. err\n        end\n    )\n    return result\nend)\n</code></pre> <pre><code>local double = scope:Computed(function(use)\n    return Safe {\n        try = function()\n            local number = use(number)\n            assert(number ~= 3, \"I don't like the number 3\")\n            return number * 2\n        end,\n        fallback = function(err)\n            return \"failed: \" .. err\n        end\n    }\nend)\n</code></pre> <p><code>pcall</code> is the simplest way to safely handle errors. It's not entirely convenient because you have to check the <code>ok</code> boolean before you know whether the calculation was successful, which makes it difficult to use as part of a larger expression.</p> <p><code>xpcall</code> is an improvement over <code>pcall</code>, because it lets you define the fallback value as a second function, and uses its return value as the result of the calculation whenever an error occurs. However, it still returns the <code>ok</code> boolean, which has to be explicitly discarded.</p> <p><code>Safe</code> is an improvement over <code>xpcall</code>, because it does away with the <code>ok</code> boolean altogether, and only returns the result. It also clearly labels the <code>try</code> and <code>fallback</code> functions so you can easily tell which one handles which case.</p> <p>As a result of its design, <code>Safe</code> can be used widely throughout Fusion to catch fatal errors. For example, you can use it to conditionally render error components directly as part of a larger UI:</p> <pre><code>[Children] = Safe {\n    try = function()\n        return scope:FormattedForumPost {\n            -- ... properties ...\n        }\n    end,\n    fallback = function(err)\n        return scope:ErrorPage {\n            title = \"An error occurred while showing this forum post\",\n            errorMessage = tostring(err)\n        }\n    end\n}\n</code></pre>"},{"location":"tutorials/best-practices/error-safety/#non-fatal-errors","title":"Non-Fatal Errors","text":"<p>As before, note that non-fatal errors aren't caught by <code>Safe</code>, because they do not cause the computation in <code>try()</code> to crash.</p> <pre><code>-- The `Safe` is outside the `Computed`.\n-- It will not catch the error, because the `Computed` handles the error.\nlocal result = Safe {\n    try = function()\n        scope:Computed(function()\n            error(\"Kaboom!\")\n        end)\n        return \"success\"\n    end,\n    fallback = function(err)\n        return \"fail\"\n    end\n}\n\nprint(result) --&gt; success\n</code></pre> <p>You must move the <code>Safe</code> closer to the source of the error, as discussed before.</p> <pre><code>-- The `Safe` and the the `Computed` have swapped places.\n-- The error is now caught by the `Safe` instead of the `Computed`.\nlocal result = scope:Computed(function()\n    return Safe {\n        try = function()\n            error(\"Kaboom!\")\n            return \"success\"\n        end,\n        fallback = function(err)\n            return \"fail\"\n        end\n    }\nend)\n\nprint(peek(result)) --&gt; fail\n</code></pre>"},{"location":"tutorials/best-practices/instance-handling/","title":"Instance Handling","text":"<p>Components are a good fit for Roblox instances. You can assemble complex groups of instances by combining simpler, self-contained parts.</p> <p>To ensure maximum compatibility, there are a few best practices to consider.</p>"},{"location":"tutorials/best-practices/instance-handling/#returns","title":"Returns","text":"<p>Anything you return from a component should be supported by <code>[Children]</code>.</p> <pre><code>-- returns an instance\nreturn scope:New \"Frame\" {}\n\n-- returns an array of instances\nreturn {\n    scope:New \"Frame\" {},\n    scope:New \"Frame\" {},\n    scope:New \"Frame\" {}\n}\n\n-- returns a state object containing instances\nreturn scope:ForValues({1, 2, 3}, function(use, scope, number)\n    return scope:New \"Frame\" {}\nend)\n\n-- mix of arrays, instances and state objects\nreturn {\n    scope:New \"Frame\" {},\n    {\n        scope:New \"Frame\" {},\n        scope:ForValues( ... )\n    }\n    scope:ForValues( ... )\n}\n</code></pre> <p>Returning multiple values is fragile</p> <p>Don't return multiple values directly from your function. When a function returns multiple values directly, the extra returned values can easily get lost.</p> <pre><code>local function BadThing(scope, props)\n    -- returns *multiple* instances (not surrounded by curly braces!)\n    return\n        scope:New \"Frame\" {},\n        scope:New \"Frame\" {},\n        scope:New \"Frame\" {}\nend\n\nlocal things = {\n    -- Luau doesn't let you add multiple returns to a list like this.\n    -- Only the first Frame will be added.\n    scope:BadThing {},\n    scope:New \"TextButton\" {}\n}\nprint(things) --&gt; { Frame, TextButton }\n</code></pre> <p>Instead, you should return them inside of an array. Because the array is a single return value, it won't get lost.</p> <p>If your returns are compatible with <code>[Children]</code> like above, you can insert a component anywhere you'd normally insert an instance.</p> <p>You can pass in one component on its own...</p> <pre><code>local ui = scope:New \"ScreenGui\" {\n    [Children] = scope:Button {\n        Text = \"Hello, world!\"\n    }\n}\n</code></pre> <p>...you can include components as part of an array..</p> <pre><code>local ui = scope:New \"ScreenGui\" {\n    [Children] = {\n        scope:New \"UIListLayout\" {},\n\n        scope:Button {\n            Text = \"Hello, world!\"\n        },\n\n        scope:Button {\n            Text = \"Hello, again!\"\n        }\n    }\n}\n</code></pre> <p>...and you can return them from state objects, too.</p> <pre><code>local stuff = {\"Hello\", \"world\", \"from\", \"Fusion\"}\n\nlocal ui = scope:New \"ScreenGui\" {\n    [Children] = {\n        scope:New \"UIListLayout\" {},\n\n        scope:ForValues(stuff, function(use, scope, text)\n            return scope:Button {\n                Text = text\n            }\n        end)\n    }\n}\n</code></pre>"},{"location":"tutorials/best-practices/instance-handling/#containers","title":"Containers","text":"<p>Some components, for example pop-ups, might contain lots of different content:</p> <p> </p> <p>Ideally, you would be able to reuse the pop-up 'container', while placing your own content inside.</p> <p> </p> <p>The simplest way to do this is to pass instances through to <code>[Children]</code>. For example, if you accept a table of <code>props</code>, you can add a <code>[Children]</code> key:</p> <pre><code>local function PopUp(\n    scope: Fusion.Scope,\n    props: {\n        [typeof(Children)]: Fusion.Children\n    }\n)\n    return scope:New \"Frame\" {\n        [Children] = props[Children]\n    }\nend\n</code></pre> <p>Accepting multiple instances</p> <p>If you have multiple 'slots' where you want to pass through instances, you can make other properties and give them the <code>Fusion.Children</code> type.</p> <p>Later on, when a pop-up is created, instances can now be parented into that pop-up:</p> <pre><code>scope:PopUp {\n    [Children] = {\n        scope:Label {\n            Text = \"New item collected\"\n        },\n        scope:ItemPreview {\n            Item = Items.BRICK\n        },\n        scope:Button {\n            Text = \"Add to inventory\"\n        }\n    }\n}\n</code></pre> <p>If you need to add other instances, you can still use arrays and state objects as normal. You can include instances you're given, in exactly the same way you would include any other instances.</p> <pre><code>scope:New \"Frame\" {\n    -- ... some other properties ...\n\n    [Children] = {\n        -- the component provides some children here\n        scope:New \"UICorner\" {\n            CornerRadius = UDim.new(0, 8)\n        },\n\n        -- include children from outside the component here\n        props[Children]\n    }\n}\n</code></pre>"},{"location":"tutorials/best-practices/optimisation/","title":"Optimisation","text":"<p>Fusion tries to handle your code in the smartest way it can. To help achieve the best performance, you can give Fusion more information about what you're trying to do, or avoid a few problematic scenarios that slow Fusion down.</p>"},{"location":"tutorials/best-practices/optimisation/#update-skipping","title":"Update Skipping","text":"<p>Fusion tries to skip updates when they result in 'meaningless changes'.</p> <p>TL;DR</p> <p>When your computations return values that aren't meaningfully different, Fusion doesn't bother to perform further updates.</p> <p>However, Fusion can't automatically do this for tables. So, you should  freeze every table you create, unless you need to change what's inside the  table later (for example, if it's a list that changes over time).</p> <p>This allows Fusion to apply more aggressive optimisations for free.</p>"},{"location":"tutorials/best-practices/optimisation/#example","title":"Example","text":"<p>Imagine you have a number, and you're using a computed to calculate whether it's even or odd.</p> <p>An observer is used to see how often this results in other code being run.</p> Luau codeOutput <pre><code>local number = scope:Value(1)\nlocal isEven = scope:Computed(function(use)\n    return use(number) % 2 == 0\nend)\nscope:Observer(isEven):onChange(function()\n    print(\"-&gt; isEven has changed to \" .. peek(isEven))\nend)\n\nprint(\"Number becomes 2\")\nnumber:set(2)\nprint(\"Number becomes 3\")\nnumber:set(3)\nprint(\"Number becomes 13\")\nnumber:set(13)\nprint(\"Number becomes 14\")\nnumber:set(14)\nprint(\"Number becomes 24\")\nnumber:set(24)\n</code></pre> <pre><code>Number becomes 2\n-&gt; isEven has changed to true\nNumber becomes 3\n-&gt; isEven has changed to false\nNumber becomes 13\nNumber becomes 14\n-&gt; isEven has changed to true\nNumber becomes 24\n</code></pre> <p>Notice that the observer only runs when <code>isEven</code> returns a meaningfully different value:</p> <ul> <li> <p>When the number changed from 2 to 3, <code>isEven</code> returned <code>false</code>. This is meaningfully different from the previous value of <code>isEven</code>, which was <code>true</code>. As a result, the observer is run and the printed message is seen.</p> </li> <li> <p>When the number changed from 3 to 13, <code>isEven</code> returned <code>false</code>. This is not meaningfully different from the previous value of <code>isEven</code>, which was <code>false</code>. As a result, the observer does not run, and no printed message is seen.</p> </li> </ul>"},{"location":"tutorials/best-practices/optimisation/#similarity","title":"Similarity","text":"<p>When trying to determine if a change is 'meaningless', Fusion compares the old and new values, using what's called the similarity test.</p> <p>The similarity test is a fast, approximate test that Fusion uses to guess which updates it can safely discard. If two values pass the similarity test, then you should be able to use them interchangeably without affecting most Luau code.</p> <p>In Fusion's case, if the values before and after a change are similar, then Fusion won't continue updating other code beyond that change, because those updates aren't likely to have an effect on the outcome of computations.</p> <p>Here's what the similarity test looks for:</p> <ul> <li>Different types:<ul> <li>Two values of different types are never similar to each other.</li> </ul> </li> <li>Tables:<ul> <li>Frozen tables are similar to other values when they're <code>==</code> to each other.</li> <li>Tables with a metatable are similar to other values when when they're <code>==</code> to each other.</li> <li>Other kinds of table are never similar to anything.</li> </ul> </li> <li>Userdatas:<ul> <li>Userdatas are similar to other values when they're <code>==</code> to each other.</li> </ul> </li> <li>NaN:<ul> <li>If each value does not <code>==</code> itself, then the two values are similar to  each other.</li> <li>This doesn't apply to tables or userdatas.</li> </ul> </li> <li>Any other values:<ul> <li>Two values are similar to each other when they're <code>==</code> to each other.</li> </ul> </li> </ul> <p>Roblox data types</p> <p>Roblox data types are not considered to be userdatas. Instead, the  similarity test follows <code>typeof()</code> rules when determining type.</p>"},{"location":"tutorials/best-practices/optimisation/#optimising-for-similarity","title":"Optimising For Similarity","text":"<p>With this knowledge about the similarity test, you can experiment with how  Fusion optimises different changes, and what breaks that optimisation.</p>"},{"location":"tutorials/best-practices/optimisation/#tables","title":"Tables","text":"<p>Imagine you're setting a value object to a table of theme colours. You attach an observer object to see when Fusion thinks the theme meaningfully changed.</p> Luau codeOutput <pre><code>local LIGHT_THEME = {\n    name = \"light\",\n    -- imagine theme colours in here\n}\nlocal DARK_THEME = {\n    name = \"dark\",\n    -- imagine theme colours in here\n}\nlocal currentTheme = scope:Value(LIGHT_THEME)\nscope:Observer(currentTheme):onChange(function()\n    print(\"-&gt; currentTheme changed to \" .. peek(currentTheme).name)\nend)\n\nprint(\"Set to DARK_THEME\")\ncurrentTheme:set(DARK_THEME)\nprint(\"Set to DARK_THEME\")\ncurrentTheme:set(DARK_THEME)\nprint(\"Set to LIGHT_THEME\")\ncurrentTheme:set(LIGHT_THEME)\nprint(\"Set to LIGHT_THEME\")\ncurrentTheme:set(LIGHT_THEME)\n</code></pre> <pre><code>Set to DARK_THEME\n-&gt; currentTheme changed to dark\nSet to DARK_THEME\n-&gt; currentTheme changed to dark\nSet to LIGHT_THEME\n-&gt; currentTheme changed to light\nSet to LIGHT_THEME\n-&gt; currentTheme changed to light\n</code></pre> <p>Because the <code>LIGHT_THEME</code> and <code>DARK_THEME</code> tables aren't frozen, and they don't have any metatables, Fusion will never skip over updates that change to or from those values.</p> Why won't Fusion skip those updates? <p>In Fusion, it's common to update arrays without creating a new array. This is known as mutating the array.</p> <pre><code>local drinks = scope:Value({\"beer\", \"pepsi\"})\n\ndo -- add tea\n    local array = peek(drinks)\n    table.insert(array, \"tea\") -- mutation occurs here\n    drinks:set(array) -- still the same array, so it's ==\nend\n</code></pre> <p>If Fusion skipped updates when the old and new values were <code>==</code>, then these mutating changes wouldn't cause an update.</p> <p>For that reason, Fusion doesn't skip updates for tables unless you do one of two things:</p> <ul> <li>You disable the ability to mutate the table (via <code>table.freeze</code>).</li> <li>You indicate to Fusion that this isn't plain data by adding a metatable.<ul> <li>Metatables are almost always used for OOP, where <code>==</code> is a sensible way of determining if two objects are similar.</li> <li>You can also use metatables to define how equality should work, which Fusion will respect - though Fusion expects it to be symmetric.</li> </ul> </li> </ul> <p>According to the similarity test (and the question section above), one way to skip these updates is by freezing the original tables.</p> Luau codeOutput <pre><code>local LIGHT_THEME = table.freeze {\n    name = \"light\",\n    -- imagine theme colours in here\n}\nlocal DARK_THEME = table.freeze {\n    name = \"dark\",\n    -- imagine theme colours in here\n}\nlocal currentTheme = scope:Value(LIGHT_THEME)\nscope:Observer(currentTheme):onChange(function()\n    print(\"-&gt; currentTheme changed to \" .. peek(currentTheme).name)\nend)\n\nprint(\"Set to DARK_THEME\")\ncurrentTheme:set(DARK_THEME)\nprint(\"Set to DARK_THEME\")\ncurrentTheme:set(DARK_THEME)\nprint(\"Set to LIGHT_THEME\")\ncurrentTheme:set(LIGHT_THEME)\nprint(\"Set to LIGHT_THEME\")\ncurrentTheme:set(LIGHT_THEME)\n</code></pre> <pre><code>Set to DARK_THEME\n-&gt; currentTheme changed to dark\nSet to DARK_THEME\nSet to LIGHT_THEME\n-&gt; currentTheme changed to light\nSet to LIGHT_THEME\n</code></pre> <p>Now, Fusion is confident enough to skip over the updates.</p> <p>In general, you should freeze all of your tables when working with Fusion, unless you have a reason for modifying them later on. There's almost zero cost to freezing a table, making this modification essentially free. Plus, this lets Fusion optimise your updates more aggressively, which means you spend less time running computations on average.</p>"},{"location":"tutorials/best-practices/references/","title":"References","text":"<p>At some point, you might need to refer to another part of the UI. There are various techniques that can let you do this.</p> <pre><code>local ui = scope:New \"Folder\" {\n    [Children] = {\n        scope:New \"SelectionBox\" {\n            -- the box should adorn to the part, but how do you reference it?\n            Adornee = ???,\n        },\n        scope:New \"Part\" {\n            Name = \"Selection Target\",\n        }\n    }\n}\n</code></pre>"},{"location":"tutorials/best-practices/references/#constants","title":"Constants","text":"<p>The first technique is simple - instead of creating the UI all at once, you can extract part of the UI that you want to reference later.</p> <p>In practice, that means you'll move some of the creation code into a new <code>local</code> constant, so that you can refer to it later by name.</p> <pre><code>-- the part is now constructed first, whereas before it was constructed second\nlocal selectionTarget = scope:New \"Part\" {\n    Name = \"Selection Target\",\n}\n\nlocal ui = scope:New \"Folder\" {\n    [Children] = {\n        scope:New \"SelectionBox\" {\n            Adornee = selectionTarget\n        },\n        selectionTarget\n    }\n}\n</code></pre> <p>While this is a simple and robust technique, it has some disadvantages:</p> <ul> <li>By moving parts of your UI code into different local variables, your UI will be constructed in a different order based on which local variables come first</li> <li>Refactoring code in this way can be bothersome and inelegant, disrupting the structure of the code</li> <li>You can't have two pieces of UI refer to each other cyclically</li> </ul> <p>Constants work well for trivial examples, but you should consider a more flexible technique if those disadvantages are relevant.</p>"},{"location":"tutorials/best-practices/references/#value-objects","title":"Value Objects","text":"<p>Where it's impossible or inelegant to use named constants, you can use value objects to easily set up references.</p> <p>Because their <code>:set()</code> method returns the value that's passed in, you can use <code>:set()</code> to reference part of your code without disrupting its structure:</p> <pre><code>-- `selectionTarget` will show as `nil` to all code trying to use it, until the\n-- `:set()` method is called later on.\nlocal selectionTarget: Fusion.Value&lt;Part?&gt; = scope:Value(nil)\n\nlocal ui = scope:New \"Folder\" {\n    [Children] = {\n        scope:New \"SelectionBox\" {\n            Adornee = selectionTarget\n        },\n        selectionTarget:set(\n            scope:New \"Part\" {\n                Name = \"Selection Target\",\n            }\n        )\n    }\n}\n</code></pre> <p>It's important to note that the value object will briefly be <code>nil</code> (or whichever default value you provide in the constructor). This is because it takes time to reach the <code>:set()</code> call, so any in-between code will see the <code>nil</code>.</p> <p>In the above example, the <code>Adornee</code> is briefly set to <code>nil</code>, but because <code>selectionTarget</code> is a value object, it will change to the part instance when the <code>:set()</code> method is called.</p> <p>While dealing with the brief <code>nil</code> value can be annoying, it is also useful, because this lets you refer to parts of your UI that haven't yet been created. In particular, this lets you create cyclic references.</p> <pre><code>local aliceRef: Fusion.Value&lt;Instance?&gt; = scope:Value(nil)\nlocal bobRef: Fusion.Value&lt;Instance?&gt; = scope:Value(nil)\n\n-- These two `ObjectValue` instances will refer to each other once the code has\n-- finished running.\nlocal alice = aliceRef:set(\n    scope:New \"ObjectValue\" {\n        Value = bobRef\n    }\n)\nlocal bob = bobRef:set(\n    scope:New \"ObjectValue\" {\n        Value = aliceRef\n    }\n)\n</code></pre> <p>Value objects are generally easier to work with than named constants, so they're often used as the primary way of referencing UI, but feel free to mix both techniques based on what your code needs.</p>"},{"location":"tutorials/best-practices/sharing-values/","title":"Sharing Values","text":"<p>Sometimes values are used in far-away parts of the codebase. For example, many UI elements might share theme colours for light and dark theme.</p>"},{"location":"tutorials/best-practices/sharing-values/#globals","title":"Globals","text":"<p>Typically, values are shared by placing them in modules. These modules can be required from anywhere in the codebase, and their values can be imported into any code.</p> <p>Values shared in this way are known as globals.</p> Theme.luauSomewhere else <pre><code>local Theme = {}\n\nTheme.colours = {\n    background = Color3.fromHex(\"FFFFFF\"),\n    text = Color3.fromHex(\"222222\"),\n    -- etc.\n}\n\nreturn Theme\n</code></pre> <pre><code>local Theme = require(\"path/to/Theme.luau\")\n\nlocal textColour = Theme.colours.text\nprint(textColour) --&gt; 34, 34, 34\n</code></pre> <p>In particular, you can share state objects this way, and every part of the codebase will be able to see and interact with those state objects.</p> Theme.luauSomewhere else <pre><code>local Fusion = require(\"path/to/Fusion.luau\")\n\nlocal Theme = {}\n\nTheme.colours = {\n    background = {\n        light = Color3.fromHex(\"FFFFFF\"),\n        dark = Color3.fromHex(\"222222\")\n    },\n    text = {\n        light = Color3.fromHex(\"FFFFFF\"),\n        dark = Color3.fromHex(\"222222\")\n    },\n    -- etc.\n}\n\nfunction Theme.init(\n    scope: Fusion.Scope\n)\n    Theme.currentTheme = scope:Value(\"light\")\nend\n\nreturn Theme\n</code></pre> <pre><code>local Fusion = require(\"path/to/Fusion.luau\")\nlocal scoped, peek = Fusion.scoped, Fusion.peek\n\nlocal Theme = require(\"path/to/Theme.luau\")\n\nlocal function printTheme()\n    local theme = Theme.currentTheme\n    print(\n        peek(theme), \n        if typeof(theme) == \"string\" then \"constant\" else \"state object\"\n    )\nend\n\nlocal scope = scoped(Fusion)\nTheme.init(scope)\nprintTheme() --&gt; light state object\n\nTheme.currentTheme:set(\"dark\")\nprintTheme() --&gt; dark state object\n</code></pre> <p>Globals are very straightforward to implement and can be useful, but they can quickly cause problems if not used carefully.</p>"},{"location":"tutorials/best-practices/sharing-values/#hidden-dependencies","title":"Hidden dependencies","text":"<p>When you use a global inside a block of reusable code such as a component, you are making your code dependent on another code file without declaring it to the outside world.</p> <p>To some extent, this is entirely why using globals is desirable. While it's more 'correct' to accept the <code>Theme</code> via the parameters of your function, it often means the <code>Theme</code> has to be passed down through multiple layers of functions. This is known as prop drilling and is widely considered bad practice, because it clutters up unrelated code with parameters that are only passed through functions.</p> <p>To avoid prop drilling, globals are often used, which 'hides' the dependency on that external code file. You no longer have to pass it down through parameters. However, relying too heavily on these hidden dependencies can cause your code to behave in surprising, unintuitive ways, or it can obscure what functionality is available to developers using your code.</p>"},{"location":"tutorials/best-practices/sharing-values/#hard-to-locate-writes","title":"Hard-to-locate writes","text":"<p>If you write into globals from deep inside your code base, it becomes very hard to figure out where the global is being changed from, which significantly hurts debugging.</p> <p>Generally, it's best to treat globals as read-only. If you're writing to a global, it should be coming from a single well-signposted, easy-to-find place.</p> <p>You should also keep the principles of top-down control in mind; think of globals as 'flowing down' from the root of the program. Globals are best managed from high up in the program, because they have widespread effects, so consider using callbacks to pass control up the chain, rather than managing globals directly from every part of the code base.</p>"},{"location":"tutorials/best-practices/sharing-values/#memory-management","title":"Memory management","text":"<p>In addition, globals can complicate memory management. Because every part of your code base can access them, you can't destroy globals until the very end of your program.</p> <p>In the above example, this is solved with an <code>init()</code> method which passes the main scope to <code>Theme</code>. Because <code>init()</code> is called before anything else that uses <code>Theme</code>, the objects that <code>Theme</code> creates will be added to the scope first.</p> <p>When the main scope is cleaned up, <code>doCleanup()</code> will destroy things in reverse order. This means the <code>Theme</code> objects will be cleaned up last, after everything else in the program has been cleaned up.</p> <p>This only works if you know that the main script is the only entry point in your program. If you have two scripts running concurrently which try to <code>init()</code> the <code>Theme</code> module, they will overwrite each other.</p>"},{"location":"tutorials/best-practices/sharing-values/#non-replaceable-for-testing","title":"Non-replaceable for testing","text":"<p>When your code uses a global, you're hard-coding a connection between your code and that specific global.</p> <p>This is problematic for testing; unless you're using an advanced testing framework with code injection, it's pretty much impossible to separate your code from that global code, which makes it impossible to replace global values for testing purposes.</p> <p>For example, if you wanted to write automated tests that verify light theme and dark theme are correctly applied throughout your UI, you can't replace any values stored in <code>Theme</code>.</p> <p>You might be able to write to the <code>Theme</code> by going through the normal process, but this fundamentally limits how you can test. For example, you couldn't run a test for light theme and dark theme at the same time.</p>"},{"location":"tutorials/best-practices/sharing-values/#contextuals","title":"Contextuals","text":"<p>The main drawback of globals is that they hold one value for all code. To solve this, Fusion introduces contextual values, which can be temporarily changed for the duration of a code block.</p> <p>To create a contextual, call the <code>Contextual</code> function from Fusion. It asks for a default value.</p> <pre><code>local myContextual = Contextual(\"foo\")\n</code></pre> <p>At any time, you can query its current value using the <code>:now()</code> method.</p> <pre><code>local myContextual = Contextual(\"foo\")\nprint(myContextual:now()) --&gt; foo\n</code></pre> <p>You can override the value for a limited span of time using <code>:is():during()</code>. Pass the temporary value to <code>:is()</code>, and pass a callback to <code>:during()</code>.</p> <p>While the callback is running, the contextual will adopt the temporary value.</p> <pre><code>local myContextual = Contextual(\"foo\")\nprint(myContextual:now()) --&gt; foo\n\nmyContextual:is(\"bar\"):during(function()\n    print(myContextual:now()) --&gt; bar\nend)\n\nprint(myContextual:now()) --&gt; foo\n</code></pre> <p>By storing widely-used values inside contextuals, you can isolate different code paths from each other, while retaining the easy, hidden referencing that globals offer. This makes testing and memory management significantly easier, and helps you locate which code is modifying any shared values.</p> <p>To demonstrate, the <code>Theme</code> example can be rewritten to use contextuals.</p> Theme.luauSomewhere else <pre><code>local Fusion = require(\"path/to/Fusion.luau\")\nlocal Contextual = Fusion.Contextual\n\nlocal Theme = {}\n\nTheme.colours = {\n    background = {\n        light = Color3.fromHex(\"FFFFFF\"),\n        dark = Color3.fromHex(\"222222\")\n    },\n    text = {\n        light = Color3.fromHex(\"FFFFFF\"),\n        dark = Color3.fromHex(\"222222\")\n    },\n    -- etc.\n}\n\nTheme.currentTheme = Contextual(\"light\")\n\nreturn Theme\n</code></pre> <pre><code>local Fusion = require(\"path/to/Fusion.luau\")\nlocal scoped, peek = Fusion.scoped, Fusion.peek\n\nlocal Theme = require(\"path/to/Theme.luau\")\n\nlocal function printTheme()\n    local theme = Theme.currentTheme:now()\n    print(\n        peek(theme), \n        if typeof(theme) == \"string\" then \"constant\" else \"state object\"\n    )\nend\n\nprintTheme() --&gt; light constant\n\nlocal scope = scoped(Fusion)\nlocal override = scope:Value(\"light\")\nTheme.currentTheme:is(override):during(function()\n    printTheme()  --&gt; light state object\n    override:set(\"dark\")\n    printTheme() --&gt; dark state object\nend)\n\nprintTheme() --&gt; light constant\n</code></pre> <p>In this rewritten example, <code>Theme</code> no longer requires an <code>init()</code> function, because - instead of defining a state object globally - <code>Theme</code> only defines <code>\"light\"</code> as the default value.</p> <p>You're expected to replace the default value with a state object when you want to make the theme dynamic. This has a number of benefits:</p> <ul> <li> <p>Because the override is time-limited to one span of your code, you can have multiple scripts running at the same time with completely different overrides.</p> </li> <li> <p>It also explicitly places your code in charge of memory management, because you're creating the object yourself.</p> </li> <li> <p>It's easy to locate where changes are coming from, because you can look for the nearest <code>:is():during()</code> call. Optionally, you could share a limited,  read-only version of the value, while retaining private access to write to the  value wherever you're overriding the contextual from.</p> </li> <li> <p>Testing becomes much simpler; you can override the contextual for different parts of your testing, without ever having to inject code, and without altering how you read and override the contextual in your production code.</p> </li> </ul> <p>It's still possible to run into issues with contextuals, though.</p> <ul> <li>You're still hiding a dependency of your code, which can still lead to confusion and obscuring available features, just the same as globals.</li> <li>Unlike globals, contextuals are time-limited. If you connect to an event or  start a delayed task, you won't be able to access the value anymore. Instead, capture the value at the start of the code block, so you can use it in delayed tasks.</li> </ul>"},{"location":"tutorials/best-practices/state/","title":"State","text":"<p>Components can hold their own data privately using state objects. This can be useful, but you should be careful when adding state.</p>"},{"location":"tutorials/best-practices/state/#creation","title":"Creation","text":"<p>You can create state objects inside components as you would anywhere else.</p> <pre><code>local HOVER_COLOUR = Color3.new(0.5, 0.75, 1)\nlocal REST_COLOUR = Color3.new(0.25, 0.5, 1)\n\nlocal function Button(\n    scope: Fusion.Scope,\n    props: {\n        -- ... some properties ...\n    }\n)\n    local isHovering = scope:Value(false)\n\n    return scope:New \"TextButton\" {\n        BackgroundColor3 = scope:Computed(function(use)\n            return if use(isHovering) then HOVER_COLOUR else REST_COLOUR\n        end),\n\n        -- ... ... some more code ...\n    }\nend\n</code></pre> <p>Because these state objects are made with the same <code>scope</code> as the rest of the component, they're destroyed alongside the rest of the component.</p>"},{"location":"tutorials/best-practices/state/#top-down-control","title":"Top-Down Control","text":"<p>Remember that Fusion mainly works with a top-down flow of control. It's a good idea to keep that in mind when adding state to components.</p> <p>When you're making reusable components, it's more flexible if your component can be controlled externally. Components that control themselves entirely are hard to use and customise.</p> <p>Consider the example of a check box. Each check box often reflects a state object under the hood:</p> <p> </p> <p>It might seem logical to store the state object inside the check box, but this causes a few problems:</p> <ul> <li>because the state is hidden, it's awkward to read and write from outside</li> <li>often, the user already has a state object representing the same setting, so now there's two state objects where one would have sufficed</li> </ul> <pre><code>local function CheckBox(\n    scope: Fusion.Scope,\n    props: {\n        -- ... some properties ...\n    }\n)\n    local isChecked = scope:Value(false) -- problematic\n\n    return scope:New \"ImageButton\" {\n        [OnEvent \"Activated\"] = function()\n            isChecked:set(not peek(isChecked))\n        end,\n\n        -- ... some more code ...\n    }\nend\n</code></pre> <p>A slightly better solution is to pass the state object in. This ensures the controlling code has easy access to the state if it needs it. However, this is not a complete solution:</p> <ul> <li>the user is forced to store the state in a <code>Value</code> object, but they might be computing the value dynamically with other state objects instead</li> <li>the behaviour of clicking the check box is hardcoded; the user cannot intercept the click or toggle a different state</li> </ul> <pre><code>local function CheckBox(\n    scope: Fusion.Scope,\n    props: {\n        IsChecked: Fusion.Value&lt;boolean&gt; -- slightly better\n    }\n)\n    return scope:New \"ImageButton\" {\n        [OnEvent \"Activated\"] = function()\n            props.IsChecked:set(not peek(props.IsChecked))\n        end,\n\n        -- ... some more code ...\n    }\nend\n</code></pre> <p>That's why the best solution is to use <code>UsedAs</code> to create read-only properties, and add callbacks for signalling actions and events.</p> <ul> <li>because <code>UsedAs</code> is read-only, it lets the user plug in any data source, including dynamic computations</li> <li>because the callback is provided by the user, the behaviour of clicking the check box is completely customisable</li> </ul> <pre><code>local function CheckBox(\n    scope: Fusion.Scope,\n    props: {\n        IsChecked: UsedAs&lt;boolean&gt;, -- best\n        OnClick: () -&gt; ()\n    }\n)\n    return scope:New \"ImageButton\" {\n        [OnEvent \"Activated\"] = function()\n            props.OnClick()\n        end,\n\n        -- ... some more code ...\n    }\nend\n</code></pre> <p>The control is always top-down here; the check box's appearance is fully controlled by the creator. The creator of the check box decides to switch the setting when the check box is clicked.</p>"},{"location":"tutorials/best-practices/state/#in-practice","title":"In Practice","text":"<p>Setting up your components in this way makes extending their behaviour incredibly straightforward.</p> <p>Consider a scenario where you wish to group multiple options under a 'main' check box, so you can turn them all on/off at once.</p> <p> </p> <p>The appearance of that check box would not be controlled by a single state, but instead reflects the combination of multiple states. Because the code uses <code>UsedAs</code>, you can represent this with a <code>Computed</code> object.</p> <pre><code>local playMusic = scope:Value(true)\nlocal playSFX = scope:Value(false)\nlocal playNarration = scope:Value(true)\n\nlocal checkBox = scope:CheckBox {\n    Text = \"Play sounds\",\n    IsChecked = scope:Computed(function(use)\n        local anyChecked = use(playMusic) or use(playSFX) or use(playNarration)\n        local allChecked = use(playMusic) and use(playSFX) and use(playNarration)\n\n        if not anyChecked then\n            return \"unchecked\"\n        elseif not allChecked then\n            return \"partially-checked\"\n        else\n            return \"checked\"\n        end\n    end)\n}\n</code></pre> <p>You can then implement the 'check all'/'uncheck all' behaviour inside <code>OnClick</code>:</p> <pre><code>local playMusic = scope:Value(true)\nlocal playSFX = scope:Value(false)\nlocal playNarration = scope:Value(true)\n\nlocal checkBox = scope:CheckBox {\n    -- ... same properties as before ...\n    OnClick = function()\n        local allChecked = peek(playMusic) and peek(playSFX) and peek(playNarration)\n\n        playMusic:set(not allChecked)\n        playSFX:set(not allChecked)\n        playNarration:set(not allChecked)\n    end\n}\n</code></pre> <p>Because the check box was written to be flexible, it can handle complex usage easily.</p>"},{"location":"tutorials/best-practices/state/#best-practices","title":"Best Practices","text":"<p>Those examples lead us to the golden rule of reusable components:</p> <p>Golden Rule</p> <p>Reusable components should reflect program state. They should not control program state.</p> <p>At the bottom of the chain of control, components shouldn't be massively responsible. At these levels, reflective components are easier to work with.</p> <p>As you go up the chain of control, components get broader in scope and less reusable; those places are often suitable for controlling components.</p> <p>A well-balanced codebase places controlling components at key, strategic locations. They allow higher-up components to operate without special knowledge about what goes on below.</p> <p>At first, this might be difficult to do well, but with experience you'll have a better intuition for it. Remember that you can always rewrite your code if it becomes a problem!</p>"},{"location":"tutorials/fundamentals/computeds/","title":"Computeds","text":"<p>Computeds are state objects that immediately process values from other state objects.</p> <p>You pass in a callback to define a calculation. Then, you can use <code>peek()</code> to read the result of the calculation at any time.</p> <pre><code>local numCoins = scope:Value(50)\nlocal itemPrice = scope:Value(10)\n\nlocal finalCoins = scope:Computed(function(use, scope)\n    return use(numCoins) - use(itemPrice)\nend)\n\nprint(peek(finalCoins)) --&gt; 40\n\nnumCoins:set(25)\nitemPrice:set(15)\nprint(peek(finalCoins)) --&gt; 10\n</code></pre>"},{"location":"tutorials/fundamentals/computeds/#usage","title":"Usage","text":"<p>To create a new computed object, call <code>scope:Computed()</code> and give it a function that performs your calculation. It takes two parameters which will be explained later; for the first part of this tutorial, they'll be left unnamed.</p> <pre><code>local scope = scoped(Fusion)\nlocal hardMaths = scope:Computed(function(_, _)\n    return 1 + 1\nend)\n</code></pre> <p>The value the callback returns will be stored as the computed's value. You can get the computed's current value using <code>peek()</code>:</p> <pre><code>local scope = scoped(Fusion)\nlocal hardMaths = scope:Computed(function(_, _)\n    return 1 + 1\nend)\n\nprint(peek(hardMaths)) --&gt; 2\n</code></pre> <p>The calculation should be immediate - that is, it should never delay. That means you should not use computed objects when you need to wait for something to occur (e.g. waiting for a server to respond to a request).</p>"},{"location":"tutorials/fundamentals/computeds/#using-state-objects","title":"Using State Objects","text":"<p>The calculation is only run once by default. If you try to <code>peek()</code> at state objects inside the calculation, your code breaks quickly:</p> <pre><code>local scope = scoped(Fusion)\nlocal number = scope:Value(2)\nlocal double = scope:Computed(function(_, _)\n    return peek(number) * 2\nend)\n\nprint(peek(number), peek(double)) --&gt; 2 4\n\n-- The calculation won't re-run! Oh no!\nnumber:set(10)\nprint(peek(number), peek(double)) --&gt; 10 4\n</code></pre> <p>Instead, the computed object provides a <code>use</code> function as the first argument. As your logic runs, you can call this function with different state objects. If any of them changes, then the computed throws everything away and recalculates.</p> <pre><code>local scope = scoped(Fusion)\nlocal number = scope:Value(2)\nlocal double = scope:Computed(function(use, _)\n    use(number) -- the calculation will re-run when `number` changes value\n    return peek(number) * 2\nend)\n\nprint(peek(number), peek(double)) --&gt; 2 4\n\n-- Now it re-runs!\nnumber:set(10)\nprint(peek(number), peek(double)) --&gt; 10 20\n</code></pre> <p>For convenience, <code>use()</code> will also read the value, just like <code>peek()</code>, so you can easily replace <code>peek()</code> calls with <code>use()</code> calls. This keeps your logic concise, readable and easily copyable.</p> <pre><code>local scope = scoped(Fusion)\nlocal number = scope:Value(2)\nlocal double = scope:Computed(function(use, _)\n    return use(number) * 2\nend)\n\nprint(peek(number), peek(double)) --&gt; 2 4\n\nnumber:set(10)\nprint(peek(number), peek(double)) --&gt; 10 20\n</code></pre> <p>It's recommended you always give the first parameter the name <code>use</code>, even if it already exists. This helps prevent you from using the wrong parameter if you have multiple computed objects at the same time.</p> <pre><code>scope:Computed(function(use, _)\n    -- ...\n    scope:Computed(function(use, _)\n        -- ...\n        scope:Computed(function(use, _)\n            return use(number) * 2\n        end)\n        -- ...\n    end)\n    -- ...\nend)\n</code></pre> Help! Using the same name gives me a warning. <p>Depending on your setup, Luau might be configured to warn when you use the same variable name multiple times.</p> <p>In many cases, using the same variable name can be a mistake, but in this case we actually find it useful. So, to turn off the warning, try adding <code>--!nolint LocalShadow</code> to the top of your file.</p> <p>Keep in mind that Fusion sometimes applies optimisations; recalculations might be postponed or cancelled if the value of the computed isn't being used. This is why you should not use computed objects for things like playing sound effects.</p> <p>You will learn more about how Fusion does this later.</p>"},{"location":"tutorials/fundamentals/computeds/#inner-scopes","title":"Inner Scopes","text":"<p>Sometimes, you'll need to create things inside computed objects temporarily. In these cases, you want the temporary things to be destroyed when you're done.</p> <p>You might try and reuse the scope you already have, to construct objects and add cleanup tasks.</p> Luau codeOutput <pre><code>local scope = scoped(Fusion)\nlocal number = scope:Value(5)\nlocal double = scope:Computed(function(use, _)\n    local current = use(number)\n    print(\"Creating\", current)\n    -- suppose we want to run some cleanup code for stuff in here\n    table.insert(scope, function()\n        print(\"Destroying\", current)\n    end)\n    return current * 2\nend)\n\nprint(\"...setting to 25...\")\nnumber:set(25)\nprint(\"...setting to 2...\")\nnumber:set(2)\nprint(\"...cleaning up...\")\ndoCleanup(scope)\n</code></pre> <pre><code>Creating 5\n...setting to 25...\nCreating 25\n...setting to 2...\nCreating 2\n...cleaning up...\nDestroying 2\nDestroying 25\nDestroying 5\n</code></pre> <p>However, this doesn't work the way you'd want it to. All of the tasks pile up at the end of the program, instead of being thrown away with the rest of the calculation.</p> <p>That's why the second argument is a different scope for you to use while inside the computed object. This scope argument is automatically cleaned up for you when the computed object recalculates.</p> Luau codeOutput <pre><code>local scope = scoped(Fusion)\nlocal number = scope:Value(5)\nlocal double = scope:Computed(function(use, myBrandNewScope)\n    local current = use(number)\n    print(\"Creating\", current)\n    table.insert(myBrandNewScope, function()\n        print(\"Destroying\", current)\n    end)\n    return current * 2\nend)\n\nprint(\"...setting to 25...\")\nnumber:set(25)\nprint(\"...setting to 2...\")\nnumber:set(2)\nprint(\"...cleaning up...\")\ndoCleanup(scope)\n</code></pre> <pre><code>Creating 5\n...setting to 25...\nCreating 25\nDestroying 5\n...setting to 2...\nCreating 2\nDestroying 25\n...cleaning up...\nDestroying 2\n</code></pre> <p>When using this new 'inner' scope, the tasks no longer pile up at the end of the program. Instead, they're cleaned up as soon as possible, when the computed object throws away the old calculation.</p> <p>It can help to give this parameter the same name as the original scope. This stops you from accidentally using the original scope inside the computed, and makes your code more easily copyable and movable.</p> <pre><code>local scope = scoped(Fusion)\nscope:Computed(function(use, scope)\n    -- ...\n    scope:Computed(function(use, scope)\n        -- ...\n        scope:Computed(function(use, scope)\n            local innerValue = scope:Value(5)\n        end)\n        -- ...\n    end)\n    -- ...\nend)\n</code></pre> Help! Using the same name gives me a warning. <p>Depending on your setup, Luau might be configured to warn when you use the same variable name multiple times.</p> <p>In many cases, using the same variable name can be a mistake, but in this case we actually find it useful. So, to turn off the warning, try adding <code>--!nolint LocalShadow</code> to the top of your file.</p> <p>Once you understand computeds, as well as the previously discussed scopes, values and observers, you're well positioned to explore the rest of Fusion.</p>"},{"location":"tutorials/fundamentals/observers/","title":"Observers","text":"<p>When you're working with state objects, it can be useful to detect various changes that happen to them.</p> <p>Observers allow you to detect those changes. Create one with a state object to 'watch', then connect code to run using <code>:onChange()</code> or <code>:onBind()</code>.</p> <pre><code>local observer = scope:Observer(health)\nlocal disconnect = observer:onChange(function()\n    print(\"The new value is: \", peek(health))\nend)\ntask.wait(5)\ndisconnect()\n</code></pre>"},{"location":"tutorials/fundamentals/observers/#usage","title":"Usage","text":"<p>To create a new observer object, call <code>scope:Observer()</code> and give it a state object you want to detect changes on.</p> <pre><code>local scope = scoped(Fusion)\nlocal health = scope:Value(5)\nlocal observer = scope:Observer(health)\n</code></pre> <p>The observer will watch the state object for changes until it's destroyed. You can take advantage of this by connecting your own code using the observer's different methods.</p> <p>The first method is <code>:onChange()</code>, which runs your code when the state object changes value.</p> Luau codeOutput <pre><code>local observer = scope:Observer(health)\n\nprint(\"...connecting...\")\nobserver:onChange(function()\n    print(\"Observed a change to: \", peek(health))\nend)\n\nprint(\"...setting health to 25...\")\nhealth:set(25)\n</code></pre> <pre><code>...connecting...\n...setting health to 25...\nObserved a change to: 25\n</code></pre> <p>By default, the <code>:onChange()</code> connection is disconnected when the observer object is destroyed. However, if you want to disconnect it earlier, the <code>:onChange()</code> method returns an optional disconnect function. Calling it will disconnect that specific <code>:onChange()</code> handler early.</p> <pre><code>local disconnect = observer:onChange(function()\n    print(\"The new value is: \", peek(health))\nend)\n\n-- disconnect the above handler after 5 seconds\ntask.wait(5)\ndisconnect()\n</code></pre> <p>The second method is <code>:onBind()</code>. It works identically to <code>:onChange()</code>, but it also runs your code right away, which can often be useful.</p> Luau codeOutput <pre><code>local observer = scope:Observer(health)\n\nprint(\"...connecting...\")\nobserver:onBind(function()\n    print(\"Observed a change to: \", peek(health))\nend)\n\nprint(\"...setting health to 25...\")\nhealth:set(25)\n</code></pre> <pre><code>...connecting...\nObserved a change to: 5\n...setting health to 25...\nObserved a change to: 25\n</code></pre>"},{"location":"tutorials/fundamentals/observers/#what-counts-as-a-change","title":"What Counts As A Change?","text":"<p>If you set the <code>health</code> to the same value multiple times in a row, you might notice your observer only runs the first time.</p> Luau codeOutput <pre><code>local observer = scope:Observer(health)\n\nobserver:onChange(function()\n    print(\"Observed a change to: \", peek(health))\nend)\n\nprint(\"...setting health to 25 three times...\")\nhealth:set(25)\nhealth:set(25)\nhealth:set(25)\n</code></pre> <pre><code>...setting health to 25 three times...\nObserved a change to: 25\n</code></pre> <p>This is because the <code>health</code> object sees that it isn't actually changing value, so it doesn't broadcast any updates. Therefore, our observer doesn't run.</p> <p>This leads to improved performance because your code runs less often. Fusion applies these kinds of optimisations generously throughout your program.</p>"},{"location":"tutorials/fundamentals/scopes/","title":"Scopes","text":"<p>In Fusion, you create a lot of objects. These objects need to be destroyed when you're done with them.</p> <p>Fusion has some coding conventions to make large quantities of objects easier to manage.</p>"},{"location":"tutorials/fundamentals/scopes/#scopes","title":"Scopes","text":"<p>When you create many objects at once, you often want to destroy them together later.</p> <p>To make this easier, some people add their objects to an array. Arrays that group together objects like this are given a special name: scopes.</p> <p>To create a new scope, create an empty array.</p> <pre><code>local Fusion = require(ReplicatedStorage.Fusion)\n\nlocal scope = {}\n</code></pre> <p>Later, when you create objects, they will ask for a scope as the first argument.</p> <pre><code>local Fusion = require(ReplicatedStorage.Fusion)\n\nlocal scope = {}\nlocal thing = Fusion.Value(scope, \"i am a thing\")\n</code></pre> <p>That object will add its <code>destroy()</code> function to the scope:</p> <pre><code>local Fusion = require(ReplicatedStorage.Fusion)\n\nlocal scope = {}\nlocal thing = Fusion.Value(scope, \"i am a thing\")\n\nprint(scope[1]) --&gt; function: 0x123456789abcdef\n</code></pre> <p>Repeat as many times as you like. Objects appear in order of creation.</p> <pre><code>local Fusion = require(ReplicatedStorage.Fusion)\n\nlocal scope = {}\nlocal thing1 = Fusion.Value(scope, \"i am thing 1\")\nlocal thing2 = Fusion.Value(scope, \"i am thing 2\")\nlocal thing3 = Fusion.Value(scope, \"i am thing 3\")\n</code></pre> <p>Later, destroy the scope by using the <code>doCleanup()</code> function. The contents are destroyed in reverse order.</p> <pre><code>local Fusion = require(ReplicatedStorage.Fusion)\n\nlocal scope = {}\nlocal thing1 = Fusion.Value(scope, \"i am thing 1\")\nlocal thing2 = Fusion.Value(scope, \"i am thing 2\")\nlocal thing3 = Fusion.Value(scope, \"i am thing 3\")\n\nFusion.doCleanup(scope)\n-- Using `doCleanup` is conceptually the same as:\n-- thing3:destroy()\n-- thing2:destroy()\n-- thing1:destroy()\n</code></pre> <p>Scopes passed to <code>doCleanup</code> can contain:</p> <ul> <li>Functions to be run (like those <code>destroy()</code> functions above)</li> <li>Roblox instances to destroy</li> <li>Roblox event connections to disconnect</li> <li>Your own objects with <code>:destroy()</code> or <code>:Destroy()</code> methods to be called</li> <li>Other nested scopes to be cleaned up</li> </ul> <p>You can add these manually using <code>table.insert</code> if you need custom behaviour, or if you are working with objects that don't add themselves to scopes.</p> <p>That's all there is to scopes. They are arrays of objects which later get passed to a cleanup function.</p>"},{"location":"tutorials/fundamentals/scopes/#improved-scopes","title":"Improved Scopes","text":"<p>This syntax is recommended</p> <p>From now on, you'll see this syntax used throughout the tutorials.</p> <p>Fusion can help manage your scopes for you. This unlocks convenient syntax, and allows Fusion to optimise your code.</p> <p>You can call <code>scoped()</code> to obtain a new scope.</p> <pre><code>local Fusion = require(ReplicatedStorage.Fusion)\nlocal scoped = Fusion.scoped\n\nlocal scope = scoped()\nlocal thing1 = Fusion.Value(scope, \"i am thing 1\")\nlocal thing2 = Fusion.Value(scope, \"i am thing 2\")\nlocal thing3 = Fusion.Value(scope, \"i am thing 3\")\n\nFusion.doCleanup(scope)\n</code></pre> <p>Unlike <code>{}</code> (which always creates a new array), <code>scoped</code> can re-use old arrays. This helps keep your program running smoothly.</p> <p>Beyond making your code more efficient, you can also use <code>scoped</code> for convenient syntax.</p> <p>You can pass a table of functions into <code>scoped</code>:</p> <pre><code>local Fusion = require(ReplicatedStorage.Fusion)\nlocal scoped = Fusion.scoped\n\nlocal scope = scoped({\n    Value = Fusion.Value,\n    doCleanup = Fusion.doCleanup\n})\nlocal thing1 = Fusion.Value(scope, \"i am thing 1\")\nlocal thing2 = Fusion.Value(scope, \"i am thing 2\")\nlocal thing3 = Fusion.Value(scope, \"i am thing 3\")\n\nFusion.doCleanup(scope)\n</code></pre> <p>If those functions take <code>scope</code> as their first argument, you can use them as methods directly on the scope:</p> <pre><code>local Fusion = require(ReplicatedStorage.Fusion)\nlocal scoped = Fusion.scoped\n\nlocal scope = scoped({\n    Value = Fusion.Value,\n    doCleanup = Fusion.doCleanup\n})\nlocal thing1 = scope:Value(\"i am thing 1\")\nlocal thing2 = scope:Value(\"i am thing 2\")\nlocal thing3 = scope:Value(\"i am thing 3\")\n\nscope:doCleanup()\n</code></pre> <p>This makes it harder to mess up writing scopes. Your code reads more naturally, too.</p> <p>For convenience, Fusion exposes the <code>insert</code> method to insert destruction tasks into a scope:</p> <pre><code>local conn, ins = scope:insert(\n    RunService.Heartbeat:Connnect(doUpdate),\n    Instance.new(\"Part\", workspace)\n)\n</code></pre>"},{"location":"tutorials/fundamentals/scopes/#adding-methods-in-bulk","title":"Adding Methods In Bulk","text":"<p>Try passing <code>Fusion</code> to <code>scoped()</code> - it's a table with functions, too.</p> <pre><code>local scope = scoped(Fusion)\n\n-- all still works!\nlocal thing1 = scope:Value(\"i am thing 1\")\nlocal thing2 = scope:Value(\"i am thing 2\")\nlocal thing3 = scope:Value(\"i am thing 3\")\n\nscope:doCleanup()\n</code></pre> <p>This gives you access to all of Fusion's functions without having to import each one manually.</p> <p>If you need to mix in other things, you can pass in another table.</p> <pre><code>local scope = scoped(Fusion, {\n    Foo = ...,\n    Bar = ...\n})\n</code></pre> <p>You can do this for as many tables as you need.</p> <p>Conflicting names</p> <p>If you pass in two tables that contain things with the same name, <code>scoped()</code> will error.</p>"},{"location":"tutorials/fundamentals/scopes/#reusing-methods-from-other-scopes","title":"Reusing Methods From Other Scopes","text":"<p>Sometimes, you'll want to make a new scope with the same methods as an existing scope.</p> <pre><code>local foo = scoped({\n    Foo = Foo,\n    Bar = Bar,\n    Baz = Baz\n})\n\n-- `bar` should have the same methods as `foo`\n-- it'd be nice to define this once only...\nlocal bar = scoped({\n    Foo = Foo,\n    Bar = Bar,\n    Baz = Baz\n})\n\nprint(foo.Baz == bar.Baz) --&gt; true\n\nbar:doCleanup()\nfoo:doCleanup()\n</code></pre> <p>To do this, Fusion provides a <code>deriveScope</code> function. It behaves like <code>scoped</code> but lets you skip defining the methods. Instead, you give it an example of what the scope should look like.</p> <pre><code>local foo = scoped({\n    Foo = Foo,\n    Bar = Bar,\n    Baz = Baz\n})\n\n-- `bar` should have the same methods as `foo`\n-- now, it's only defined once!\nlocal bar = foo:deriveScope()\n\nprint(foo.Baz == bar.Baz) --&gt; true\n\nbar:doCleanup()\nfoo:doCleanup()\n</code></pre> <p>Deriving scopes like this is highly efficient because Fusion can re-use the same information for both scopes. It also helps keep your definitions all in one place.</p> <p>You can also add more method tables if you'd like to.</p> <pre><code>local foo = scoped({\n    Foo = Foo,\n    Bar = Bar,\n    Baz = Baz\n})\n\n-- `bar` should have the same methods as `foo`\n-- now, it's only defined once!\nlocal bar = foo:deriveScope({\n    Garb = Garb\n})\n\nprint(bar.Garb) --&gt; function: 0x123456789abcdef\nprint(foo.Garb) --&gt; nil\n</code></pre>"},{"location":"tutorials/fundamentals/scopes/#inner-scopes","title":"Inner Scopes","text":"<p>The main reason you would want to create a new scope is to create things that get destroyed at different times.</p> <p>For example, imagine you're creating a dropdown menu. You create a new scope for the menu, which you clean up when the menu is closed.</p> <pre><code>local uiScope = scoped(Fusion)\n\n-- ... create the ui ...\n\nuiScope:insert(\n    dropdownOpened:Connect(function()\n        local dropdownScope = uiScope:deriveScope()\n\n        -- ... create the dropdown ...\n\n        dropdownScope:insert(\n            dropdownClosed:Connect(function()\n                dropdownScope:doCleanup()\n            end)\n        )\n    end)\n)\n</code></pre> <p>This ordinarily works just fine; when the dropdown is opened, the new scope is created, and when the dropdown is closed, the new scope is destroyed.</p> <p>However, what if the UI gets cleaned up while the dropdown is open? The <code>uiScope</code> will get cleaned up, but the <code>dropdownScope</code> will not.</p> <p>To help with this, Fusion provides an <code>innerScope</code> method. It works just like <code>deriveScope</code>, but it adds in extra logic:</p> <ul> <li>When the original scope is cleaned up, the 'inner scope' is cleaned up too</li> <li>You can still call <code>doCleanup()</code> to clean the inner scope up early</li> </ul> <pre><code>local uiScope = scoped(Fusion)\n\n-- ... create the ui ...\n\nuiScope:insert(\n    dropdownOpened:Connect(function()\n        local dropdownScope = uiScope:innerScope()\n\n        -- ... create the dropdown ...\n\n        dropdownScope:insert(\n            dropdownClosed:Connect(function()\n                dropdownScope:doCleanup()\n            end)\n        )\n    end)\n)\n</code></pre> <p>Now, the dropdown scope is guaranteed to be cleaned up if the UI it came from is cleaned up. This strictly limits how long the dropdown can exist for.</p> <p>Inner scopes are often the safest choice for creating new scopes. They let you call <code>doCleanup</code> whenever you like, but guarantee that they won't stick around beyond the rest of the code they're in.</p>"},{"location":"tutorials/fundamentals/scopes/#when-youll-use-this","title":"When You'll Use This","text":"<p>Scopes might sound like a lot of upfront work. However, you'll find in practice that Fusion manages a lot of this for you, and it makes your code much more resilient to memory leaks and other kinds of memory management issues.</p> <p>You'll need to create and destroy your own scopes manually sometimes. For example, you'll need to create a scope in your main code file to start using Fusion, and you might want to make a few more in other parts of your code.</p> <p>However, Fusion manages most of your scopes for you, so for large parts of your codebase, you won't have to consider scopes and destruction at all.</p>"},{"location":"tutorials/fundamentals/values/","title":"Values","text":"<p>Now that you understand how Fusion works with objects, you can create Fusion's simplest object.</p> <p>Values are objects which store single values. You can write to them with their <code>:set()</code> method, and read from them with the <code>peek()</code> function.</p> <pre><code>local health = scope:Value(100)\n\nprint(peek(health)) --&gt; 100\nhealth:set(25)\nprint(peek(health)) --&gt; 25\n</code></pre>"},{"location":"tutorials/fundamentals/values/#usage","title":"Usage","text":"<p>To create a new value object, call <code>scope:Value()</code> and give it a value you want to store.</p> <pre><code>local Fusion = require(ReplicatedStorage.Fusion)\nlocal doCleanup, scoped = Fusion.doCleanup, Fusion.scoped\n\nlocal scope = scoped(Fusion)\nlocal health = scope:Value(5)\n</code></pre> <p>Fusion provides a global <code>peek()</code> function. It will read the value of whatever you give it. You'll use <code>peek()</code> to read the value of lots of things; for now, it's useful for printing <code>health</code> back out.</p> <pre><code>local Fusion = require(ReplicatedStorage.Fusion)\nlocal doCleanup, scoped = Fusion.doCleanup, Fusion.scoped\nlocal peek = Fusion.peek\n\nlocal scope = scoped(Fusion)\nlocal health = scope:Value(5)\nprint(peek(health)) --&gt; 5\n</code></pre> <p>You can change the value using the <code>:set()</code> method. Unlike <code>peek()</code>, this is specific to value objects, so it's done on the object itself.</p> <pre><code>local scope = scoped(Fusion)\nlocal health = scope:Value(5)\nprint(peek(health)) --&gt; 5\n\nhealth:set(25)\nprint(peek(health)) --&gt; 25\n</code></pre> <code>:set()</code> returns the value you give it <p>You can use <code>:set()</code> in the middle of calculations:</p> <pre><code>local myNumber = scope:Value(0)\nlocal computation = 10 + myNumber:set(2 + 2)\nprint(computation) --&gt; 14\nprint(peek(myNumber)) --&gt; 4\n</code></pre> <p>This is useful when building complex expressions. On a later page, you'll see one such use case.</p> <p>Generally though, it's better to keep your expressions simple.</p> <p>Value objects are Fusion's simplest 'state object'. State objects contain a single value - their state, you might say - and that single value can be read out at any time using <code>peek()</code>.</p> <p>Later on, you'll discover more advanced state objects that can calculate their value in more interesting ways.</p>"},{"location":"tutorials/get-started/developer-tools/","title":"Developer Tools","text":"<p>For the best Fusion experience, you can try out a range of developer tools.  These aren't strictly required to use Fusion, but they can make your life a lot better!</p>"},{"location":"tutorials/get-started/developer-tools/#fusionkit","title":"FusionKit","text":"<p>FusionKit is a range of officially-endorsed tools distributed alongside the Elttob\u00a0Suite. They're designed to take advantage of dedicated deep Fusion integrations, and are kept up to date with new releases of Fusion.</p> <p>Work in progress</p> <p>Official developer tools are still in the works; in the meantime, feel  free to check out the community's recommendations below!</p>"},{"location":"tutorials/get-started/developer-tools/#community-tools","title":"Community Tools","text":"<p>These tools are unofficial, community-made contributions. The Fusion project make no guarantees about them, and you won't be able to get support for them here. However, if you're looking for a broader diversity of options, then they may have something to offer \ud83d\ude42</p> Have a new tool for this page? <p>If you use a component library, Roblox plugin, extension, command-line tool, or something else that benefits your developer workflow, you can suggest it for inclusion on this page!</p> <p>Before adding a community tool to this page, it should meet various criteria:</p> <ul> <li>The tool must abide by Roblox's Terms of Service.</li> <li>The tool must be notable and actively used within the Fusion community.</li> <li>The tool should be compatible with a modern Fusion release.<ul> <li>General purpose tools are also accepted if they can be used with Fusion.</li> </ul> </li> </ul> <p>If you believe a tool meets these criteria, you may add some details to this page, using these guidelines:</p> <ul> <li>Tools must be sorted alphabetically for neutrality.</li> <li>Descriptions should be short with a neutral, professional tone.<ul> <li>In particular, do not exaggerate, market, or attempt to elevate one tool over another.</li> </ul> </li> <li>Descriptions should usefully define the tool's capabilities.<ul> <li>Ensure that it's clear how the tool works with Fusion, and give an accurate impression of the level of integration.</li> </ul> </li> <li>You may only use these links:<ul> <li>Get on Creator\u00a0Store: <code>create.roblox.com</code></li> <li>Get on itch.io: <code>itch.io</code></li> <li>Add to Visual\u00a0Studio\u00a0Code: <code>marketplace.visualstudio.com</code></li> <li>Code on GitHub: <code>github.com</code></li> <li>Learn more: <code>github.io</code>, <code>devforum.roblox.com</code></li> <li>All other links are disallowed unless an explicit exception is made by a Fusion maintainer (e.g. well-known domains like <code>rojo.space</code>).</li> </ul> </li> </ul> <p>If you're not sure, then follow the example of other listings. When you're ready, open a pull request with your changes  and Fusion maintainers will review your additions for possible inclusion.</p> Codify <p>             Generate Fusion code based on existing hand-made UI or instances.         </p> Get on Creator\u00a0Store Get on itch.io Code on GitHub Learn more Flipbook <p>             Storybook-like plugin for creating sandboxed previews of UI             components.             Can be manually integrated with Fusion.         </p> Get on Creator\u00a0Store Code on GitHub Learn more Fusion Autocomplete <p>             Autocomplete class names, properties, functions, parameters, and             special keys in Visual\u00a0Studio\u00a0Code when building instances.         </p> Add to Visual Studio Code Code on GitHub Hoarcekat <p>             Run your UI code in a preview window. Can be manually integrated             with Fusion.         </p> Get on Creator\u00a0Store Code on GitHub Lydie <p>             Theme-able Fusion component library with a modern, rounded look.          </p> Code on GitHub OnyxUI <p>             Quick, customizable components.         </p> Code on GitHub Learn more Rojo <p>             Build Roblox\u00a0Studio projects with real code files, version             control and an external editor of your choice. Can be used to work             with source-code releases of Fusion.         </p> Add to Visual\u00a0Studio\u00a0Code Code on GitHub Learn more Selene <p>             Code linting tool that assists in writing simple, idiomatic Luau             code. Useful for monitoring code quality of large Fusion projects.         </p> Add to Visual\u00a0Studio\u00a0Code Code on GitHub Learn more StyLua <p>             Opinionated Luau code formatter. Can be configured to format Fusion             code.         </p> Add to Visual\u00a0Studio\u00a0Code Code on GitHub Toned <p>             CSS-like style sheets for applying properties in bulk to selected             Fusion instances.         </p> Code on GitHub Learn more"},{"location":"tutorials/get-started/getting-help/","title":"Getting Help","text":"<p>If you're struggling to understand a concept, or need help debugging an error, here are some resources which can help.</p>"},{"location":"tutorials/get-started/getting-help/#get-help-with-errors","title":"Get Help With Errors","text":"<p>Whenever Fusion outputs a message to the console, it will contain a link to a page which will tell you more about what the message means, and why it appeared.</p> <pre><code>[Fusion] The Frame class doesn't have a property called 'Activated'.\nID: cannotConnectChange\nLearn more: https://elttob.uk/Fusion/0.3/api-reference/general/errors/#cannotconnectchange\n</code></pre> <p>When you follow that link, it will take you to the Errors page, which describes every single message that Fusion can show you, what parts of Fusion are related to each message, and any relevant ongoing discussions on the Fusion repository that may contain useful context.</p> <p>When you run into an error, that page is a great place to start!</p>"},{"location":"tutorials/get-started/getting-help/#working-examples","title":"Working Examples","text":"<p>If you would like to see more practical examples of Fusion being used to build larger systems, then take a look at the Examples section.</p> <p>The example projects can be a great place to learn how Fusion code should look in a complete project, and help you to structure your own projects in ways that are easy to extend as you grow.</p> <p>Additionally, there's a cookbook full of explained code snippets, which show you how to achieve common tasks in an idiomatic and professional way using Fusion.</p>"},{"location":"tutorials/get-started/getting-help/#talk-to-other-developers","title":"Talk To Other Developers","text":"<p>Fusion is built to be easy to use, and this website strives to be as useful and comprehensive as possible. However, you might need targeted help on a specific issue, or you might want to grow your understanding of Fusion in other ways.</p> <p>The best place to get help is the #fusion channel over on the Roblox OSS Discord server. Maintainers and contributors drop in frequently, alongside many eager Fusion users.</p>"},{"location":"tutorials/get-started/installing-fusion/","title":"Installing Fusion","text":""},{"location":"tutorials/get-started/installing-fusion/#install-via-roblox","title":"Install via Roblox","text":"<p>If you are creating Luau experiences in Roblox Studio, then you can import a Roblox model file containing Fusion.</p> <ul> <li>Head over to Fusion's 'Releases' page.</li> <li>Click the 'Assets' dropdown to view the downloadable files:</li> </ul> <p> </p> <ul> <li>Click on the <code>Fusion.rbxm</code> file to download it. This model contains Fusion.</li> </ul> <p> </p> <ul> <li>Head into Roblox Studio to import the model; if you're just following the tutorials, an empty baseplate will do.</li> <li>Right-click on <code>ReplicatedStorage</code>, and select 'Insert from File':</li> </ul> <p> </p> <ul> <li>Select the <code>Fusion.rbxm</code> file you just downloaded. Y</li> <li>You should see a 'Fusion' module script appear in <code>ReplicatedStorage</code>!</li> </ul> <p>Now, you can create a script for testing:</p> <ul> <li>Create a <code>LocalScript</code> in <code>StarterGui</code> or <code>StarterPlayerScripts</code>.</li> <li>Remove the default code, and paste the following code in:</li> </ul> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n</code></pre> <ul> <li>Press 'Play' - if there are no errors, everything was set up correctly!</li> </ul>"},{"location":"tutorials/get-started/installing-fusion/#install-as-source-code","title":"Install as Source Code","text":"<p>If you're using pure Luau, or if you're synchronising external files into Roblox Studio, then you can use Fusion's source code directly.</p> <ul> <li>Head over to Fusion's 'Releases' page.</li> <li>Under 'Assets', download <code>Source code (zip)</code>. Inside is a copy of the Fusion GitHub repository.</li> <li>Inside the zip, copy the <code>src</code> folder - it may be inside another folder.</li> <li>Paste the <code>src</code> folder into your local project, wherever you keep your libraries <ul> <li>For example, you might paste it inside a <code>lib</code> or <code>shared</code> folder.</li> </ul> </li> <li>Rename the pasted folder from <code>src</code> to <code>Fusion</code>.</li> </ul> <p>Once everything is set up, you should be able to <code>require()</code> Fusion in one of the following ways:</p> <pre><code>-- Rojo\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\n-- darklua\nlocal Fusion = require(\"../shared/Fusion\")\n\n-- vanilla Luau\nlocal Fusion = require(\"../shared/Fusion/init.luau\")\n</code></pre>"},{"location":"tutorials/roblox/change-events/","title":"Change Events","text":"<p><code>OnChange</code> is a function that returns keys to use when hydrating or creating an instance. Those keys let you connect functions to property changed events on the instance.</p> <pre><code>local input = scope:New \"TextBox\" {\n    [OnChange \"Text\"] = function(newText)\n        print(\"You typed:\", newText)\n    end\n}\n</code></pre>"},{"location":"tutorials/roblox/change-events/#usage","title":"Usage","text":"<p><code>OnChange</code> doesn't need a scope - import it into your code from Fusion directly.</p> <pre><code>local OnChange = Fusion.OnChange\n</code></pre> <p>When you call <code>OnChange</code> with a property name, it will return a special key:</p> <pre><code>local key = OnChange(\"Text\")\n</code></pre> <p>When used in a property table, you can pass in a handler and it will be run when that property changes.</p> <p>Arguments are different to Roblox API</p> <p>Normally in the Roblox API, when using <code>:GetPropertyChangedSignal()</code> on an instance, the callback will not receive any arguments.</p> <p>To make working with change events easier, <code>OnChange</code> will pass the new value of the property to the callback.</p> <pre><code>local input = scope:New \"TextBox\" {\n    [OnChange(\"Text\")] = function(newText)\n        print(\"You typed:\", newText)\n    end\n}\n</code></pre> <p>If you're using quotes <code>'' \"\"</code> for the event name, the extra parentheses <code>()</code> are optional:</p> <pre><code>local input = scope:New \"TextBox\" {\n    [OnChange \"Text\"] = function(newText)\n        print(\"You typed:\", newText)\n    end\n}\n</code></pre>"},{"location":"tutorials/roblox/events/","title":"Events","text":"<p><code>OnEvent</code> is a function that returns keys to use when hydrating or creating an instance. Those keys let you connect functions to events on the instance.</p> <pre><code>local button = scope:New \"TextButton\" {\n    [OnEvent \"Activated\"] = function(_, numClicks)\n        print(\"The button was pressed\", numClicks, \"time(s)!\")\n    end\n}\n</code></pre>"},{"location":"tutorials/roblox/events/#usage","title":"Usage","text":"<p><code>OnEvent</code> doesn't need a scope - import it into your code from Fusion directly.</p> <pre><code>local OnEvent = Fusion.OnEvent\n</code></pre> <p>When you call <code>OnEvent</code> with an event name, it will return a special key:</p> <pre><code>local key = OnEvent(\"Activated\")\n</code></pre> <p>When that key is used in a property table, you can pass in a handler and it will be connected to the event for you:</p> <pre><code>local button = scope:New \"TextButton\" {\n    [OnEvent(\"Activated\")] = function(_, numClicks)\n        print(\"The button was pressed\", numClicks, \"time(s)!\")\n    end\n}\n</code></pre> <p>If you're using quotes <code>'' \"\"</code> for the event name, the extra parentheses <code>()</code> are optional:</p> <pre><code>local button = scope:New \"TextButton\" {\n    [OnEvent \"Activated\"] = function(_, numClicks)\n        print(\"The button was pressed\", numClicks, \"time(s)!\")\n    end\n}\n</code></pre>"},{"location":"tutorials/roblox/hydration/","title":"Hydration","text":"<p>Intent to replace</p> <p>While the contents of this page still apply (and are useful for explaining other features), <code>Hydrate</code> itself will be replaced by other primitives in the near future. See this issue on GitHub for further details.</p> <p>The process of connecting your scripts to a pre-made UI template is known as hydration. This is where logic in your scripts translate into UI effects, for example setting a message inside a TextLabel, moving menus around, or showing and hiding buttons.</p> <p> </p> Screenshot: GameUIDatabase (Halo Infinite) <p>Fusion provides a <code>Hydrate</code> function for hydrating an instance using a table of properties. If you pass in Fusion objects, changes will be applied immediately:</p> <pre><code>local showUI = scope:Value(false)\n\nlocal ui = scope:Hydrate(StarterGui.Template:Clone()) {\n    Name = \"MainGui\",\n    Enabled = showUI\n}\n\nprint(ui.Name) --&gt; MainGui\nprint(ui.Enabled) --&gt; false\n\nshowUI:set(true)\ntask.wait() -- important: changes are applied on the next frame!\nprint(ui.Enabled) --&gt; true\n</code></pre>"},{"location":"tutorials/roblox/hydration/#usage","title":"Usage","text":"<p>The <code>Hydrate</code> function is called in two parts. First, call the function with the instance you want to hydrate, then pass in the property table:</p> <pre><code>local instance = workspace.Part\n\nscope:Hydrate(instance)({\n    Color = Color3.new(1, 0, 0)\n})\n</code></pre> <p>If you're using curly braces <code>{}</code> to pass your properties in, the extra parentheses <code>()</code> are optional:</p> <pre><code>local instance = workspace.Part\n\n-- This only works when you're using curly braces {}!\nscope:Hydrate(instance) {\n    Color = Color3.new(1, 0, 0)\n}\n</code></pre> <p><code>Hydrate</code> returns the instance you give it, so you can use it in declarations:</p> <pre><code>local instance = scope:Hydrate(workspace.Part) {\n    Color = Color3.new(1, 0, 0)\n}\n</code></pre> <p>If you pass in constant values for properties, they'll be applied to the instance directly. However, if you pass in a Fusion object (like <code>Value</code>), then changes will be applied immediately:</p> <pre><code>local message = scope:Value(\"Loading...\")\n\nscope:Hydrate(PlayerGui.LoadingText) {\n    Text = message\n}\n\nprint(PlayerGui.Message.Text) --&gt; Loading...\n\nmessage:set(\"All done!\")\ntask.wait() -- important: changes are applied on the next frame!\nprint(PlayerGui.Message.Text) --&gt; All done!\n</code></pre>"},{"location":"tutorials/roblox/new-instances/","title":"New Instances","text":"<p>Fusion provides a <code>New</code> function when you're hydrating newly-made instances. It creates a new instance, applies some default properties, then hydrates it with a property table.</p> <pre><code>local message = scope:Value(\"Hello there!\")\n\nlocal ui = scope:New \"TextLabel\" {\n    Name = \"Greeting\",\n    Parent = PlayerGui.ScreenGui,\n\n    Text = message\n}\n\nprint(ui.Name) --&gt; Greeting\nprint(ui.Text) --&gt; Hello there!\n\nmessage:set(\"Goodbye friend!\")\ntask.wait() -- important: changes are applied on the next frame!\nprint(ui.Text) --&gt; Goodbye friend!\n</code></pre>"},{"location":"tutorials/roblox/new-instances/#usage","title":"Usage","text":"<p>The <code>New</code> function is called in two parts. First, call the function with the type of instance, then pass in the property table:</p> <pre><code>local instance = scope:New(\"Part\")({\n    Parent = workspace,\n    Color = Color3.new(1, 0, 0)\n})\n</code></pre> <p>If you're using curly braces <code>{}</code> for your properties, and quotes <code>'' \"\"</code> for your class type, the extra parentheses <code>()</code> are optional:</p> <pre><code>-- This only works when you're using curly braces {} and quotes '' \"\"!\nlocal instance = scope:New \"Part\" {\n    Parent = workspace,\n    Color = Color3.new(1, 0, 0)\n}\n</code></pre> <p>By design, <code>New</code> works just like <code>Hydrate</code> - it will apply properties the same way. See the Hydrate tutorial to learn more.</p>"},{"location":"tutorials/roblox/new-instances/#default-properties","title":"Default Properties","text":"<p>When you create an instance using <code>Instance.new()</code>, Roblox will give it some default properties. However, these tend to be outdated and aren't useful for most people, leading to repetitive boilerplate needed to disable features that nobody wants to use.</p> <p>The <code>New</code> function will apply some of it's own default properties to fix this. For example, by default borders on UI are disabled, automatic colouring is turned off and default content is removed.</p> <p> </p> <p>For a complete list, take a look at Fusion's default properties file.</p>"},{"location":"tutorials/roblox/outputs/","title":"Outputs","text":"<p><code>Out</code> is a function that returns keys to use when hydrating or creating an instance. Those keys let you output a property's value to a <code>Value</code> object.</p> <pre><code>local name = scope:Value()\n\nlocal thing = scope:New \"Part\" {\n    [Out \"Name\"] = name\n}\n\nprint(peek(name)) --&gt; Part\n\nthing.Name = \"Jimmy\"\nprint(peek(name)) --&gt; Jimmy\n</code></pre>"},{"location":"tutorials/roblox/outputs/#usage","title":"Usage","text":"<p><code>Out</code> doesn't need a scope - import it into your code from Fusion directly.</p> <pre><code>local Out = Fusion.Out\n</code></pre> <p>When you call <code>Out</code> with a property name, it will return a special key:</p> <pre><code>local key = Out(\"Activated\")\n</code></pre> <p>When used in a property table, you can pass in a <code>Value</code> object. It will be set to the value of the property, and when the property changes, it will be set to the new value:</p> <pre><code>local name = scope:Value()\n\nlocal thing = scope:New \"Part\" {\n    [Out(\"Name\")] = name\n}\n\nprint(peek(name)) --&gt; Part\n\nthing.Name = \"Jimmy\"\nprint(peek(name)) --&gt; Jimmy\n</code></pre> <p>If you're using quotes <code>'' \"\"</code> for the event name, the extra parentheses <code>()</code> are optional:</p> <pre><code>local thing = scope:New \"Part\" {\n    [Out \"Name\"] = name\n}\n</code></pre>"},{"location":"tutorials/roblox/outputs/#two-way-binding","title":"Two-Way Binding","text":"<p>By default, <code>Out</code> only outputs changes to the property. If you set the value to something else, the property remains the same:</p> <pre><code>local name = scope:Value()\n\nlocal thing = scope:New \"Part\" {\n    [Out \"Name\"] = name -- When `thing.Name` changes, set `name`\n}\n\nprint(thing.Name, peek(name)) --&gt; Part Part\nname:set(\"NewName\")\ntask.wait()\nprint(thing.Name, peek(name)) --&gt; Part NewName\n</code></pre> <p>If you want the value to both change and be changed by the property, you need to explicitly say so:</p> <pre><code>local name = scope:Value()\n\nlocal thing = scope:New \"Part\" {\n    Name = name -- When `name` changes, set `thing.Name`\n    [Out \"Name\"] = name -- When `thing.Name` changes, set `name`\n}\n\nprint(thing.Name, peek(name)) --&gt; Part Part\nname:set(\"NewName\")\ntask.wait()\nprint(thing.Name, peek(name)) --&gt; NewName NewName\n</code></pre> <p>This is known as two-way binding. Most of the time you won't need it, but it can come in handy when working with some kinds of UI - for example, a text box that users can write into, but which can also be modified by your scripts.</p>"},{"location":"tutorials/roblox/parenting/","title":"Parenting","text":"<p>The <code>[Children]</code> key allows you to add children when hydrating or creating an instance.</p> <p>It accepts instances, arrays of children, and state objects containing children or <code>nil</code>.</p> <pre><code>local folder = scope:New \"Folder\" {\n    [Children] = {\n        New \"Part\" {\n            Name = \"Gregory\",\n            Color = Color3.new(1, 0, 0)\n        },\n        New \"Part\" {\n            Name = \"Sammy\",\n            Material = \"Glass\"\n        }\n    }\n}\n</code></pre>"},{"location":"tutorials/roblox/parenting/#usage","title":"Usage","text":"<p><code>Children</code> doesn't need a scope - import it into your code from Fusion directly.</p> <pre><code>local Children = Fusion.Children\n</code></pre> <p>When using <code>New</code> or <code>Hydrate</code>, you can use <code>[Children]</code> as a key in the property table. Any instance you pass in will be parented:</p> <pre><code>local folder = scope:New \"Folder\" {\n    -- The part will be moved inside of the folder\n    [Children] = workspace.Part\n}\n</code></pre> <p>Since <code>New</code> and <code>Hydrate</code> both return their instances, you can nest them:</p> <pre><code>-- Makes a Folder, containing a part called Gregory\nlocal folder = scope:New \"Folder\" {\n    [Children] = scope:New \"Part\" {\n        Name = \"Gregory\",\n        Color = Color3.new(1, 0, 0)\n    }\n}\n</code></pre> <p>If you need to parent multiple children, arrays of children are accepted:</p> <pre><code>-- Makes a Folder, containing parts called Gregory and Sammy\nlocal folder = scope:New \"Folder\" {\n    [Children] = {\n        scope:New \"Part\" {\n            Name = \"Gregory\",\n            Color = Color3.new(1, 0, 0)\n        },\n        scope:New \"Part\" {\n            Name = \"Sammy\",\n            Material = \"Glass\"\n        }\n    }\n}\n</code></pre> <p>Arrays can be nested to any depth; all children will still be parented:</p> <pre><code>local folder = scope:New \"Folder\" {\n    [Children] = {\n        {\n            {\n                {\n                    scope:New \"Part\" {\n                        Name = \"Gregory\",\n                        Color = Color3.new(1, 0, 0)\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>State objects containing children or <code>nil</code> are also allowed:</p> <pre><code>local value = scope:Value()\n\nlocal folder = scope:New \"Folder\" {\n    [Children] = value\n}\n\nvalue:set(\n    scope:New \"Part\" {\n        Name = \"Clyde\",\n        Transparency = 0.5\n    }\n)\n</code></pre> <p>You may use any combination of these to parent whichever children you need:</p> <pre><code>local modelChildren = workspace.Model:GetChildren()\nlocal includeModel = scope:Value(true)\n\nlocal folder = scope:New \"Folder\" {\n    -- array of children\n    [Children] = {\n        -- single instance\n        scope:New \"Part\" {\n            Name = \"Gregory\",\n            Color = Color3.new(1, 0, 0)\n        },\n        -- state object containing children (or nil)\n        scope:Computed(function(use)\n            return if use(includeModel)\n                then modelChildren:GetChildren() -- array of children\n                else nil\n        end)\n    }\n}\n</code></pre> <p>Tip</p> <p>If you're using strictly typed Luau, you might incorrectly see type errors when mixing different kinds of value in arrays. This commonly causes problems when listing out children.</p> <p>If you're seeing type errors, try importing the <code>Child</code> function and using it when listing out children:</p> <pre><code>local Child = Fusion.Child\n\n-- ... later ...\n\nlocal folder = scope:New \"Folder\" {\n    [Children] = Child {\n        scope:New \"Part\" {\n            Name = \"Gregory\",\n            Color = Color3.new(1, 0, 0)\n        },\n        scope:Computed(function(use)\n            return if use(includeModel)\n                then modelChildren:GetChildren() -- array of children\n                else nil\n        end)\n    }\n}\n</code></pre> <p>The <code>Child</code> function doesn't do any processing, but instead encourages the Luau type system to infer a more useful type and avoid the problem.</p>"},{"location":"tutorials/tables/forkeys/","title":"ForKeys","text":"<p><code>ForKeys</code> is a state object that processes keys from another table.</p> <p>It supports both constants and state objects.</p> <pre><code>local data = {Red = \"foo\", Blue = \"bar\"}\nlocal prefix = scope:Value(\"Key_\")\n\nlocal renamed = scope:ForKeys(data, function(use, scope, key)\n    return use(prefix) .. key\nend)\n\nprint(peek(renamed)) --&gt; {Key_Red = \"foo\", Key_Blue = \"bar\"}\n\nprefix:set(\"colour\")\nprint(peek(renamed)) --&gt; {colourRed = \"foo\", colourBlue = \"bar\"}\n</code></pre>"},{"location":"tutorials/tables/forkeys/#usage","title":"Usage","text":"<p>To create a new <code>ForKeys</code> object, call the constructor with an input table and a processor function. The first two arguments are <code>use</code> and <code>scope</code>, just like computed objects. The third argument is one of the keys read from the input table.</p> <pre><code>local data = {red = \"foo\", blue = \"bar\"}\nlocal renamed = scope:ForKeys(data, function(use, scope, key)\n    return string.upper(key)\nend)\n</code></pre> <p>You can read the table of processed keys using <code>peek()</code>:</p> <pre><code>local data = {red = \"foo\", blue = \"bar\"}\nlocal renamed = scope:ForKeys(data, function(use, scope, key)\n    return string.upper(key)\nend)\n\nprint(peek(renamed)) --&gt; {RED = \"foo\", BLUE = \"bar\"}\n</code></pre> <p>The input table can be a state object. When the input table changes, the output will update.</p> <pre><code>local foodSet = scope:Value({})\n\nlocal prefixes = { pie = \"tasty\", chocolate = \"yummy\", broccoli = \"gross\" }\nlocal renamedFoodSet = scope:ForKeys(foodSet, function(use, scope, food)\n    return prefixes[food] .. food\nend)\n\nfoodSet:set({ pie = true })\nprint(peek(renamedFoodSet)) --&gt; { tasty_pie = true }\n\nfoodSet:set({ broccoli = true, chocolate = true })\nprint(peek(renamedFoodSet)) --&gt; { gross_broccoli = true, yummy_chocolate = true }\n</code></pre> <p>You can also <code>use()</code> state objects in your calculations, just like a computed.</p> <pre><code>local foodSet = scope:Value({ broccoli = true, chocolate = true })\n\nlocal prefixes = { chocolate = \"yummy\", broccoli = scope:Value(\"gross\") }\nlocal renamedFoodSet = scope:ForKeys(foodSet, function(use, scope, food)\n    return use(prefixes[food]) .. food\nend)\n\nprint(peek(renamedFoodSet)) --&gt; { gross_broccoli = true, yummy_chocolate = true }\n\nprefixes.broccoli:set(\"scrumptious\")\nprint(peek(renamedFoodSet)) --&gt; { scrumptious_broccoli = true, yummy_chocolate = true }\n</code></pre> <p>Anything added to the <code>scope</code> is cleaned up for you when the processed key is removed.</p> <pre><code>local foodSet = scope:Value({ broccoli = true, chocolate = true })\n\nlocal shoutingFoodSet = scope:ForKeys(names, function(use, scope, food)\n    table.insert(scope, function()\n        print(\"I ate the \" .. food .. \"!\")\n    end)\n    return string.upper(food)\nend)\n\nnames:set({ chocolate = true }) --&gt; I ate the broccoli!\n</code></pre> How ForKeys optimises your code <p>Rather than creating a new output table from scratch every time the input table is changed, <code>ForKeys</code> will try and reuse as much as possible to improve performance.</p> <p>Say you're converting an array to a dictionary:</p> <pre><code>local array = scope:Value({\"Fusion\", \"Knit\", \"Matter\"})\nlocal dict = scope:ForKeys(array, function(use, scope, index)\n    return \"Value\" .. index\nend)\n\nprint(peek(dict)) --&gt; {Value1 = \"Fusion\", Value2 = \"Knit\", Value3 = \"Matter\"}\n</code></pre> <p>Because <code>ForKeys</code> only operates on the keys, changing the values in the array doesn't affect the keys. Keys are only added or removed as needed:</p> <pre><code>local array = scope:Value({\"Fusion\", \"Knit\", \"Matter\"})\nlocal dict = scope:ForKeys(array, function(use, scope, index)\n    return \"Value\" .. index\nend)\n\nprint(peek(dict)) --&gt; {Value1 = \"Fusion\", Value2 = \"Knit\", Value3 = \"Matter\"}\n\narray:set({\"Roact\", \"Rodux\", \"Promise\"})\nprint(peek(dict)) --&gt; {Value1 = \"Roact\", Value2 = \"Rodux\", Value3 = \"Promise\"}\n</code></pre> <p><code>ForKeys</code> takes advantage of this - when a value changes, it's copied into the output table without recalculating the key. Keys are only calculated when a value is assigned to a new key.</p>"},{"location":"tutorials/tables/forpairs/","title":"ForPairs","text":"<p><code>ForPairs</code> is like <code>ForValues</code> and <code>ForKeys</code> in one object. It can process pairs of keys and values at the same time.</p> <p>It supports both constants and state objects.</p> <pre><code>local itemColours = { shoes = \"red\", socks = \"blue\" }\nlocal owner = scope:Value(\"Janet\")\n\nlocal manipulated = scope:ForPairs(itemColours, function(use, scope, thing, colour)\n    local newKey = colour\n    local newValue = use(owner) .. \"'s \" .. thing\n    return newKey, newValue\nend)\n\nprint(peek(manipulated)) --&gt; {red = \"Janet's shoes\", blue = \"Janet's socks\"}\n\nowner:set(\"April\")\nprint(peek(manipulated)) --&gt; {red = \"April's shoes\", blue = \"April's socks\"}\n</code></pre>"},{"location":"tutorials/tables/forpairs/#usage","title":"Usage","text":"<p>To create a new <code>ForPairs</code> object, call the constructor with an input table and a processor function. The first two arguments are <code>use</code> and <code>scope</code>, just like computed objects. The third and fourth arguments are one of the key-value pairs read from the input table.</p> <pre><code>local itemColours = { shoes = \"red\", socks = \"blue\" }\nlocal swapped = scope:ForPairs(data, function(use, scope, item, colour)\n    return colour, item\nend)\n</code></pre> <p>You can read the processed table using <code>peek()</code>:</p> <pre><code>local itemColours = { shoes = \"red\", socks = \"blue\" }\nlocal swapped = scope:ForPairs(data, function(use, scope, item, colour)\n    return colour, item\nend)\n\nprint(peek(swapped)) --&gt; { red = \"shoes\", blue = \"socks\" }\n</code></pre> <p>The input table can be a state object. When the input table changes, the output will update.</p> <pre><code>local itemColours = scope:Value({ shoes = \"red\", socks = \"blue\" })\nlocal swapped = scope:ForPairs(data, function(use, scope, item, colour)\n    return colour, item\nend)\n\nprint(peek(swapped)) --&gt; { red = \"shoes\", blue = \"socks\" }\n\nitemColours:set({ sandals = \"red\", socks = \"green\" })\nprint(peek(swapped)) --&gt; { red = \"sandals\", green = \"socks\" }\n</code></pre> <p>You can also <code>use()</code> state objects in your calculations, just like a computed.</p> <pre><code>local itemColours = { shoes = \"red\", socks = \"blue\" }\n\nlocal shouldSwap = scope:Value(false)\nlocal swapped = scope:ForPairs(data, function(use, scope, item, colour)\n    if use(shouldSwap) then\n        return colour, item\n    else\n        return item, colour\n    end\nend)\n\nprint(peek(swapped)) --&gt; { shoes = \"red\", socks = \"blue\" }\n\nshouldSwap:set(true)\nprint(peek(swapped)) --&gt; { red = \"shoes\", blue = \"socks\" }\n</code></pre> <p>Anything added to the <code>scope</code> is cleaned up for you when either the processed key or the processed value is removed.</p> <pre><code>local itemColours = scope:Value({ shoes = \"red\", socks = \"blue\" })\nlocal swapped = scope:ForPairs(data, function(use, scope, item, colour)\n    table.insert(scope, function()\n        print(\"No longer wearing \" .. colour .. \" \" .. item)\n    end)\n    return colour, item\nend)\n\nitemColours:set({ shoes = \"red\", socks = \"green\" }) --&gt; No longer wearing blue socks\n</code></pre> How ForPairs optimises your code <p>Rather than creating a new output table from scratch every time the input table is changed, <code>ForPairs</code> will try and reuse as much as possible to improve performance.</p> <p>Since <code>ForPairs</code> has to depend on both keys and values, changing any value in the input table will cause a recalculation for that key-value pair.</p> <p> </p> <p>Inversely, <code>ForPairs</code> won't recalculate any key-value pairs that stay the same. Instead, these will be preserved in the output table.</p> <p> </p> <p>If you don't need the keys or the values, Fusion can offer better optimisations. For example, if you're working with an array of values where position doesn't matter, ForValues can move values between keys.</p> <p>Alternatively, if you're working with a set of objects stored in keys, and don't need the values in the table, ForKeys will ignore the values for optimal performance.</p>"},{"location":"tutorials/tables/forvalues/","title":"ForValues","text":"<p><code>ForValues</code> is a state object that processes values from another table.</p> <p>It supports both constants and state objects.</p> <pre><code>local numbers = {1, 2, 3, 4, 5}\nlocal multiplier = scope:Value(2)\n\nlocal multiplied = scope:ForValues(numbers, function(use, scope, num)\n    return num * use(multiplier)\nend)\n\nprint(peek(multiplied)) --&gt; {2, 4, 6, 8, 10}\n\nmultiplier:set(10)\nprint(peek(multiplied)) --&gt; {10, 20, 30, 40, 50}\n</code></pre>"},{"location":"tutorials/tables/forvalues/#usage","title":"Usage","text":"<p>To create a new <code>ForValues</code> object, call the constructor with an input table and a processor function. The first two arguments are <code>use</code> and <code>scope</code>, just like computed objects. The third argument is one of the values read from the input table.</p> <pre><code>local numbers = {1, 2, 3, 4, 5}\nlocal doubled = scope:ForValues(numbers, function(use, scope, num)\n    return num * 2\nend)\n</code></pre> <p>You can read the table of processed values using <code>peek()</code>:</p> <pre><code>local numbers = {1, 2, 3, 4, 5}\nlocal doubled = scope:ForValues(numbers, function(use, scope, num)\n    return num * 2\nend)\n\nprint(peek(doubled)) --&gt; {2, 4, 6, 8, 10}\n</code></pre> <p>The input table can be a state object. When the input table changes, the output will update.</p> <pre><code>local numbers = scope:Value({})\nlocal doubled = scope:ForValues(numbers, function(use, scope, num)\n    return num * 2\nend)\n\nnumbers:set({1, 2, 3, 4, 5})\nprint(peek(doubled)) --&gt; {2, 4, 6, 8, 10}\n\nnumbers:set({5, 15, 25})\nprint(peek(doubled)) --&gt; {10, 30, 50}\n</code></pre> <p>You can also <code>use()</code> state objects in your calculations, just like a computed.</p> <pre><code>local numbers = {1, 2, 3, 4, 5}\nlocal factor = scope:Value(2)\nlocal multiplied = scope:ForValues(numbers, function(use, scope, num)\n    return num * use(factor)\nend)\n\nprint(peek(multiplied)) --&gt; {2, 4, 6, 8, 10}\n\nfactor:set(10)\nprint(peek(multiplied)) --&gt; {10, 20, 30, 40, 50}\n</code></pre> <p>Anything added to the <code>scope</code> is cleaned up for you when the processed value is removed.</p> <pre><code>local names = scope:Value({\"Jodi\", \"Amber\", \"Umair\"})\nlocal shoutingNames = scope:ForValues(names, function(use, scope, name)\n    table.insert(scope, function()\n        print(\"Goodbye, \" .. name .. \"!\")\n    end)\n    return string.upper(name)\nend)\n\nnames:set({\"Amber\", \"Umair\"}) --&gt; Goodbye, Jodi!\n</code></pre> How ForValues optimises your code <p>Rather than creating a new output table from scratch every time the input table is changed, <code>ForValues</code> will try and reuse as much as possible to improve performance.</p> <p>Say you're measuring the lengths of an array of words:</p> <pre><code>local words = scope:Value({\"Orange\", \"Red\", \"Magenta\"})\nlocal lengths = scope:ForValues(words, function(use, scope, word)\n    return #word\nend)\n\nprint(peek(lengths)) --&gt; {6, 3, 7}\n</code></pre> <p>The word lengths don't depend on the position of the word in the array. This means that rearranging the words in the input array will just rearrange the lengths in the output array:</p> <p> </p> <p><code>ForValues</code> takes advantage of this - when input values move around, the output values will move around too, instead of being recalculated.</p> <p>Note that values are only reused once. For example, if you added another occurence of 'Orange', your calculation would have to run again for the second 'Orange':</p> <p> </p>"}]}